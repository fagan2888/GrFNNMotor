(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.0'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[   1102984,      32373]*)
(*NotebookOutlinePosition[   1205577,      35704]*)
(*  CellTagsIndexPosition[   1196509,      35431]*)
(*WindowFrame->Normal*)



Notebook[{
Cell["\<\
P   R   O   G   R   A   M   M   I   N   G 
     G   R   A   P   H   I   C   S 
           N   U   M   E   R   I   C   S  
                 S   Y   M   B   O   L   I   C   S\
\>", "VolumeLabel"],

Cell[TextData[{
  StyleBox["ADDITIONAL EXERCISES AND SOLUTIONS TO", "CHP",
    FontSize->23],
  StyleBox["\n", "CHP"],
  StyleBox["THE MATHEMATICA GUIDEBOOKS", "CHP",
    FontSize->25,
    FontWeight->"Bold"]
}], "ChapterNumber"],

Cell[CellGroupData[{

Cell["Remarks", "Section"],

Cell[TextData[{
  "This notebook contains exercises and the corresponding solutions in the \
style of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " ",
  StyleBox["GuideBooks. ",
    FontSlant->"Italic"],
  "It also uses stylesheet of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " ",
  StyleBox["GuideBooks ",
    FontSlant->"Italic"],
  "(\[Copyright] Springer\[Hyphen]Verlag, New York, 2004)."
}], "Text"],

Cell[TextData[{
  "The latest version of this notebook is available from  ",
  ButtonBox["http://www.MathematicaGuideBooks.org",
    ButtonData:>{
      URL[ "http://www.MathematicaGuideBooks.org"], None},
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[TextData[{
  "To avoid the download of large notebooks, all outputs, graphics, and \
animations have been deleted. To recreate them, evaluate one solution at a \
time. It is highly recommended to quite and restart the kernel after each \
solution is fully evaluated. The code is tailored for ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " version 5.0.1."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Graphics Volume, Chapter 1", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Stick Breaking"
}], "ExerciseHeading"],

Cell[TextData[{
  "Given a list of real numbers ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["p", "1"], ",", 
            SubscriptBox["p", "2"], ",", "\[Ellipsis]", ",", 
            SubscriptBox["p", "n"]}], "}"}], TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "n"], 
            SubscriptBox["p", "k"]}], "=", "1"}], TraditionalForm]]],
  ", interpret ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "k"], TraditionalForm]]],
  " as the probability to break a 1D stick ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"a", ",", "b"}], "}"}], TraditionalForm]]],
  " into ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  " parts at ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "-", "1"}], TraditionalForm]]],
  " randomly chosen points from the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"a", ",", "b"}], "]"}], TraditionalForm]]],
  ". Starting with the stick ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0", ",", "1"}], "}"}], TraditionalForm]]],
  ", repeatedly breaking all nontrivially broken sticks (meaning once a piece \
of a stick was trivially \
\[OpenCurlyDoubleQuote]broken\[CloseCurlyDoubleQuote] with probability ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "1"], TraditionalForm]]],
  " into one part, it will no longer be considered for further breaking) as \
long as the stick piece is longer than a minimal length ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["l", "min"], TraditionalForm]]],
  ". Implement a one\[Hyphen]liner that carries out the stick breaking. Model \
the breaking for the probabilities ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0.5", ",", "0.5"}], "}"}], TraditionalForm]]],
  ", such that more than 1000 broken pieces result. Visualize the resulting \
stick pieces."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "Here is a straightforward recursive one\[Hyphen]liner for breaking a \
stick. The result of ",
  StyleBox["breakStick", "MR"],
  " is a nested list, whose elements at level ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"-", "2"}], "}"}], TraditionalForm]]],
  " are the resulting stick pieces."
}], "SolutionSubgroup"],

Cell[TextData[{
  "breakStick[{a_, b_}, pList_, lMin_] :=\nIf[",
  StyleBox["(* is stick longer than minimal length? *)", "CodeComment"],
  " b - a <= lMin, {a, b}, \n   If[Length[#] === 1, {#[[1]]},\n      ",
  StyleBox["(* break recursively *)", "CodeComment"],
  "\n      breakStick[#, pList, lMin]& /@ #]&[",
  StyleBox["(* random break points in [a, b] *)", "CodeComment"],
  "\n       Partition[Flatten[{a, Sort[Table[Random[Real, {a, b}], \n        \
",
  StyleBox["(* number of break points *)", "CodeComment"],
  "\n        {Position[Rest[FoldList[Plus, 0, \n                  ",
  StyleBox["(* normalize *)", "CodeComment"],
  " pList/(Plus @@ pList)]], \n                  PatternTest[_, ",
  StyleBox["(* random number for break points *)", "CodeComment"],
  "\n                                 Evaluate[Evaluate[# > Random[]]&]], \n  \
                             {1}, 1][[1, 1]] - 1}]], b}], 2, 1]]]"
}], "Input"],

Cell["\<\
In the following example, exactly one nontrivial breaking process \
occurs.\
\>", "Text"],

Cell["\<\
SeedRandom[8]
breakStick[{0, 1}, {1/2, 1/2}, 0]\
\>", "Input"],

Cell["\<\
In the next example three breaks occur and we have four pieces at \
the end.\
\>", "Text"],

Cell["\<\
SeedRandom[124]
breakStick[{0, 1}, {1/2, 1/2}, 0]\
\>", "Input"],

Cell[TextData[{
  "To generate 1000 pieces for the probabilities ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0.5", ",", "0.5"}], "}"}], TraditionalForm]]],
  ", we need a a suitable seed. The next input searches for such a seed."
}], "Text"],

Cell["\<\
Module[{r = 1, o = 2, max = 0, maxr = 0, \[CapitalLambda] = 10^3, \
\[Lambda]},
 While[SeedRandom[r]; 
       \[Lambda] = Length[Level[breakStick[{0, 1}, Table[1/o, {o}], 0], \
{-2}]];
           If[\[Lambda] > max, max = \[Lambda]; maxr = r]; \[Lambda] < \
\[CapitalLambda], r++]; r]\
\>", "Input"],

Cell[TextData[{
  "To visualize the broken sticks, we display their starting and ending \
positions ,long the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis and display the time at which the break occurs vertically."
}], "Text"],

Cell["\<\
stickPieceGraphics[brokenSticks_] := 
Graphics[MapIndexed[Function[{i, p}, Line[{#, Length[p]}& /@ i]], 
                    brokenSticks, {-2}], 
        Frame -> True, PlotRange -> All];\
\>", "Input"],

Cell["\<\
Here is the above breaking process and two others visualized.\
\>", \
"Text"],

Cell["\<\
Show[GraphicsArray[stickPieceGraphics /@
{SeedRandom[162];  breakStick[{0, 1}, {1/2, 1/2}, 0],
 SeedRandom[ 89];  breakStick[{0, 1}, {1/3, 1/3, 1/3}, 10^-6],
 SeedRandom[  3];  breakStick[{0, 1}, {1/4, 1/4, 1/4, 1/4}, 10^-6]}]]\
\>", \
"Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Rotating Aperiodic Tiling Polygons Animation"
}], "ExerciseHeading"],

Cell["\<\
Take (a part of) an aperiodic tiling. Make an animation that \
rotates the polygons of the tiling around all inner points of the \
tiling.\
\>", "Text"],

Cell[CellGroupData[{

Cell["We use the substitution tiling from Section 1.5.5.", "SolutionSubgroup"],

Cell[TextData[{
  StyleBox["(* avoid setting this option for each single graphic *)", 
    "CodeComment"],
  "\nSetOptions[Graphics, AspectRatio -> Automatic];"
}], "Input"],

Cell["\<\
startRhombusA = {{{{1, 0}, {1, 0} + {Cos[72\[Degree]], Sin[72\
\[Degree]]}, 
                   {Cos[72\[Degree]], Sin[72\[Degree]]}, {0, 0}, {1, 0}}, \"A\
\"}};
                   
startRhombusB = {{{{0, 0}, {1, 0}, {1, 0} + {Cos[36\[Degree]], \
Sin[36\[Degree]]}, 
                   {Cos[36\[Degree]], Sin[36\[Degree]]}, {0, 0}}, \
\"B\"}};\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* some often occurring rotation matrices *)", "CodeComment"],
  "\n\[Phi] = 1/(2 Cos[Pi/10]);\nrm54  = {{ Cos[-54\[Degree]], Sin[-54\
\[Degree]]}, {-Sin[-54\[Degree]], Cos[-54\[Degree]]}};\nrmp18 = {{ Cos[ 18\
\[Degree]], Sin[ 18\[Degree]]}, {-Sin[ 18\[Degree]], Cos[ 18\[Degree]]}};\n\
rmm18 = {{ Cos[-18\[Degree]], Sin[-18\[Degree]]}, {-Sin[-18\[Degree]], \
Cos[-18\[Degree]]}};\n\nruleA := {{p1_, p2_, p3_, p4_, p1_}, \"A\"} :>\n\
Module[{p5, p6, p7, p8, p9}, ",
  StyleBox["(* new points *)", "CodeComment"],
  "\n       p5 = p4 + \[Phi] rm54.(p1 - p4); p6 = p4 + \[Phi] rmp18.(p1 - \
p4);\n       p7 = p5 + (p1 - p4); p8 = p6 + (p3 - p4); p9 = p5 + p6 - p4;\n   \
   Sequence @@ ",
  StyleBox["(* delete braces *)", "CodeComment"],
  "\n            {{{p5, p4, p6, p9, p5}, \"A\"}, {{p8, p3, p5, p9, p8}, \
\"A\"},\n             {{p7, p2, p8, p9, p7}, \"A\"}, {{p6, p1, p7, p9, p6}, \
\"B\"}}]"
}], "Input"],

Cell[TextData[{
  "ruleB := {{p1_, p2_, p3_, p4_, p1_}, \"B\"} :>\nModule[{p5, p6, p7, p8}, \
",
  StyleBox["(* new points *)", "CodeComment"],
  "\n       p7 = p1 + \[Phi] rm54.(p2 - p1); p5 = p1 + \[Phi] rmp18.(p2 - \
p1);\n       p6 = p2 + \[Phi] rmm18.(p3 - p2); p8 = p5 + p7 - p1;\n       \
Sequence @@ ",
  StyleBox["(* delete braces *)", "CodeComment"],
  "\n      {{{p7, p1, p5, p8, p7}, \"A\"}, {{p6, p4, p7, p8, p6}, \"B\"},\n   \
    {{p5, p2, p6, p8, p5}, \"B\"}}]"
}], "Input"],

Cell["\<\
In the following, we use the tiling at level 6. It has 725 \
polygons.\
\>", "Text"],

Cell["\<\
s[1] = N[startRhombusA, 30];
s[i_] := s[i] = s[i - 1] /. {ruleA, ruleB}\
\>", "Input"],

Cell[TextData[{
  "The polygons and the types of the polygons we collect in the two list ",
  StyleBox["polys", "MR"],
  " and ",
  StyleBox["polysTypes", "MR"],
  "."
}], "Text"],

Cell["\<\
polys = Polygon[Drop[First[#], -1]]& /@ N[s[6]];
polysTypes = Last /@ s[6];\
\>", "Input"],

Cell[TextData[{
  "Out of the 790 vertices of the tiling 128 are not inner ones. We find the \
boundary vertices by counting how frequently the edges of all polygons occur. \
",
  StyleBox["outerVertex[", "MR"],
  StyleBox["point", "TI"],
  StyleBox["]", "MR"],
  " yields ",
  StyleBox["True", "MR"],
  " for if point is a vertex on the boundary."
}], "Text"],

Cell["Length[vertices = Union[Level[polys, {-2}]]]", "Input"],

Cell[TextData[{
  StyleBox["(* group identical line segments of the tiling *)", 
    "CodeComment"],
  "\nsegments = Split[Sort[Sort /@ Flatten[Partition[Append[#[[1]], \n        \
          #[[1, 1]]], 2, 1]& /@ Take[polys, All], 1]]];\n",
  StyleBox["(* mark boundary polygons *)", "CodeComment"],
  "\nIf[Length[#] === 1, (boundaryVertex[#] = True)& /@ #[[1]]]& /@ segments; \
"
}], "Input"],

Cell[TextData[{
  "The list ",
  StyleBox["poly\[Tau]Data", "MR"],
  " contains the rotation centers, the polygons to be rotated, the rotation \
angles, and the colors of the polygons. The parameter ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  " is the animation parameter and is assumed to vary from 0 to 1."
}], "Text"],

Cell[TextData[{
  "poly\[Tau]Data = Table[\n{",
  StyleBox["(* all inner vertices *)", "CodeComment"],
  "\n DeleteCases[polys[[k]][[1]], _?boundaryVertex], polys[[k]],\n ",
  StyleBox["(* color the two polygon types differently *)", "CodeComment"],
  "\n If[polysTypes[[k]] === \"A\", 1, -1] 2Pi \[Tau], If[polysTypes[[k]] === \
\"A\", 0, 0.78] + \[Tau]},\n {k, Length[polys]}];"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["makecoloredRotatedPolygon", "MR"],
  " rotates the polygons and adds the ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  "\[Hyphen]dependent coloring."
}], "Text"],

Cell[TextData[{
  "makecoloredRotatedPolygon[{mps_, poly_, \[CurlyPhi]_, c_}, \[Tau]c_] := \n\
With[{",
  StyleBox["(* rotation matrix *)", "CodeComment"],
  "\n      \[ScriptCapitalR] = {{Cos[#], Sin[#]}, {-Sin[#], Cos[#]}}&[\
\[CurlyPhi] /. \[Tau] -> \[Tau]c]},\n {Hue[c /. \[Tau] -> \[Tau]c], {#, \
{GrayLevel[0], # /. \n                         Polygon[l_] :> Line[Append[l, \
First[l]]]}}&[\n  ",
  StyleBox["(* rotate around al inner vertices *)", "CodeComment"],
  "\n  Function[mp, Map[(mp + \[ScriptCapitalR].(# - mp))&, poly, {-2}]] /@ \
mps]}]"
}], "Input"],

Cell["\<\
rotatedTilingFrame[\[Tau]_] := 
Graphics[{Thickness[0.001],  makecoloredRotatedPolygon[#, \[Tau]]& /@ poly\
\[Tau]Data},
        AspectRatio -> Automatic, PlotRange -> {{-0.12, 1.5}, {-0.26, 1.1}}];\
\
\>", "Input"],

Cell["Here is the resulting animation.", "Text"],

Cell["Show[GraphicsArray[rotatedTilingFrame /@ {0, 0.3, 0.5}]]", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_RotatingTiling.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
frames = 120;
Do[Show[rotatedTilingFrame[\[Tau]]], {\[Tau], 0, 1 - 1/frames, \
1/frames}]\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Circles Along Curves Animation"
}], "ExerciseHeading"],

Cell["\<\
Take a discretized curve and draw circles through the midpoints of \
the lines connecting successive neighbors. Make an animation showing how the \
resulting collection of circles changes as the original curve morphs from one \
Lissajou figure to another.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "It is straightforward to implement a frame of such an animation. We \
interpolate linearly between two curves ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"cos", "(", 
              RowBox[{"5", "\[CurlyPhi]"}], ")"}], ",", 
            RowBox[{"sin", "(", 
              RowBox[{"3", "\[CurlyPhi]"}], ")"}]}], "}"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"cos", "(", 
              RowBox[{"3", "\[CurlyPhi]"}], ")"}], ",", 
            RowBox[{"sin", "(", 
              RowBox[{"5", "\[CurlyPhi]"}], ")"}]}], "}"}], 
        TraditionalForm]]],
  ". To match the beginning and final configurations, we rotate the whole \
arrangement as a function of the animation parameter. The list ",
  StyleBox["\[CurlyPhi]Values", "MR"],
  " determines the points on the parametrized curve."
}], "SolutionSubgroup"],

Cell[TextData[{
  "frame[\[Alpha]_, \[CurlyPhi]Values_, m_, f_:1] := \n\
With[{\[ScriptCapitalR] = {{ #1, #2}, {-#2, #1}}&[Cos[f \[Alpha] Pi/2], Sin[f \
\[Alpha] Pi/2]] // N,\n      o = Length[\[CurlyPhi]Values]},\n\
Graphics[{Thickness[0.0001], ",
  StyleBox["(* color circles *)", "CodeComment"],
  "\nMapIndexed[{Hue[\[Alpha] + 1.8 (#2[[1]] - 1)/m], #}&,\nReverse[Table[",
  StyleBox["(* the circles *)", "CodeComment"],
  "\n Circle[\[ScriptCapitalR].Plus[##]/2, Sqrt[#.#]&[(#1 - #2)]/2]&[#[[1]], \
#[[-1]]]& /@\n  Table[Take[#, {i, i + n}], {i, o}]&[\n         Join[#, \
Take[#, n]]], {n, 2, m}]&[\n    ",
  StyleBox["(* linear interpolation between the two curves *)", 
    "CodeComment"],
  "\n    ((1 - \[Alpha]){Cos[5 #], Sin[3 #]} + \[Alpha]{Cos[3 #], Sin[5 #]})& \
/@ \[CurlyPhi]Values]]]},\n     PlotRange -> {{-1.5, 1.5}, {-1.7, 1.7}}, \
AspectRatio -> Automatic]]"
}], "Input"],

Cell["\<\
Here are two animations. The left uses equidistant points on the \
curve, and the right uses 384 randomly selected points on the curve.\
\>", \
"Text"],

Cell[TextData[{
  "SeedRandom[123];\nModule[{",
  StyleBox["(* animation parameters *)", "CodeComment"],
  " frames = 6, circles = 17,\n        \[CurlyPhi]Values1 = 2Pi \
Range[256]/256.,\n        \[CurlyPhi]Values2 = 2Pi Sort[Table[Random[], \
{384}]]},\nDo[Show[GraphicsArray[\n        {frame[k/frames, \
\[CurlyPhi]Values1, circles], \n         frame[k/frames, \[CurlyPhi]Values2, \
circles, -1]}]],\n   {k, frames}]];"
}], "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_CirclesAlongCurves.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel",
  GeneratedCell->False],

Cell[TextData[{
  "SeedRandom[123];\nModule[{",
  StyleBox["(* animation parameters *)", "CodeComment"],
  " frames = 60, circles = 17,\n        \[CurlyPhi]Values1 = 2Pi \
Range[256]/256.,\n        \[CurlyPhi]Values2 = 2Pi Sort[Table[Random[], \
{384}]]},\nDo[Show[GraphicsArray[\n        {frame[k/frames, \
\[CurlyPhi]Values1, circles], \n         frame[k/frames, \[CurlyPhi]Values2, \
circles, -1]}]],\n   {k, frames}]];"
}], "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Graphics Volume, Chapter 2", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Rotating Textured M\[ODoubleDot]bius Bands"
}], "ExerciseHeading"],

Cell["\<\
Make an animation of two interlocking rotating M\[ODoubleDot]bius \
bands having a pattern mapped onto them.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by defining two M\[ODoubleDot]bius bands. The band ",
  StyleBox["moebiusXY", "MR"],
  " lies in the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]plane and for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyTheta]", "=", "0"}], TraditionalForm]]],
  " the band ",
  StyleBox["moebiusXZ", "MR"],
  " lies in the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]plane. The parameter ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"\[Delta]", 
            StyleBox["x",
              FontSlant->"Italic"]}]], TraditionalForm]]],
  " shifts the band along the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " direction and the parameter ",
  Cell[BoxData[
      FormBox["\[CurlyTheta]", TraditionalForm]]],
  " rotates around the ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]axis. The parameter ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"\[CurlyPhi]", 
            StyleBox["0",
              FontSlant->"Italic"]}]], TraditionalForm]]],
  " determines the initial orientation of the line segment that sweeps out \
the M\[ODoubleDot]bius bands."
}], "SolutionSubgroup"],

Cell[TextData[{
  "moebiusXY[{u_, \[Omega]_}, \[CurlyPhi]0_] = ",
  StyleBox["(* rotate segment around z-axis *)", "CodeComment"],
  "\n{{Cos[\[Omega]], Sin[\[Omega]], 0}, {-Sin[\[Omega]], Cos[\[Omega]], 0}, \
{0, 0, 1}}.\n({1, 0, 0} + ",
  StyleBox["(* rotate line segment *)", "CodeComment"],
  "\n {{Cos[\[Omega]/2], 0, Sin[\[Omega]/2]}, {0, 1, 0}, {-Sin[\[Omega]/2], \
0, Cos[\[Omega]/2]}}.\n (u {Cos[\[CurlyPhi]0], 0, Sin[\[CurlyPhi]0]}));\n \n\
moebiusXZ[{u_, \[Omega]_}, \[CurlyPhi]0_, \[CurlyTheta]_, \[Delta]x_] = ",
  StyleBox["(* rotate band around z-axis *)", "CodeComment"],
  "\n          {{Cos[\[CurlyTheta]], Sin[\[CurlyTheta]], 0}, {-Sin[\
\[CurlyTheta]], Cos[\[CurlyTheta]], 0}, {0, 0, 1}}.\n          ({\[Delta]x, \
0, 0} + {#1, #3, #2}& @@ moebiusXY[{u, \[Omega]}, \[CurlyPhi]0]);"
}], "Input"],

Cell[TextData[{
  "A continuous pattern on the M\[ODoubleDot]bius band must be antisymmetric \
with respect to the variable ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " around ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Omega]", "=", "\[Pi]"}], TraditionalForm]]],
  ". Here we define two such functions depending on the parameter ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  " that are random linear combinations of trigonometric terms."
}], "Text"],

Cell["\<\
SeedRandom[1];
{randomPatternXY[\[Tau]_][u_, \[Omega]_], randomPatternXZ[\[Tau]_][u_, \
\[Omega]_]} = 
Table[Sum[Random[Real, {-1, 1}] Cos[k 2Pi \[Tau] + 2 Pi Random[]]*
                 Cos[(i + 1/2) \[Omega]] Sin[j u/L],
          {i, 0, 3}, {j, 0, 2}, {k, 0, 2}], {2}];\
\>", "Input"],

Cell["\<\
Here is the resulting animation. We rotate the initial segments of \
the bands and the second band, and change the pattern as we rotate.\
\>", \
"Text"],

Cell[TextData[{
  "frame[\[CurlyPhi]0_] := \nBlock[{L = 1/2}, Show[",
  StyleBox["(* the band in the x,y-plane *)", "CodeComment"],
  "\nParametricPlot3D[#, {u, -L, L}, {\[Omega], 0, 2Pi},\n               \
PlotPoints -> {90, 240}, DisplayFunction -> Identity]& /@\n     {",
  StyleBox["(* the band in the x,y-plane *)", "CodeComment"],
  "\n      Append[moebiusXY[{u, \[Omega]}, \[CurlyPhi]0], ",
  StyleBox["(* the pattern *)", "CodeComment"],
  "\n             {EdgeForm[], SurfaceColor[Hue[#], Hue[#], 2.6]& @ \n        \
                  randomPatternXY[\[CurlyPhi]0/Pi][u, \[Omega]]}],\n      ",
  StyleBox["(* the perpendicular band *)", "CodeComment"],
  "\n      Append[moebiusXZ[{u, \[Omega]}, \[CurlyPhi]0, 2\[CurlyPhi]0, 1], \
",
  StyleBox["(* the pattern *)", "CodeComment"],
  "\n               {EdgeForm[], SurfaceColor[Hue[#], Hue[#], 2.6]& @ \n      \
         randomPatternXZ[\[CurlyPhi]0/Pi][u, \[Omega]]}]},\n           \
PlotRange -> {5/2 {-1, 1}, 5/2 {-1, 1}, 3/2 {-1, 1}}, \n           Axes -> \
False,  DisplayFunction -> $DisplayFunction, \n           Boxed -> False]]"
}], "Input"],

Cell["\<\
Show[GraphicsArray[
      Block[{$DisplayFunction = Identity},
            frame /@ {0, Pi/4, Pi/2}], GraphicsSpacing -> 0]]\
\>", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_RotatingMoebiusBands.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Do[frame[\[CurlyPhi]0], {\[CurlyPhi]0, 0, Pi, Pi/60}]\
\>", \
"Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Rotating Tori with Tilings"
}], "ExerciseHeading"],

Cell["\<\
Map (a part of) an aperiodic tiling onto a torus. Then make an \
animation in which two such tori are rotating and display them together with \
their three projections into the coordinate planes.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with a part of an aperiodic tiling. The list ",
  StyleBox["tilingPolys", "MR"],
  " contains the corresponding 2D polygons."
}], "SolutionSubgroup"],

Cell[TextData[{
  "tilingPolys  = \nModule[{order = 4, \[ScriptS] = Sqrt[2]},\n",
  StyleBox["(* subdivision of the rhomb *)", "CodeComment"],
  "\nsubdivide[Polygon[{p1_, p2_, p3_, p4_}]] :=\nModule[{p5, p6, p7, p8, p9, \
p10}, ",
  StyleBox["(* new vertices *)", "CodeComment"],
  "\n p5 = p1 + (\[ScriptS] - 1) (p2 - p1); p6 = p2 + (2 - \[ScriptS]) (p3 - \
p2);\n p7 = p3 + (\[ScriptS] - 1) (p4 - p3); p8 = p4 + (2 - \[ScriptS]) (p1 - \
p4);\n p9 = p5 - p1 + p8; p10 = p6 + p7 - p3;\n ",
  StyleBox["(* 3 new rhombi and 4 new triangles *)", "CodeComment"],
  "\n Polygon /@ {{p1, p5, p9, p8}, {p3, p7, p10, p6},\n             {p2, p9, \
p4, p10}, {p9, p5, p2},\n             {p10, p6, p2}, {p10, p7, p4}, {p9, p8, \
p4}}];\n",
  StyleBox["(* subdivision of the triangle *)", "CodeComment"],
  "\nsubdivide[Polygon[{p1_, p2_, p3_}]] :=\nModule[{p5, p6, p7, p8}, ",
  StyleBox["(* new vertices *)", "CodeComment"],
  "\n p4 = p1 + (\[ScriptS] - 1) (p2 - p1);  p5 = p2 + 1/(\[ScriptS] + 2) (p3 \
- p2);\n p6 = p2 + 1/\[ScriptS] (p3 - p2); p7 = p3 + (\[ScriptS] - 1) (p1 - \
p3);\n p8 = p6 + p7 - p3;\n",
  StyleBox["(* 2 new rhombi and 3 new triangles *)", "CodeComment"],
  "\n Polygon /@ {{p5, p8, p1, p4}, {p3, p7, p8, p6},\n             {p5, p4, \
p2}, {p8, p6, p5}, {p8, p7, p1}}];\n",
  StyleBox["(* the initial rhomb *)  ", "CodeComment"],
  "\nstartRhombus = Polygon[{{0, 0}, {2, 0}, {2 + \[ScriptS], \[ScriptS]}, {\
\[ScriptS], \[ScriptS]}}/2];\n",
  StyleBox["(* polygons of the tesselation *)  ", "CodeComment"],
  "\nNest[Flatten[subdivide /@ #]&, N[{startRhombus}], order]];"
}], "Input"],

Cell[TextData[{
  "The next graphic shows the resulting list of triangles and quadrilaterals. \
The pairs of triangles facing each other along their longest side form one \
quadrilateral of the tiling. The left edge of the patch adjoins to its the \
right edge. To fit upper edge to the lower we slightly shift the patch to the \
right with increasing ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]values. We map the resulting list of polygons ",
  StyleBox["polys1", "MR"],
  " onto a torus."
}], "Text"],

Cell["\<\
Show[Graphics[Function[p, 
              With[{mp = Plus @@ p[[1]]/Length[p[[1]]], f = 0.8},  
                   Polygon[mp + f (# - mp)& /@ p[[1]]]]] /@ 
     (tilingPolys1 = Apply[{#1 + (1 - Sqrt[2]/2)#2/(Sqrt[2]/2), Sqrt[2] #2}&, \

      N[tilingPolys], {-2}])],   AspectRatio -> Automatic, Frame -> \
True]\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["toTorus", "MR"],
  " parametrizes a torus. By interpreting the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}], TraditionalForm]]],
  "\[Hyphen]coordinates of ",
  StyleBox["tilingPolys1", "MR"],
  " as ",
  Cell[BoxData[
      FormBox[
        StyleBox["\[CurlyPhi]1",
          "TI"], TraditionalForm]]],
  "\[Hyphen] and ",
  Cell[BoxData[
      FormBox[
        StyleBox["\[CurlyPhi]2",
          "TI"], TraditionalForm]]],
  "\[Hyphen]values (for fixed ",
  StyleBox["r", "TI"],
  " and ",
  StyleBox["R", "TI"],
  "), we map the tiling onto the torus."
}], "Text"],

Cell[TextData[{
  StyleBox["(* mapping from plane to a torus *)  ", "CodeComment"],
  "\ntoTorus[\[CurlyPhi]_, \[CurlyTheta]_, R_, r_] = {R Cos[\[CurlyPhi]] + r \
Cos[\[CurlyPhi]] Cos[\[CurlyTheta]], \n                           R Sin[\
\[CurlyPhi]] + r Sin[\[CurlyPhi]] Cos[\[CurlyTheta]], r Sin[\[CurlyTheta]]};"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["polygonToTorus", "MR"],
  " cuts holes and colors the mapped polygons from the list ",
  StyleBox["tilingPolys1", "MR"],
  " to the torus. We color the triangles different from the quadrilaterals. \
In addition, we keep a copy of the 3D polygons without the holes in the \
expression ",
  StyleBox["C[", "MR"],
  StyleBox["\[Ellipsis]", "TI"],
  StyleBox["]", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the quadrilateral *)", "CodeComment"],
  "\npolygonToTorus[Polygon[{p1_, p2_, p3_, p4_}]] := \nModule[{mp = (p1 + p2 \
+ p3 + p4)/4, f = 0.6, \[Lambda], q1, q2, q3, q4,\n        sf = \
Sequence[SurfaceColor[RGBColor[1, 0.06, 0.1], \n                              \
     RGBColor[1, 0.06, 0.1], 2.5],\n                      EdgeForm[], \
GrayLevel[0], Thickness[0.001]]},  \n       ",
  StyleBox["(* inner points *)", "CodeComment"],
  "\n       {q1, q2, q3, q4} = (mp + f (# - mp))& /@ {p1, p2, p3, p4};\n      \
 {C[sf, Polygon[{p1, p2, p3, p4}], Line[{p1, p2, p3, p4, p1}]],\n       ",
  StyleBox["(* contracted polygons *)", "CodeComment"],
  "\n        {sf, Polygon /@ {{p1, p2, q2, q1}, {p2, p3, q3, q2}, \n          \
               {p3, p4, q4, q3}, {p4, p1, q1, q4}},\n         Line[{p1, p2, \
p3, p4, p1}], Line[{q1, q2, q3, q4, q1}]}}]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* the triangle *)", "CodeComment"],
  "\npolygonToTorus[Polygon[{p1_, p2_, p3_}]] := \nModule[{mp = (p2 + p3)/2, \
f = 0.6, q1, q2, q3,\n        sf = Sequence[SurfaceColor[RGBColor[1, 0.66, \
0.14], \n                                   RGBColor[1, 0.66, 0.14], 2.5],\n  \
                    EdgeForm[], GrayLevel[0.2], Thickness[0.001]]},  \n       \
",
  StyleBox["(* inner points *)", "CodeComment"],
  "\n       {q1, q2, q3} = (mp + f (# - mp))& /@ {p1, p2, p3};\n       {C[sf, \
Polygon[{p1, p2, p3}], Line[{p2, p1, p3}]],\n        ",
  StyleBox["(* contracted polygons *)", "CodeComment"],
  "\n        {sf, Polygon /@ {{p1, p2, q2, q1}, {p2, p3, q3, q2}, \n          \
               {p3, p1, q1, q3}},\n         Line[{p2, p1, p3}], Line[{q2, q1, \
q3}]}}]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["coloredTorusPolys", "MR"],
  " maps the polygons ",
  StyleBox["polys1", "MR"],
  " to the torus. The variable ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " determines the relative orientation of the tiling on the torus and by \
varying ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ", the torus effectively rotates. We chose the radii ",
  Cell[BoxData[
      FormBox["R", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["r", TraditionalForm]]],
  "so that we can interlock the tori without intersections."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the polygons of the torus *)  ", "CodeComment"],
  "\ncoloredTorusPolys[polys_, \[Omega]_] := polygonToTorus /@   \n\
Apply[toTorus[2Pi #1 + N[\[Omega]], 2Pi #2 + N[\[Omega]], 3, 11/8]&, polys, \
{-2}];"
}], "Input"],

Cell[TextData[{
  "Here are two pictures of the resulting tori for two values of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
     Graphics3D[DeleteCases[coloredTorusPolys[tilingPolys1, #], 
                       _C, Infinity], Boxed -> False]& /@ {0, Pi/2}]]\
\>", \
"Input"],

Cell[TextData[{
  "The function ",
  StyleBox["coloredTorusPairPolys", "MR"],
  " makes two orthogonal tori. We rotate the two tori by an angle ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " around the ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen] and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]axes."
}], "Text"],

Cell[TextData[{
  "coloredTorusPairPolys[polys_, \[Omega]_] := \nModule[{aux = \
coloredTorusPolys[polys, \[Omega]],\n        ",
  StyleBox["(* rotation matrix *)", "CodeComment"],
  "\n        \[ScriptCapitalR] = N[{{Cos[\[Omega]], Sin[\[Omega]], 0}, {-Sin[\
\[Omega]], Cos[\[Omega]], 0}, {0, 0, 1}}.\n              {{Cos[\[Omega]], 0, \
Sin[\[Omega]]}, {0, 1, 0}, {-Sin[\[Omega]], 0, Cos[\[Omega]]}}]},\n       ",
  StyleBox["(* shift and change orientation *) ", "CodeComment"],
  "      \n       {aux  /. (pl:(Polygon | Line))[l_] :> pl[{#1, #2 - 3/2, \
#3}& @@@ l],\n        aux  /. (pl:(Polygon | Line))[l_] :> pl[{#3, #1 + 3/2, \
#2}& @@@ l]} /.\n       ",
  StyleBox["(* rotate *) ", "CodeComment"],
  "(pl:(Polygon | Line))[l_] :> pl[\[ScriptCapitalR].#& /@ l]];"
}], "Input"],

Cell["\<\
Show[Graphics3D[DeleteCases[
     coloredTorusPairPolys[tilingPolys1, Pi/4], _C, Infinity]], Axes -> \
True];\
\>", "Input"],

Cell[TextData[{
  "It remains to implement the projections of the torus into the coordinate \
planes. The function ",
  StyleBox["projectedPolygon", "MR"],
  " does this. Instead of calculating true projections and explicitly \
calculating the visible polygons, the function ",
  StyleBox["projectedPolygon", "MR"],
  " effectively calculates squinched version of the torus with a finite \
thickness so small that they effectively appear two\[Hyphen]dimensional."
}], "Text"],

Cell[TextData[{
  "projectedPolygon[torusPolys_] := \nModule[{\[ScriptP] = torusPolys, L = 8, \
\[CurlyEpsilon] = 10^-8},\n",
  StyleBox["(* projection into the y-z-plane *)", "CodeComment"],
  "\nxP = Map[If[Head[#] === List, \n            {-L + 100 \[CurlyEpsilon] + \
\[CurlyEpsilon] #[[1]], #[[2]], #[[3]]}, #]&, \[ScriptP], {-2}];\n",
  StyleBox["(* projection into the x-z-plane *)", "CodeComment"],
  "\nyP = Map[If[Head[#] === List, \n            {#[[1]], +L - 100 \
\[CurlyEpsilon] - \[CurlyEpsilon] #[[2]], #[[3]]}, #]&, \[ScriptP], {-2}]; \n\
",
  StyleBox["(* projection into the x-y-plane *)", "CodeComment"],
  "\nzP = Map[If[Head[#] === List, \n            {#[[1]], #[[2]], -L + 100 \
\[CurlyEpsilon] + \[CurlyEpsilon] #[[3]]}, #]&, \[ScriptP], {-2}];\n",
  StyleBox["(* projection plane polygons *)", "CodeComment"],
  "\ncornerPolys = Polygon /@ \n{{{-L, -L, -L}, { L, -L, -L}, { L, L, -L}, \
{-L,  L, -L}},\n {{-L,  L, -L}, { L,  L, -L}, { L, L,  L}, {-L,  L,  L}},\n \
{{-L, -L, -L}, {-L,  L, -L}, {-L, L,  L}, {-L, -L,  L}}};\n",
  StyleBox["(* color all polygons *)", "CodeComment"],
  "\n{{SurfaceColor[RGBColor[0.70, 0.06, 0.63], \n               \
RGBColor[0.66, 0.52, 0.89], 4], cornerPolys}, \n ",
  StyleBox["(* reverse colors in projections *)", "CodeComment"],
  "\n {xP /. RGBColor[r_, g_, b_] -> RGBColor[1 - r, 1 - g, 1 - b], \n  yP /. \
RGBColor[r_, g_, b_] -> RGBColor[1 - g, 1 - b, 1 - r], \n  zP /. RGBColor[r_, \
g_, b_] -> RGBColor[1 - b, 1 - r, 1 - g]} /. \n                              \
GrayLevel[x_] -> GrayLevel[1 - x]}]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["torusGraphics3D", "MR"],
  " finally assembles all functions together and, for a given value of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ", generates one frame of the animation."
}], "Text"],

Cell[TextData[{
  "torusGraphics3D[\[Omega]_, opts___] := \nModule[{",
  StyleBox["(* polygons on the torus *)", "CodeComment"],
  " \n        aux = coloredTorusPairPolys[tilingPolys1, \[Omega]]},\n\
Graphics3D[{DeleteCases[aux, _C, Infinity], \n             ",
  StyleBox["(* the three projections *)", "CodeComment"],
  "\n             projectedPolygon[List @@@ Cases[aux, _C, Infinity]]},\n     \
      opts, Boxed -> False, ViewPoint -> {3, -3, 2},\n           PlotRange -> \
8.3 {{-1, 1}, {-1, 1}, {-1, 1}}]]"
}], "Input"],

Cell["Here is the resulting animation.", "Text"],

Cell["\<\
frames = 5;
Show[GraphicsArray[##]]& /@ Partition[
Table[torusGraphics3D[\[Omega]], {\[Omega], 0, 2Pi (1 - 1/frames), \
2Pi/frames}], 3]\
\>", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_RotatingTori.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
frames = 90;
Do[Show[torusGraphics3D[\[Omega]]], {\[Omega], 0, 2Pi (1 - 1/frames), \
2Pi/frames}]\
\>", "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "Another aperiodic pattern suited for mapping onto a torus is the labyrinth \
tiling [",
  
  CounterBox["BibliographyCounter", "Baake99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Baake99",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Yuan00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Yuan00",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Here is the labyrinth tiling of order six shown. The three occurring \
polygon shapes are colored in red, green, and blue."
}], "Text"],

Cell[TextData[{
  "labyrinthPolygons[order_Integer?Positive] := labyrinthPolygons[order] = \n\
Module[{abChain, grid1D, grid2D},\n ",
  StyleBox["(* chain of two symbols from iterating a substitution *)", 
    "CodeComment"],
  "\n abChain = Flatten[Nest[(# /. {a -> {b}, b -> {b, a, b}})&, {a}, \
order]];\n ",
  StyleBox["(* 1D grid *)", "CodeComment"],
  "\n grid1D = FoldList[Plus, 0, abChain /. {a -> 1, b -> GoldenRatio}];\n ",
  StyleBox["(* 2D tensor product grid *)", "CodeComment"],
  "\n grid2D = Outer[List, grid1D, grid1D];\n ",
  StyleBox["(* place polygons around odd-odd vertices  *)", "CodeComment"],
  "\n Flatten @ Table[If[(-1)^(i + j) === 1, {},\n                    \
Polygon[{grid2D[[i + 1, j]], grid2D[[i, j + 1]], \n                           \
  grid2D[[i - 1, j]], grid2D[[i, j - 1]]}]],\n                 {i, 2, \
Length[grid1D] - 1}, {j, 2, Length[grid1D] - 1}]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* color according to number of different edges *)", 
    "CodeComment"],
  "\ncolorQuadrilateral[p:Polygon[l_]] := {Hue[Length[Union[#.#& /@ \n   \
(Subtract @@@ Partition[Append[l, First[l]], 2, 1])]]/3], p}"
}], "Input"],

Cell["\<\
Show[Graphics[colorQuadrilateral /@ labyrinthPolygons[6]],
     PlotRange -> All, AspectRatio -> Automatic, Frame -> True,
     FrameTicks -> False];\
\>", "Input"],

Cell["\<\
We now use three copies of the labyrinth tiling of order five and \
map it onto a torus.\
\>", "Text"],

Cell[TextData[{
  "quadrilaterals = labyrinthPolygons[5];\n",
  StyleBox["(* translation length *)", "CodeComment"],
  "\n\[Lambda] = Sort[Union[Level[quadrilaterals, {4}]], #1 < #2&][[-2]];\n\
torusPattern = \n Flatten[Table[Map[(k {\[Lambda], 0} + #)&, \
Flatten[quadrilaterals], {3}], {k, 0, 2}]];"
}], "Input"],

Cell["\<\
Show[Graphics[colorQuadrilateral /@ torusPattern],
     PlotRange -> All, AspectRatio -> Automatic, 
     Frame -> True, FrameTicks -> None];\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* extension in x- and y-direction *)", "CodeComment"],
  "\n{xM, yM} = Sort[Union[#], #1 < #2&][[-2]]& /@ \n                    \
Transpose[Expand[Level[torusPattern, {3}]]];\n\
to\[CurlyPhi]1\[CurlyPhi]2Coordinates[{x_, y_}] := Sequence @@ (2Pi {x/xM, \
y/yM});"
}], "Input"],

Cell["\<\
quadrilateral3DColor[p_Polygon] := 
             SurfaceColor[#, #, 2.6]& @ colorQuadrilateral[p][[1]]\
\>", \
"Input"],

Cell["\<\
Show[Graphics3D[{EdgeForm[{Thickness[0.0001]}], \
quadrilateral3DColor[#], 
   Map[toTorus[to\[CurlyPhi]1\[CurlyPhi]2Coordinates[#], 3, 1]&, #, {2}]}& /@ \

       torusPattern], Boxed -> False]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Klein Bottle with Hexagonal Massive Wireframe"
}], "ExerciseHeading"],

Cell["\<\
Construct and visualize a Klein bottle whose surface consists of a \
massive hexagonal framework.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We use the parametrization ",
  Cell[BoxData[
      FormBox["\[Psi]", TraditionalForm]]],
  " of the Klein bottle from Subsection 2.3.4 that covers the whole surface."
}], "SolutionSubgroup"],

Cell["\<\
\[Psi][{t_, \[CurlyPhi]_}] = 
Module[{spine2D = {Sin[t]^4, 2 (Sin[t] + Sin[2t]/3)},
        radius = 1/6 + 1/8 (Sin[2t]^2)^(1/4) (Pi/2 - t),
        \[ScriptD]1 = {0, 0, 1}, \[ScriptT], \[ScriptD]2, spine3D},
        \[ScriptT] = #/Sqrt[#.#]&[D[spine2D, t]];
        \[ScriptD]2 = Append[Reverse[\[ScriptT]] {-1, 1}, 0];
        spine3D = Append[spine2D, 0];
        spine3D + radius (Cos[\[CurlyPhi]] \[ScriptD]1 + Sin[\[CurlyPhi]] \
\[ScriptD]2)];\
\>", "Input"],

Cell[TextData[{
  "Next, we create the list of hexagons that we want to map onto the Klein \
bottle surface. The coordinates of the vertices of the hexagons cover the \
parametrization domain ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"(", 
            RowBox[{"0", ",", "\[Pi]"}], ")"}], "\[Times]", 
          RowBox[{"(", 
            RowBox[{"0", ",", 
              RowBox[{"2", "\[Pi]"}]}], ")"}]}], TraditionalForm]]],
  ". Some vertices slightly stick out of this domain to fit into the \
corresponding hole on the opposite edge of the parametrization domain."
}], "Text"],

Cell[TextData[{
  "hexagonCarpet = \nWith[{",
  StyleBox["(* number of hexagon rows and columns *)", "CodeComment"],
  " m = 17, n = 73,\n      ",
  StyleBox["(* a unit hexagon *)", "CodeComment"],
  "\n      hexagon = Line[Table[{Cos[p], Sin[p]}, {p, 0, 2Pi, 2Pi/6}]]},\n    \
  ",
  StyleBox["(* map hexagons into parametrization domain of the Klein bottle \
*)", "CodeComment"],
  "\n      \[ScriptF][{x_, y_}] = {2 Pi (x + 1)/(3(n + 1))/2, \n              \
       Pi (y + Cos[Pi/6])/(Cos[Pi/6](m + 1))};\n     N[Map[\[ScriptF], #, \
{3}], 30]& @\n     ",
  StyleBox["(* array of hexagons *)", "CodeComment"],
  "\n     Flatten[{Table[Map[# + {3i, j Cos[Pi/6]}&, hexagon, {2}], \n        \
             {i, 0, n}, {j, 0, 2 m, 2}],\n              Table[Map[# + {3i + \
3/2, j Cos[Pi/6]}&, hexagon, {2}], \n                    {i, 0, n}, {j, 1, 1 \
+ 2m, 2}]}]];"
}], "Input",
  AspectRatioFixed->True],

Cell[TextData[{
  "With respect to the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]parametrization, the sticking \[Hyphen]out points map trivially \
into the corresponding holes. By the definition of a Klein bottle, this is \
not the case for the ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  "\[Hyphen]parametrization. We must account for the twist of ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["180", "\[Degree]"], TraditionalForm]]],
  " along the spine. The following 18 points have ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  "\[Hyphen]values greater than ",
  Cell[BoxData[
      FormBox["\[Pi]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
wrapAroundPoints = Union[Cases[hexagonCarpet, {_?(# > Pi&), _}, \
{3}]];
Length[wrapAroundPoints]\
\>", "Input"],

Cell[TextData[{
  "We realize the twist in the Klein bottle by using the parametrization ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Psi]", "(", 
          RowBox[{"{", 
            RowBox[{
              RowBox[{"t", " ", "mod", " ", "\[Pi]"}], ",", " ", 
              "\[CurlyPhi]"}], "}"}], ")"}], TraditionalForm]]],
  " and by stitching corresponding points appropriately together. The \
function ",
  StyleBox["\[Psi]Stitched", "MR"],
  " maps the hexagon edge ",
  StyleBox["Line[", "MR"],
  StyleBox["l", "TI"],
  StyleBox["]", "MR"],
  " correctly on to the Klein bottle."
}], "Text"],

Cell["\<\
\[Psi]1[{t_, \[CurlyPhi]_}] := If[t >= Pi, \[Psi][{t - Pi, \
\[CurlyPhi]}], \[Psi][{t, \[CurlyPhi]}]];
\[Psi]Ps = \[Psi]1 /@ wrapAroundPoints;\
\>", "Input"],

Cell[TextData[{
  "\[Psi]Stitched[Line[l_]] :=\nIf[",
  StyleBox["(* wrap around? *)", "CodeComment"],
  " Max[First /@ l] > Pi,\n  Module[{mp, \[DoubleStruckD]},\n   ",
  StyleBox["(* find point to connect to *)", "CodeComment"],
  "\n   mp = (Plus @@ #/Length[#])&[\[Psi]1 /@ Cases[Rest[l], {_?(# < Pi&), \
_}]];\n   \[DoubleStruckD] = \[Psi]Ps[[Position[#, Min[#]]&[#.#& /@ ((mp - \
#)& /@ \[Psi]Ps)][[1, 1]]]];\n   Line[MapAt[\[DoubleStruckD]&, \[Psi] /@ l, \
Position[l, {_?(# > Pi&), _}]]]],\n   ",
  StyleBox["(* no wrap around *)", "CodeComment"],
  " Line[\[Psi]1 /@ l]]"
}], "Input",
  AspectRatioFixed->True],

Cell[TextData[{
  StyleBox["hexagonTiledKleinBottle", "MR"],
  " is a list of polygons forming a Klein bottle made from hexagons."
}], "Text"],

Cell["\<\
hexagonTiledKleinBottle = Polygon @@@ (Map[\[Psi]Stitched, \
hexagonCarpet] // N);\
\>", "Input"],

Cell[TextData[{
  "Here are two views on the resulting Klein bottle. The right graphic shows \
that the hexagons were correctly mapped at the transition ",
  Cell[BoxData[
      FormBox[
        RowBox[{"t", "=", 
          RowBox[{"\[Pi]", "\[Implies]", 
            RowBox[{"t", "-", "0"}]}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
Graphics3D[{EdgeForm[Thickness[0.0001]], hexagonTiledKleinBottle}, 
            Boxed -> False, ##]& @@@ {{}, {ViewPoint -> {0, -2, 0}}}]]\
\>", \
"Input"],

Cell["\<\
We continue by constructing a massive wireframe along the edges of \
the hexagons. Because the size of the hexagons varies across the Klein bottle \
surface, so should the thickness of the massive wireframe. To thicken the \
hexagon edges in the direction approximately normal to the surface, we find \
the neighboring three vertices and erect a normal on the plane formed by \
these three neighbors. \
\>", "Text"],

Cell[TextData[{
  "To find all three neighbors of a given vertex quickly, we extract all \
edges and sort them. Then we define the function ",
  StyleBox["neighbors", "MR"],
  " for the 5328 vertices of the hexagons."
}], "Text"],

Cell[TextData[{
  "sortedEdgeList = ",
  StyleBox["(* extract and sort all edges *)", "CodeComment"],
  "\nUnion /@ Split[Sort[Flatten[{#, Reverse[#]}& /@ \n   \
Flatten[Partition[#[[1]], 2, 1]& /@ hexagonTiledKleinBottle, 1], 1]],\n       \
                          #1[[1]] === #2[[1]]&];\n                            \
     \n(neighbors[#[[1, 1]]] = Last /@ #)& /@ sortedEdgeList;\nallVertices = \
#[[1, 1, 1]]& /@ DownValues[neighbors];"
}], "Input"],

Cell[TextData[{
  "Given a vertex and its three neighbors, the function ",
  StyleBox["makeTetradNormal", "MR"],
  " gives the normal of the plane formed by the three neighbors."
}], "Text"],

Cell[TextData[{
  "makeTetradNormal[q_, {p1_, p2_, p3_}] := \nModule[{\[ScriptN] = \
#/Sqrt[#.#]&, d1, d2, v},\n       ",
  StyleBox["(* remove components in plane {p1, p2, p3} *)", "CodeComment"],
  "\n       d1 = \[ScriptN][p2 - p1]; d2 = \[ScriptN][p3 - p1]; d2 = \
\[ScriptN][d2 - d2.d1 d1];\n       v = q - p1; \[ScriptN][v - v.d1 d1 - v.d2 \
d2]]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["theNormal", "MR"],
  " gives the normal for a given vertex."
}], "Text"],

Cell["\<\
(theNormal[#] = makeTetradNormal[#, neighbors[#]])& /@ allVertices;\
\
\>", "Input"],

Cell[TextData[{
  "Now, we have all functions together to implement the function ",
  StyleBox["make3DBorder", "MR"],
  " that for a given hexagon forms the 2\[Times]2\[Times]6 polygons forming \
the massive wireframe. To guarantee that the polygons fit together \
appropriately, we make sure that the orientation is uniform and determine the \
thickness of the massive wireframe from the average distance to the three \
neighbor vertices."
}], "Text"],

Cell[TextData[{
  "make3DBorder[Polygon[l_], \[Alpha]_, \[Beta]_] := \nModule[{\[ScriptN] = \
#/Sqrt[#.#]&, mp = Plus @@ Rest[l]/6,\n        hexagonNormal, \[Lambda]s, \
pointNormals, L, \[ScriptL], \[ScriptCapitalL]},\n ",
  StyleBox["(* the averaged normal of the hexagon *)", "CodeComment"],
  "\n hexagonNormal  = \[ScriptN][Plus @@ (\[ScriptN][Cross[#1 - mp, #2 - \
mp]]& @@@ \n                                             Partition[l, 2, \
1])/6];\n",
  StyleBox["(* average hexagon edge length/2 *)", "CodeComment"],
  "\n \[Lambda]s  = (Function[p, Plus @@ (Sqrt[#.#& @ (p - #)]& /@ \n         \
                                  neighbors[p])] /@ l)/12;                    \
          \n ",
  StyleBox["(* normals at the vertices *)", "CodeComment"],
  "\n pointNormals = If[hexagonNormal.# < 0, -#, #]& /@ (theNormal /@ l);\n",
  StyleBox["(* contracted hexagon *)", "CodeComment"],
  "\n \[ScriptL] = (mp + \[Alpha] (# - mp))& /@ l;   \n Table[",
  StyleBox["(* move out of hexagon plane in normal directions *)", 
    "CodeComment"],
  "\n       {L, \[ScriptCapitalL]} = (# + sign \[Beta] \[Lambda]s \
pointNormals)& /@ {l, \[ScriptL]};\n       ",
  StyleBox["(* form polygons of beams *)", "CodeComment"],
  "\n       MapThread[Polygon[Join[#1, Reverse[#2]]]&, \n                 \
{Partition[#1, 2, 1],  Partition[#2, 2, 1]}]& @@@\n                           \
                       {{L, \[ScriptCapitalL]}, {\[ScriptL], \
\[ScriptCapitalL]}}, \n       ",
  StyleBox["(* up and down *)", "CodeComment"],
  " {sign, -1, 1, 2}]]"
}], "Input"],

Cell["\<\
Here are three original hexagons and the polygons forming the \
wireframe.\
\>", "Text"],

Cell[TextData[{
  "Module[{vertex = hexagonTiledKleinBottle[[100, 1, 1]],\n        \
threeNeighborHexagons},\n",
  StyleBox["(* the polygons sharing vertex *)", "CodeComment"],
  "\nthreeNeighborHexagons = hexagonTiledKleinBottle[[\n     Union[First /@ \
Position[hexagonTiledKleinBottle, vertex]]]];\n",
  StyleBox["(* original hexagons in red, wireframe polygons in yellow *)", 
    "CodeComment"],
  "\nShow[Graphics3D[\n{{SurfaceColor[Hue[0], Hue[0], 2.1], \
threeNeighborHexagons},\n {SurfaceColor[Hue[0.12], Hue[0.12], 2.1], \n  \
make3DBorder[#, 0.8, 0.8]& /@ threeNeighborHexagons}}]]]"
}], "Input"],

Cell[TextData[{
  "The list ",
  StyleBox["KleinBottlePolys", "MR"],
  " contains the 63936 polygons forming the massive hexagonal framework \
wireframe."
}], "Text"],

Cell["\<\
KleinBottlePolys = make3DBorder[#, 0.86, 0.6]& /@ \
hexagonTiledKleinBottle;\
\>", "Input"],

Cell["\<\
Here are views of the resulting Klein bottle and its cross section.\
\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nGraphics3D[{EdgeForm[], SurfaceColor[Hue[0.18], \
Hue[0.03], 1.3], \n            KleinBottlePolys},\n           ViewPoint -> \
{3/2, 2, 3}, ViewVertical -> {0, 1, 0}, \n           Boxed -> False, ##]& @@@ \
\n                    ",
  StyleBox["(* show all and cross section *)", "CodeComment"],
  "\n                    {{}, {PlotRange -> {All, All, {0, -0.3}}}}]]"
}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  4.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ",
  Cell[BoxData[
      FormBox["N", TraditionalForm]]],
  " Random Walkers in 3D"
}], "ExerciseHeading"],

Cell["\<\
Consider 1000 random walkers on a 3D cubic lattice, each making \
1000 steps. Carry out these walks and visualize the lattice points that have \
been visited and the ones that have not been visited. \
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "The function ",
  StyleBox["sitesVisitedByNRandomWalkers", "MR"],
  " returns a list of sites (points in 3D with integer coordinates) that were \
visited by ",
  StyleBox["n", "TI"],
  " walkers, each making ",
  StyleBox["steps", "TI"],
  " steps."
}], "SolutionSubgroup"],

Cell["\<\
sitesVisitedByNRandomWalkers[n_, steps_]  :=
Module[{pos, visitedQ,
        dirs = {{-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, 
                {0, 0, -1}, {0, 0, 1}}},
       Do[pos = {0, 0, 0};
          Do[pos = pos + dirs[[Random[Integer, {1, 6}]]];
             visitedQ[pos] = True, {steps}], {n}]; 
          #[[1, 1, 1]]& /@ DownValues[visitedQ]]\
\>", "Input"],

Cell["We start with 100 walkers, each making 100 steps.", "Text"],

Cell["\<\
SeedRandom[1];
Length[visitedSites = sitesVisitedByNRandomWalkers[100, 100]] // Timing\
\>", \
"Input"],

Cell[TextData[{
  "The function ",
  StyleBox["makeCube", "MR"],
  " returns the faces of the cube sitting at a lattice point ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y", ",", "z"}], "}"}], TraditionalForm]]],
  ". (To avoid rational numbers, we multiply all coordinates by 2.)"
}], "Text"],

Cell["\<\
makeCube[{x_, y_, z_}] :=  Map[(2{x, y, z} + #)&, 
  {{#8, #4, #2, #6}, {#8, #6, #5, #7}, {#8, #7, #3, #4}, 
   {#4, #3, #1, #2}, {#1, #3, #7, #5}, {#2, #1, #5, #6}}&[
  {-1, -1, -1}, {-1, -1, 1}, {-1, 1, -1}, {-1, 1, 1}, 
  { 1, -1, -1}, { 1, -1, 1}, { 1, 1, -1}, { 1, 1, 1}], {2}]\
\>", "Input"],

Cell["\<\
The outermost and the inner boundaries of the lattice points \
visited by the walkers are the cube faces occurring exactly once in the list \
of all cube faces.\
\>", "Text"],

Cell["\<\
makeBoundaryCubeFaces[visitedSites_] := #[[1, 2]]& /@ 
 Select[Split[Sort[{Plus @@ #/4, #}& /@ 
              Flatten[makeCube /@ visitedSites, 1]],
           #1[[1]] === #2[[1]]&], Length[#] === 1&];\
\>", "Input"],

Cell["boundaryCubeFaces = makeBoundaryCubeFaces[visitedSites];", "Input"],

Cell[TextData[{
  "To find the connected components of the surfaces, we associate the cube \
faces ",
  StyleBox["boundaryCubeFaces", "MR"],
  " to all of its edges."
}], "Text"],

Cell["\<\
edges[face_] := Sort /@ Partition[Append[face, face[[1]]], 2, \
1]\
\>", "Input"],

Cell["\<\
makeEdgesAndFaces[boundaryCubeFaces_] := 
({#[[1, 1]], Last /@ #}& /@ Split[
  Sort[Flatten[Function[f, {#, f}& /@ edges[f]] /@ 
     Take[boundaryCubeFaces, All], 1]], #1[[1]] === #2[[1]]&]);\
\>", "Input"],

Cell["edgesAndFaces = makeEdgesAndFaces[boundaryCubeFaces];", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["neighborFaces[", "MR"],
  StyleBox["edge", "TI"],
  StyleBox["]", "MR"],
  " returns a list of all faces sharing the edge ",
  StyleBox["edge", "TI"],
  "."
}], "Text"],

Cell["\<\
Function[{edge, faceList}, neighborFaces[edge] = faceList] @@@ \
edgesAndFaces;\
\>", "Input"],

Cell[TextData[{
  "Next, we separate the surface into its connected surface parts. The \
function ",
  StyleBox["makeConnectedSurfaces", "MR"],
  " does this by selecting recursively all faces that are connected through a \
common edge."
}], "Text"],

Cell[TextData[{
  "makeConnectedSurfaces[] := \nModule[{faceBags = {}, counter = 0, allEdges, \
xMax, startEdge,\n        currentFaces, newFaceBag, currentEdges, newFaces},\n\
Off[Unset::norep];\n",
  StyleBox["(* as long as there are unused edges *)", "CodeComment"],
  "\nWhile[DownValues[neighborFaces] =!= {}, \n",
  StyleBox["(* all remaining edges *)", "CodeComment"],
  "\nallEdges = #[[1, 1, 1]]& /@ DownValues[neighborFaces];\n",
  StyleBox["(* outermost edge *)", "CodeComment"],
  "\nxMax = Max[Transpose[Flatten[allEdges, 1]][[1]]];\nstartEdge = \
Select[allEdges, (#[[1, 1]] === xMax || \n                              #[[2, \
1]] === xMax)&, 1][[1]];\n",
  StyleBox["(* neighbor faces of startEdge *)", "CodeComment"],
  "\ncurrentFaces = neighborFaces[startEdge];\nneighborFaces[startEdge] =.;\n\
newFaceBag = {};\n",
  StyleBox["(* extend current surface part as long as possible *)", 
    "CodeComment"],
  "\nWhile[\n ",
  StyleBox["(* the edges of the current faces *)", "CodeComment"],
  "\n currentEdges = Flatten[edges /@ currentFaces, 1] // Union;\n ",
  StyleBox["(* new faces on the outside *)", "CodeComment"],
  "\n newFaces = DeleteCases[Flatten[neighborFaces /@ currentEdges, 1],\n     \
                   _neighborFaces] // Union;\n newFaces =!= {},\n ",
  StyleBox["(* keep outer layer of faces *)", "CodeComment"],
  "\n newFaceBag = {newFaceBag, newFaces};\n (neighborFaces[#]=.)& /@ \
currentEdges;\n currentFaces = newFaces];\n ",
  StyleBox["(* keep new component *)", "CodeComment"],
  "\n faceBags = {faceBags, Union[Level[newFaceBag, {-3}]]}];\n ",
  StyleBox["(* return connected components *)", "CodeComment"],
  " Level[faceBags, {-4}]]"
}], "Input"],

Cell["\<\
For the example under consideration, we have four components. The \
outermost one is clearly dominating in size. \
\>", "Text"],

Cell["\<\
walkSurfaces = makeConnectedSurfaces[];
{First[#], Length[#]}& /@ Split[Length /@ walkSurfaces]\
\>", "Input"],

Cell["\<\
Here are two graphics. The left graphic shows the outer boundary of \
all sites visited and the right graphic shows the not visited sites that are \
inside the left graphic.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* color polygon of one surface component \n   according to \
distance to the origin *)", "CodeComment"],
  "\ninOutColoredPolys[polys_] := \nModule[{polyDistances = {Sqrt[#.#]&[Plus \
@@ #/4], #}& /@ N[polys], \n        min, max},\n       {min, max} = {Min[#], \
Max[#]}&[First /@ polyDistances];\n       {SurfaceColor[#, #, 2.2]&[Hue[0.78 \
- 0.78 (#[[1]] - min)/(max - min)]], \n                                     \
Polygon[#[[2]]]}& /@ polyDistances];\n                                        \
      \n",
  StyleBox["(* randomly colored polygons *)", "CodeComment"],
  "\nrandomlyColorPolys[polys_] := \n{SurfaceColor[Hue[Random[]], \
Hue[Random[]], 3 Random[]], Polygon /@ polys}"
}], "Input"],

Cell[TextData[{
  "showWalkSurfaces[walkSurfaces_] := \nShow[GraphicsArray[\n{",
  StyleBox["(* color large component according to distance to the origin *)", 
    "CodeComment"],
  "\n Graphics3D[{EdgeForm[], inOutColoredPolys[First[walkSurfaces]]}, \n     \
      PlotRange -> All, Boxed -> False],\n ",
  StyleBox["(* color inner components randomly *)", "CodeComment"],
  "\n Graphics3D[{EdgeForm[], randomlyColorPolys /@ Rest[walkSurfaces]}, \n   \
         PlotRange -> All, Boxed -> False]}]];"
}], "Input"],

Cell["showWalkSurfaces[walkSurfaces];", "Input"],

Cell["\<\
Now, we repeat the above calculations with 1000 walkers, each \
taking 1000 steps. The walks can be carried out in less than half a minute on \
a 2 GHz computer.\
\>", "Text"],

Cell["\<\
SeedRandom[1];
Length[visitedSites = sitesVisitedByNRandomWalkers[1000, 1000]] // \
Timing\
\>", "Input"],

Cell["\<\
Repeating the steps from above, we obtain now 806 connected surface \
components.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* all cube faces *)", "CodeComment"],
  "\nboundaryCubeFaces = makeBoundaryCubeFaces[visitedSites];\n",
  StyleBox["(* edges and faces *)", "CodeComment"],
  "\nedgesAndFaces = makeEdgesAndFaces[boundaryCubeFaces];\n",
  StyleBox["(* make definitions for ", "CodeComment"],
  StyleBox["neighborFaces", "CodeComment"],
  StyleBox[" *)", "CodeComment"],
  "\nFunction[{edge, faceList}, neighborFaces[edge] = faceList] @@@ \
edgesAndFaces;\n",
  StyleBox["(* no longer needed *)", "CodeComment"],
  " Clear[edgesAndFaces];\nwalkSurfaces = makeConnectedSurfaces[];\n\
Length[walkSurfaces]"
}], "Input"],

Cell["\<\
Again, we have one large component representing the outermost \
visited sites and many small not visited sites in the inside. Here is a plot \
of the logarithm of the distribution.\
\>", "Text"],

Cell["\<\
ListPlot[{Length[#], Log @ First[#]}& /@ Split[Sort[Length /@ \
walkSurfaces]], 
         PlotRange -> All, Frame -> True, Axes -> False]\
\>", "Input"],

Cell["Here are the connected components.", "Text"],

Cell["showWalkSurfaces[walkSurfaces]", "Input"],

Cell["\<\
By calculating the volume and the surface area of the clusters for \
various number of walkers (=steps), we see that the surface roughness is \
approximately constant.\
\>", "Text"],

Cell["\<\
volumeSurfaceData = 
Table[{o, Length[#], Length[makeBoundaryCubeFaces[#]]}&[
                            sitesVisitedByNRandomWalkers[o, o]], 
      {o, 100, 1000, 100}]
      
N[Log[#3, #2]& @@@ volumeSurfaceData]\
\>", "Input"],

Cell[TextData[{
  "For many results on many random walkers, see [",
  
  CounterBox["BibliographyCounter", "Acedo03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Acedo03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  5.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " 2D Minkowski Function"
}], "ExerciseHeading"],

Cell[TextData[{
  "A possible 2D generalization of the classical Minkowski function from the \
triangles ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"0", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "1"}], "}"}]}], "}"}], TraditionalForm]]],
  " into the triangle ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"0", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "1"}], "}"}]}], "}"}], TraditionalForm]]],
  " is based on the following construction ",
  "[",
  
  CounterBox["BibliographyCounter", "Beaver04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Beaver04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Marder04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Marder04",
    ButtonStyle->"Hyperlink"],
  "]: Start with two copies of the triangle ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"0", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "0"}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{"1", ",", "1"}], "}"}]}], "}"}], TraditionalForm]]],
  " and recursively subdivide them into six new triangles by inserting a new \
point along each edge and one point in the interior. The four new points ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "1"], "\[CirclePlus]", 
          SubscriptBox["p", "2"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "1"], "\[CirclePlus]", 
          SubscriptBox["p", "3"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "2"], "\[CirclePlus]", 
          SubscriptBox["p", "2"]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "1"], "\[CirclePlus]", 
          SubscriptBox["p", "2"], "\[CirclePlus]", 
          SubscriptBox["p", "3"]}], TraditionalForm]]],
  ", are calculated through the generalized additions ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CirclePlus]", 
          RowBox[{"F", "/", "B"}]], TraditionalForm]]],
  " of the three vertices ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "2"], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "3"], TraditionalForm]]],
  "(with rational coordinates ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SubscriptBox["p", 
                RowBox[{"i", " ", "x"}]], "/", 
              SubscriptBox["r", 
                RowBox[{"i", " "}]]}], ",", 
            RowBox[{
              SubscriptBox["p", 
                RowBox[{"i", " ", "y"}]], "/", 
              SubscriptBox["r", 
                RowBox[{"i", " "}]]}]}], "}"}], TraditionalForm]]],
  " ) of a triangle according to two possible rules:"
}], "Text"],

Cell[TextData[{
  "a) the Farey addition ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CirclePlus]", "F"], TraditionalForm]]],
  ": "
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"{", 
            RowBox[{
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"i", " ", "x"}]], 
                SubscriptBox["r", 
                  RowBox[{"i", " "}]]], ",", 
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"i", " ", "y"}]], 
                SubscriptBox["r", 
                  RowBox[{"i", " "}]]]}], "}"}], 
          SubscriptBox["\[CirclePlus]", "F"], 
          RowBox[{"{", 
            RowBox[{
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"j", " ", "x"}]], 
                SubscriptBox["r", "j"]], ",", 
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"j", " ", "y"}]], 
                SubscriptBox["r", "j"]]}], "}"}]}], "=", 
        RowBox[{"{", 
          RowBox[{
            FractionBox[
              RowBox[{
                SubscriptBox["p", 
                  RowBox[{"i", " ", "x"}]], "+", 
                SubscriptBox["p", 
                  RowBox[{"j", " ", "x"}]]}], 
              RowBox[{
                SubscriptBox["r", 
                  RowBox[{"i", " "}]], "+", 
                SubscriptBox["r", "j"]}]], ",", 
            FractionBox[
              RowBox[{
                SubscriptBox["p", 
                  RowBox[{"i", " ", "y"}]], "+", 
                SubscriptBox["p", 
                  RowBox[{"j", " ", "y"}]]}], 
              RowBox[{
                SubscriptBox["r", 
                  RowBox[{"i", " "}]], "+", 
                SubscriptBox["r", "j"]}]]}], "}"}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "a) the Bary addition ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CirclePlus]", "B"], TraditionalForm]]],
  ": "
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"{", 
            RowBox[{
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"i", " ", "x"}]], 
                SubscriptBox["r", 
                  RowBox[{"i", " "}]]], ",", 
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"i", " ", "y"}]], 
                SubscriptBox["r", 
                  RowBox[{"i", " "}]]]}], "}"}], 
          SubscriptBox["\[CirclePlus]", "B"], 
          RowBox[{"{", 
            RowBox[{
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"j", " ", "x"}]], 
                SubscriptBox["r", "j"]], ",", 
              FractionBox[
                SubscriptBox["p", 
                  RowBox[{"j", " ", "y"}]], 
                SubscriptBox["r", "j"]]}], "}"}]}], "=", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              FractionBox["1", "2"], 
              RowBox[{"(", 
                RowBox[{
                  FractionBox[
                    SubscriptBox["p", 
                      RowBox[{"i", " ", "x"}]], 
                    SubscriptBox["r", 
                      RowBox[{"i", " "}]]], "+", 
                  FractionBox[
                    SubscriptBox["p", 
                      RowBox[{"j", " ", "x"}]], 
                    SubscriptBox["r", "j"]]}], ")"}]}], ",", 
            RowBox[{
              FractionBox["1", "2"], 
              RowBox[{"(", 
                RowBox[{
                  FractionBox[
                    SubscriptBox["p", 
                      RowBox[{"i", " ", "y"}]], 
                    SubscriptBox["r", 
                      RowBox[{"i", " "}]]], "+", 
                  FractionBox[
                    SubscriptBox["p", 
                      RowBox[{"j", " ", "y"}]], 
                    SubscriptBox["r", "j"]]}], ")"}]}]}], "}"}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "and both additions being associative ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["p", "1"], 
            SubscriptBox["\[CirclePlus]", 
              RowBox[{"F", "/", "B"}]], 
            SubscriptBox["p", "2"], 
            SubscriptBox["\[CirclePlus]", 
              RowBox[{"F", "/", "B"}]], 
            SubscriptBox["p", "3"]}], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                SubscriptBox["p", "1"], 
                SubscriptBox["\[CirclePlus]", 
                  RowBox[{"F", "/", "B"}]], 
                SubscriptBox["p", "2"]}], ")"}], 
            SubscriptBox["\[CirclePlus]", 
              RowBox[{"F", "/", "B"}]], 
            SubscriptBox["p", "3"]}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "The 2D Minowski map is then the limit ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "\[Rule]", "\[Infinity]"}], TraditionalForm]]],
  " of the map, that maps the two sets of identically ordered triangles after \
",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " subdivisions into each other."
}], "Text"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "4"}], TraditionalForm]]],
  " or ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "5"}], TraditionalForm]]],
  ", embed the map from the first triangle into the second in ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[DoubleStruckCapitalR]", "4"], TraditionalForm]]],
  " and make an animation showing projections of the resulting surface \
projected into 3D."
}], "Text"],

Cell[CellGroupData[{

Cell["\<\
We start by defining two plus operation functions, one for Farey \
addition, and one for Bary addition.\
\>", "SolutionSubgroup"],

Cell["\<\
FareyPlus[ps_List] := 
Module[{dens = Max /@ Denominator[ps], nums},
        nums = MapThread[Times, {dens, ps}];
      {Plus @@ (First /@ nums), Plus @@ (Last /@ nums)}/(Plus @@ dens)]\
\>", \
"Input"],

Cell["\<\
BaryPlus[ps_List] := {Plus @@ (First /@ ps), Plus @@ (Last /@ \
ps)}/Length[ps]\
\>", "Input"],

Cell["\<\
Next, given an triangle, we define its splitting into six new \
triangles according to the described rule.\
\>", "Text"],

Cell["\<\
sixNewTriangles[plus_, Polygon[{p1_, p2_, p3_}]] :=
Module[{p12 = plus[{p1, p2}], p13 = plus[{p1, p3}], p23 = plus[{p2, p3}],
        p123 = plus[{p1, p2, p3}]},
        Polygon /@ {{p1, p12, p123}, {p12, p2, p123}, {p2, p23, p123},
                    {p23, p3, p123}, {p3, p13, p123}, {p13, p1, p123}}]\
\>", \
"Input"],

Cell["\<\
Here are the first few recursive subdivisions in superimposed form \
for the Farey and the Bary addition.\
\>", "Text"],

Cell["\<\
With[{o = 4},
Show[GraphicsArray[
Function[plus, Graphics[{MapIndexed[{Hue[0.8 (#2[[1]] - 1)/(o + 1)], 
          Thickness[0.025 - 0.025 (#2[[1]] - 1)/o], #}&, 
          NestList[Flatten[sixNewTriangles[plus, #]& /@ #]&, 
                   {Polygon[{{0, 0}, {1, 0}, {1, 1}}]}, o]] /. 
                 Polygon[l_] :> Line[Append[l, First[l]]]}, 
             AspectRatio -> Automatic, Frame -> True, 
             FrameTicks -> False]] /@ {FareyPlus, BaryPlus}]]];\
\>", "Input"],

Cell["\<\
To better see the complicated structure of the triangulations, we \
color the triangles according to their smallest angles.\
\>", "Text"],

Cell["\<\
\[ScriptN] = #/Sqrt[#.#]&;

minMaxAngles[Polygon[{p1_, p2_, p3_}]] := 
Module[{n12 = \[ScriptN][p2 - p1], n13 = \[ScriptN][p3 - p1], n23 = \
\[ScriptN][p3 - p2]},
       {Min[#], Max[#]}& @ ArcCos[{n12.n13, n12.n23, n13.n23}]]\
\>", "Input"],

Cell["\<\
angleColoredGraphics[polys_] := 
Module[{allAngles = minMaxAngles /@ N[polys], minAngle, maxAngle},
       {minAngle, maxAngle} = {Min[#], Max[#]}& [First /@ allAngles];
       Graphics[{Transpose[{Hue /@ (0.78 ((First /@ allAngles) - minAngle)/
                                      (maxAngle - minAngle)), polys}]},
                AspectRatio -> Automatic, Frame -> False]]\
\>", "Input"],

Cell["\<\
With[{o = 5},
Show[GraphicsArray[Function[plus, 
angleColoredGraphics[Nest[Flatten[sixNewTriangles[plus, #]& /@ #]&, 
          {Polygon[{{0, 0}, {1, 0}, {1, 1}}]}, o]]] /@ {FareyPlus, \
BaryPlus}]]]\
\>", "Input"],

Cell["\<\
Next, we construct the triangles for the animation. These are the \
two sets of Farey and Bary triangles in identical order.\
\>", "Text"],

Cell["\<\
order = 4;
trianglesFarey = Nest[Flatten[sixNewTriangles[FareyPlus, #]& /@ #]&, 
          {Polygon[{{0, 0}, {1, 0}, {1, 1}}]}, order];\
\>", "Input"],

Cell["\<\
trianglesBary = Nest[Flatten[sixNewTriangles[BaryPlus, #]& /@ #]&, 
          {Polygon[{{0, 0}, {1, 0}, {1, 1}}]}, order];\
\>", "Input"],

Cell[TextData[{
  "By joining the coordinates of the Farey and Bary triangle, we embed them \
into ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[DoubleStruckCapitalR]", "4"], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
to4DTriangle[{Polygon[{p1_, p2_, p3_}], Polygon[{q1_, q2_, q3_}]}] \
:=
              Polygon[{Join[p1, q1], Join[p2, q2], Join[p3, q3]}]\
\>", \
"Input"],

Cell["\<\
triangles4D = to4DTriangle /@ Transpose[{trianglesFarey, \
trianglesBary}];\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["project", "MR"],
  " projects the triangles ",
  StyleBox["triangles4D", "TI"],
  " into a 3D subspace orthogonal to ",
  StyleBox["vector", "TI"],
  "."
}], "Text"],

Cell["\<\
project[triangles4D_, vector_] := 
Module[{v4 = \[ScriptN][vector], v3 = \[ScriptN][Table[Random[], {4}]],
        v2 = \[ScriptN][Table[Random[], {4}]], v1 = \
\[ScriptN][Table[Random[], {4}]]},
       v3 = \[ScriptN][v3 - v3.v4 v4];
       v2 = \[ScriptN][v2 - v2.v4 v4 - v2.v3 v3];
       v1 = \[ScriptN][v1 - v1.v4 v4 - v1.v3 v3 - v1.v2 v2];
      Map[{v1.#, v2.#, v3.#}&, triangles4D, {3}]]\
\>", "Input"],

Cell["Here are three random projections.", "Text"],

Cell["\<\
Show[GraphicsArray[
Table[SeedRandom[k];
     Graphics3D[project[triangles4D, Table[Random[Real, {-1, 1}], {4}]], 
                BoxRatios -> {1, 1, 1},  PlotRange -> All], {k, 3}]]];\
\>", \
"Input"],

Cell["\<\
For the animation, we want a smooth dependence of the projection \
subspace from the animation parameter. And to obtain a variety of views on \
the surface, we use a parametrization through 4D rotation matrices similar to \
the ones used in Solution 21a) of the second chapter of the Graphics \
volume.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* all principle projections *)", "CodeComment"],
  "\nreImPathList4D = {{1, 2, 3, 4}, {1, 2, 4, 3}, {1, 4, 2, 3},\n            \
      {3, 4, 2, 1}, {3, 4, 1, 2}, {3, 2, 1, 4}, {1, 2, 3, 4}};"
}], "Input",
  GeneratedCell->False],

Cell[TextData[{
  StyleBox["(* construct parametrized rotation matrix that rotates from aL to \
bL *)", "CodeComment"],
  "\nmakeTransitionMatrix[{aL_, bL_}, \[CurlyPhi]_] := \nModule[{m = Table[0, \
{4}, {4}], c = Cos[\[CurlyPhi]], s = Sin[\[CurlyPhi]],\n        \[ScriptF] = \
Function[{\[ScriptM], v}, If[\[ScriptM] === 0, \[ScriptM] = v], {HoldAll}]},\n\
",
  StyleBox[" (* set rotation matrix elements *)", "CodeComment"],
  "\n Do[{i, j} = {aL[[k]], bL[[k]]}; \n   If[i == j, m[[i, i]] = 1, \
\[ScriptF][m[[i, i]],  c]; \[ScriptF][m[[j, j]], c]; \n                       \
      \[ScriptF][m[[i, j]], -s]; \[ScriptF][m[[j, i]], s]], \n     {k, 4}]; \
m]"
}], "Input",
  GeneratedCell->False],

Cell[TextData[{
  StyleBox["(* list of rotation matrices *)", "CodeComment"],
  "\n\[ScriptCapitalR]s = \nModule[{framesPerSubRotation = 18, \[ScriptR]1, \
\[ScriptR]2},\n  ",
  StyleBox["(* all Pi/2 rotations *)", "CodeComment"],
  "\n  \[ScriptR]1 = makeTransitionMatrix[#, \[CurlyPhi]]& /@ \
Partition[reImPathList4D, 2, 1];\n  ",
  StyleBox["(* cumulative rotation matrix *)", "CodeComment"],
  "\n  \[ScriptR]2 = FoldList[#1.#2&, IdentityMatrix[4], \[ScriptR]1 /. \
\[CurlyPhi] -> Pi/2];\n  Table[",
  StyleBox["(* form subrotation matrices *)", "CodeComment"],
  " Table[\[ScriptR]2[[k]].\[ScriptR]1[[k]], \n                     {\
\[CurlyPhi], 0, Pi/2, Pi/2/framesPerSubRotation}],\n        {k, \
Length[reImPathList4D] - 1}] // Flatten[#, 1]& // N];"
}], "Input"],

Cell["\<\
Here are some of the resulting views in the 2D Minkowski \
function.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Partition[
Function[\[ScriptCapitalR], Graphics3D[Map[Most[\[ScriptCapitalR].#]&, \
triangles4D, {3}], BoxRatios -> {1, 1, 1},
                  PlotRange -> All]] /@ \[ScriptCapitalR]s[[{1, 27, 43, 54, \
69, 106}]], 3]\
\>", "Input"],

Cell["Here is the corresponding animation.", "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "4_1_PolygonFolding.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Function[\[ScriptCapitalR], Show[Graphics3D[Map[Most[\
\[ScriptCapitalR].#]&, triangles4D, {3}], BoxRatios -> {1, 1, 1},
                  PlotRange -> All]]] /@ \[ScriptCapitalR]s\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Graphics Volume, Chapter 3", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Degenerate Chladny Figure Animation"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider a Chladny tone figure in the square ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"(", 
            RowBox[{"0", ",", "\[Pi]"}], ")"}], "\[Times]", 
          RowBox[{"(", 
            RowBox[{"0", ",", "\[Pi]"}], ")"}]}], TraditionalForm]]],
  " of the form"
}], "Text",
  CellTags->{
  "Index[09, Chladny figures]", "Index[09, {figures, Chladny ~}]", 
    "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"}],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"v", "(", 
          RowBox[{
            RowBox[{"t", ";", "x"}], ",", "y"}], ")"}], "=", 
        RowBox[{
          UnderscriptBox["\[Sum]", 
            RowBox[{
              RowBox[{
                SuperscriptBox["n", "2"], "+", 
                SuperscriptBox["m", "2"]}], "=", 
              StyleBox["\<\"\[CurlyEpsilon]\"\>",
                "TI"]}],
            LimitsPositioning->True], 
          RowBox[{
            SubscriptBox["c", 
              StyleBox["\<\"nm\"\>",
                "TI"]], 
            SuperscriptBox["e", 
              RowBox[{"(", 
                RowBox[{"i", "(", 
                  RowBox[{
                    RowBox[{"\[CurlyEpsilon]", " ", "t"}], "+", 
                    SubscriptBox["\[CurlyPhi]", 
                      RowBox[{"n", " ", "m"}]]}], ")"}], " ", ")"}]], 
            RowBox[{"cos", "(", 
              RowBox[{"n", " ", "x"}], ")"}], 
            RowBox[{
              RowBox[{"cos", "(", 
                RowBox[{"m", " ", "y"}], ")"}], "."}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For a ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  " with at least eightfold degeneracy, make a ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  "\[Hyphen]dependent animation showing the argument of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"v", "(", 
          RowBox[{
            RowBox[{"t", ";", "x"}], ",", "y"}], ")"}], TraditionalForm]]],
  " and the lines of vanishing real and imaginary parts."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by finding an ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  " which has eight different ways to be expressed as a sum of two squares."
}], "SolutionSubgroup"],

Cell["\<\
With[{d = 40},
Sort[Select[Sort[Map[Rest, 
Split[Sort[Flatten[Table[{i^2 + j^2, i, j}, {i, d}, {j, d}], 1]], 
       #[[1]] === #2[[1]]&], {-2}], Length[#1] > Length[#2]&],
       Length[#] >= 8&], #1[[1]].#1[[1]] < #2[[1]].#2[[1]]&]]\
\>", "Input"],

Cell[TextData[{
  "We choose the first list of the last result with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", "1105"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["evs = %[[1]];", "Input"],

Cell["Now we form a random superposition with random phases.", "Text"],

Cell["\<\
f[\[Tau]_][x_, y_] = Plus @@ ((Random[Real, {-1, 1}] Exp[2Pi I (\
\[Tau] + 
                          Random[])] Cos[#1 x] Cos[#2 y])& @@@ evs);\
\>", \
"Input"],

Cell[TextData[{
  "The function frame calculates ",
  StyleBox["f[", "MR"],
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  StyleBox["][", "MR"],
  StyleBox["x", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["y", "TI"],
  StyleBox["] ", "MR"],
  "on a grid of ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]values and superposes the density plots of the argument with the \
contour lines of vanishing real and imaginary part."
}], "Text"],

Cell[TextData[{
  "frame[\[Tau]_, pp_] := \nModule[{data = Table[Evaluate[N @ f[\[Tau]][x, \
y]], \n                     {y, 0., 1. Pi, 1. Pi/pp}, {x, 0., 1. Pi, 1. \
Pi/pp}]},\nBlock[{$DisplayFunction = Identity},\nShow[{",
  StyleBox["(* density plot of the argument *)", "CodeComment"],
  "\n      ListDensityPlot[Arg[data], MeshRange -> {{0, Pi}, {0, Pi}}, \n     \
                 FrameTicks -> None, Mesh -> False,\n                      \
ColorFunction -> Hue, PlotRange -> {-Pi, Pi},\n                      \
ColorFunctionScaling -> False],\n      ",
  StyleBox["(* contour lines of vanishing real and imaginary parts *)", 
    "CodeComment"],
  "\n      ListContourPlot[#1[data], MeshRange -> {{0, Pi}, {0, Pi}},\n       \
               Contours -> {0}, ContourShading -> False,\n                    \
  ContourStyle -> {{Thickness[0.005], GrayLevel[#2]}}]& @@@ \n                \
                                             {{Re, 0}, {Im, 1}}},\n     \
PlotRange -> {{0, Pi}, {0, Pi}}]]]"
}], "Input"],

Cell["Show[GraphicsArray[frame[#, 240]& /@ {0, 0.3, 0.5}]]", "Input"],

Cell["Here is the resulting animation.", "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "        ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          
          FrontEnd`FileName[ {"Animations"}, 
            "WSA_DegenerateChladnyFigures.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Do[Show[#,  DisplayFunction -> $DisplayFunction]& @ frame[\[Tau], \
240], 
   {\[Tau], 0, 1, 1/90}]\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Changing Charged ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gon Animation"
}], "ExerciseHeading"],

Cell[TextData[{
  "Make an animation of the equipotential curves of a set of randomly \
rotating, randomly moving, and randomly size\[Hyphen]changing set of regular \
",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gons."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "This is the potential at the points ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}], TraditionalForm]]],
  " of a charged line segments ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{
                StyleBox["x0",
                  "TI"], ",", 
                StyleBox["y0",
                  "TI"]}], "}"}], ",", 
            RowBox[{"{", 
              RowBox[{
                StyleBox["x1",
                  "TI"], ",", 
                StyleBox["y1",
                  "TI"]}], "}"}]}], "}"}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
pot[{{x0_, y0_}, {x1_, y1_}}, {x_, y_}] =
 (-Log[(x - x0)(x0 - x1) + Sqrt[(x - x0)^2 + (y - y0)^2]*
       Sqrt[(x0 - x1)^2 + (y0 - y1)^2] + (y - y0)(y0 - y1)] + 
   Log[(x - x1)(x0 - x1) + Sqrt[(x - x1)^2 + (y - y1)^2]*
       Sqrt[(x0 - x1)^2 + (y0 - y1)^2] + (y - y1)(y0 - y1)])/
  Sqrt[(x0 - x1)^2 + (y0 - y1)^2];\
\>", "Input",
  AspectRatioFixed->True],

Cell[TextData[{
  StyleBox["randomNgon", "MR"],
  " generates a list of the vertices of a randomly oriented ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gon (in the following, we use ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " between 3 and 8)."
}], "Text"],

Cell["\<\
randomNgon := 
Table[Evaluate[Random[Real, {0.15, 0.6}] {Cos[\[CurlyPhi] + #], Sin[\
\[CurlyPhi] + #]}&[
                                                     2 Pi Random[]]],
      Evaluate[{\[CurlyPhi], 0, 2Pi (1 - 1/#), 2Pi/#}&[
      Random[Integer, {3, 8}]]]]\
\>", "Input"],

Cell[TextData[{
  "For the following animation, we use 12 ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gons."
}], "Text"],

Cell["\<\
SeedRandom[111]; n = 12;
initialNgons = Table[randomNgon, {n}];\
\>", "Input"],

Cell[TextData[{
  "For realizing the the random movements and rotations, we define a function \
",
  StyleBox["randomFunction", "MR"],
  " that generates a random function with parameter ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  " and period ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", "\[Pi]"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
randomFunction[d_, \[Tau]_, \[Alpha]_] := 
 Sum[Random[Real, {-\[Alpha], \[Alpha]}] Cos[k \[Tau] + 2 Pi Random[]], {k, \
d}];\
\>", "Input"],

Cell[TextData[{
  "The list ",
  StyleBox["randomMoveDatas", "MR"],
  " contains parametrized random translation vectors, scale factors, and \
rotation matrices."
}], "Text"],

Cell[TextData[{
  "randomMoveData :=\n{",
  StyleBox["(* translation vector *)", "CodeComment"],
  " Table[randomFunction[2, \[Tau], 0.8], {2}], \n ",
  StyleBox["(* scale factor *)", "CodeComment"],
  "0.2 + Abs[randomFunction[2, \[Tau], 1.2]],\n ",
  StyleBox["(* rotation matrix *)", "CodeComment"],
  "\n {{Cos[#], Sin[#]}, {-Sin[#], Cos[#]}}&[randomFunction[2, \[Tau], 2]]}"
}], "Input"],

Cell["\<\
randomMoveDatas[\[Tau]_] = Table[randomMoveData, {n}];\
\>", "Input"],

Cell[TextData[{
  "The last random ingredient is a list ",
  StyleBox["charges", "MR"],
  " of random function that represent the (potentially sign\[Hyphen]changing) \
charges of the ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gons."
}], "Text"],

Cell["\<\
charges[\[Tau]_] = Flatten[Table[randomFunction[2, \[Tau], 1]*
                      Table[1, {Length[initialNgons[[k]]]}], {k, n}]];\
\>", \
"Input"],

Cell[TextData[{
  "For a given ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", "\[Tau]"}], TraditionalForm]]],
  ", the function ",
  StyleBox["makeSegments", "MR"],
  " generates the list of line segments of the ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gons."
}], "Text"],

Cell[TextData[{
  "makeSegments[\[Tau]_] :=\nWith[{\[Tau]Data = randomMoveDatas[\[Tau]]}, \n\
Table[Partition[Append[#, First[#]], 2, 1]& @ \n          ",
  StyleBox["(* apply random translation, scaling, and rotation *)", 
    "CodeComment"],
  "\n          Map[(\[Tau]Data[[k, 1]] + \[Tau]Data[[k, 3]].(\[Tau]Data[[k, \
2]] #))&, \n              initialNgons[[k]], {-2}], {k, n}] // Flatten[#, \
1]&]"
}], "Input"],

Cell["\<\
Given the line segments, it is straightforward to add their \
potential contribution.\
\>", "Text"],

Cell["\<\
makePotential[\[Tau]_] := (pot[#, {x, y}]& /@ \
makeSegments[\[Tau]]).charges[\[Tau]]\
\>", "Input"],

Cell[TextData[{
  "So, we have the following final function ",
  StyleBox["makeFrame[", "MR"],
  StyleBox["\[Tau]", "TI"],
  StyleBox["]", "MR"],
  " that generates a frame of the animation."
}], "Text"],

Cell[TextData[{
  StyleBox["(* sketch the ngons *)", "CodeComment"],
  "\noutlinedNGons[\[Tau]_] := \nWith[{mS = makeSegments[\[Tau]], \n      gs \
= GrayLevel /@ ((ArcTan[charges[\[Tau]]] + Pi/2)/Pi)},\n     {",
  StyleBox["(* edges as bold lines*)", "CodeComment"],
  "\n      {Thickness[0.008], Transpose[{gs, Line /@ mS}]},\n      ",
  StyleBox["(* thin lines from the center to the edges *)", "CodeComment"],
  "\n      {Thickness[0.001], Transpose[{gs, Flatten[Function[l, \n           \
              Line[{#, Plus @@ l/Length[l]}]& /@ l] /@ \n       Map[First, \n \
      Fold[{Drop[#1[[1]], #2], Append[#1[[2]], Take[#1[[1]], #2]]}&, \n       \
  {mS, {}}, Length /@ initialNgons][[2]], {2}]]}]}}]"
}], "Input"],

Cell[TextData[{
  "makeFrame[\[Tau]_] :=\nModule[{pp = 240, contours = 120, n1, n2, cp, cls, \
L = 1.8, k = 0},\n       n1 = Round[pp^2/contours]; n2 = Round[n1/2];\n       \
",
  StyleBox["(* initial contour plot *)", "CodeComment"],
  "\n       Off[ContourPlot::plnr];\n       cp = \
ContourPlot[Evaluate[makePotential[\[Tau]]],\n                       {x, -L, \
L}, {y, -L, L}, PlotPoints -> pp,\n                       DisplayFunction -> \
Identity][[1]] /. \n                       ",
  StyleBox["(* ignore single points *)", "CodeComment"],
  " Indeterminate -> 0.; \n       On[ContourPlot::plnr];                \n    \
   ",
  StyleBox["(* homogeneously spaced contour line *)", "CodeComment"],
  "\n       cls = Flatten[#[[n2]]& /@ Partition[Sort[Flatten[cp]], n1]]; \n   \
    ",
  StyleBox["(* final contour plot *)", "CodeComment"],
  "\n       ListContourPlot[cp, Contours -> cls, PlotRange -> All,\n          \
      ",
  StyleBox["(* color \"random\" consecutively with overall shift \[Tau] *)", 
    "CodeComment"],
  "\n                ColorFunction -> (Hue[Sin[\[Tau]/(2Pi) + (k++)]]&),\n    \
            ContourLines -> False, FrameTicks -> None, \n                \
MeshRange -> {{-L, L}, {-L, L}},\n                ",
  StyleBox["(* the ngons in gray *)", "CodeComment"],
  " Epilog -> outlinedNGons[\[Tau]]]]"
}], "Input"],

Cell["Here is the resulting animation.", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ 
Block[{$DisplayFunction = Identity, frames = 9},
      Partition[
       Table[makeFrame[\[Tau]], {\[Tau], 0, 2Pi (1 - 1/frames), 2Pi/frames}], \
3]]\
\>", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "        ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_ChargedNGons.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
frames = 150;
Do[makeFrame[\[Tau]], {\[Tau], 0, 2Pi (1 - 1/frames), 2Pi/frames}]\
\>", \
"Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Charged Truchet Patterns"
}], "ExerciseHeading"],

Cell["\<\
Make contour plots of charged Truchet patterns. Use different color \
functions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "The pieces of a Truchet pattern are circle segments. While exact \
expressions for the electrostatic potential of circle segments can be found, \
they are too complicated for an efficient numerical evaluation. So we will \
approximate the quarter circles of a square Truchet pattern by line segments. \
The electrostatic potential of a charged line segment starting at the point \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            StyleBox["x0",
              "TI"], ",", 
            StyleBox["y0",
              "TI"]}], "}"}], TraditionalForm]]],
  " and pointing in direction ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            StyleBox["xr",
              "TI"], ",", " ", 
            StyleBox["yr",
              "TI"]}], "}"}], TraditionalForm]]],
  " is given by ",
  StyleBox["potential\[CurlyPhi]", "MR"],
  ". "
}], "SolutionSubgroup"],

Cell["\<\
potential\[CurlyPhi][{x0_, y0_}, {xr_, yr_}, {x_, y_}] = 
With[{s = Sqrt[xr^2 + yr^2]}, 
(-Log[Sqrt[(x - x0)^2 + (y - y0)^2] + (x0 xr - y yr + y0 yr - x xr)/s] + 
  Log[(xr (-x + x0 + xr) + yr (-y + y0 + yr))/s +  
       Sqrt[(-x + x0 + xr)^2 + (-y + y0 + yr)^2]])/s];\
\>", "Input"],

Cell["\<\
makePotential\[CurlyPhi][{p0_, p1_}, p_] := \
potential\[CurlyPhi][p0, p1 - p0, p]\
\>", "Input"],

Cell[TextData[{
  "Generating a Truchet pattern, approximating its circle pieces by line \
segments, charging the line segments and calculating a contour plot is \
straightforward. We deal here with the case of all segments being charged \
with the same parity. The function ",
  StyleBox["chargedTruchetPattern", "MR"],
  " generates a graphics array of contour plots of a charged Truchet pattern \
with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", 
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{"L", "+", "1"}], ")"}], "2"]}], TraditionalForm]]],
  " quarter circles, each quarter circle being approximated through ",
  StyleBox["ppc", "TI"],
  " line segments. ",
  StyleBox["pp", "TI"],
  " is the number of plot points for the contour plot, ",
  StyleBox["contourList", "TI"],
  " is the list of contour values and ",
  StyleBox["cf", "TI"],
  " is the color function whose arguments are the values of the contour \
values. (Because calculating the potential values is the \
time\[Hyphen]consuming step, we allow for the generation of more than one \
contour plot once the potential values are calculated.)"
}], "Text"],

Cell[TextData[{
  "chargedTruchetPattern[L_Integer, ppc_Integer, pp_, contourList_, \n        \
              colorFunction_] := \nModule[{lineCircleParts, \[DoubleStruckR] \
:= Random[Integer, {1, 2}],\n        (*fullPotential\[CurlyPhi], \
cf\[CurlyPhi], cpData, cls, *) \[Alpha] = N[Pi/100]},\n",
  StyleBox["(* seed random number generator *) ", "CodeComment"],
  "SeedRandom[111];\n",
  StyleBox["(* pairs of quarter circles forming the Truchet pattern *)", 
    "CodeComment"],
  "\nlineCircleParts =  \nTable[{{Circle[{i, j} + {-1, +1}/2, 1/2, {3/2, 2} \
Pi],\n        Circle[{i, j} + {+1, -1}/2, 1/2, {1/2, 1} Pi]},\n       \
{Circle[{i, j} + {+1, +1}/2, 1/2, {1, 3/2} Pi],\n        Circle[{i, j} + {-1, \
-1}/2, 1/2, {0, 1/2} Pi]}}[[\[DoubleStruckR]]], \n      {i, 0, L}, {j, 0, L}] \
/. \n     ",
  StyleBox["(* approximate quarter circles with line segments*)", 
    "CodeComment"],
  "\n      Circle[mp_, r_, {\[CurlyPhi]1_, \[CurlyPhi]2_}] :>  Partition[\n   \
         Table[mp + r {Cos[\[CurlyPhi]], Sin[\[CurlyPhi]]},  \n               \
   {\[CurlyPhi], \[CurlyPhi]1, \[CurlyPhi]2, Pi/4/ppc}], 2, 1] // Flatten[#, \
3]&;\n",
  StyleBox["(* the electrostatic potential of the line segment *)", 
    "CodeComment"],
  "\nfullPotential\[CurlyPhi][x_, y_] = \n    Chop[Plus @@ (makePotential\
\[CurlyPhi][#, {x, y}]& /@ lineCircleParts)];\n",
  StyleBox["(* use ContourPlot to autocompile the function *)", 
    "CodeComment"],
  "\n",
  StyleBox["(* in case a point falls onto a line segment *)", "CodeComment"],
  " Off[ContourPlot::plnr];\n",
  StyleBox["(* avoid spending time in rewriting the long sum *)", 
    "CodeComment"],
  "\nIf[$Version >= 5, SetOptions[Compile, CompileOptimizations -> None]];\n\
cf\[CurlyPhi] = Compile[{x, y}, Evaluate[N @ fullPotential\[CurlyPhi][x, \
y]]];\ncpData = Table[Table[",
  StyleBox["(* make machine numbers for all potential values *)", 
    "CodeComment"],
  "\n                     Which[MachineNumberQ[#], #, # === Indeterminate, \
1., \n                           Abs[#] < 1, 0., Abs[#] > 1, 10^10., True, \
1.]& @\n                     Re[cf\[CurlyPhi][x, y]], {x, -\[Alpha] L, (1 + \
\[Alpha]) L, (1 + 2 \[Alpha]) L/pp}],\n                    {y, -\[Alpha] L, \
(1 + \[Alpha]) L, (1 + 2 \[Alpha]) L/pp}];  \n",
  StyleBox["(* make contour plots with different number of contour lines *)", 
    "CodeComment"],
  "\nShow[GraphicsArray[Function[c, SeedRandom[222];\ncls = \
#[[Round[pp^2/c]]]& /@ \n         Partition[Sort[Flatten[cpData]], \
Round[pp^2/c]]; \nListContourPlot[cpData, ContourLines -> False, \n           \
     ",
  StyleBox["(* homogeneous contour spacing *)", "CodeComment"],
  " Contours -> cls, \n",
  StyleBox["                ", "CodeComment"],
  " ColorFunctionScaling -> False,\n                 ColorFunction -> \
colorFunction[cls], FrameTicks -> False,\n                 DisplayFunction -> \
Identity]] /@ \n                 ",
  StyleBox["(* number of contours *)", "CodeComment"],
  " contourList]]]"
}], "Input"],

Cell["\<\
Now, let us display some examples. The following plot uses a \
coloring according to the potential value. Blue is smallest and red is \
highest. We use just a small Truchet pattern with only 18 quarter \
circles.\
\>", "Text"],

Cell["\<\
SeedRandom[333];
chargedTruchetPattern[2, 4, 60, {10, 60, 60}, 
 Function[\[ScriptC]\[ScriptL]\[ScriptS], Function[\[ScriptC], Evaluate[Which \
@@ Flatten[MapIndexed[{#1, 
                                    Hue[0.76 (1 - #2[[1]]/Length[\[ScriptC]\
\[ScriptL]\[ScriptS]])]}&,
                                  Append[\[ScriptC] < #& /@ \[ScriptC]\
\[ScriptL]\[ScriptS], True]]]]]]]\
\>", "Input"],

Cell["Here is the same potential with a random coloring.", "Text"],

Cell["\<\
SeedRandom[333];
chargedTruchetPattern[2, 4, 60, {10, 20, 30}, (Hue[Random[]]&)&]\
\>", "Input"],

Cell["The coloring of the next contour plot is alternating.", "Text"],

Cell["\<\
SeedRandom[222];
chargedTruchetPattern[3, 6, 60, {10, 20, 30}, 
 Function[\[ScriptC]\[ScriptL]\[ScriptS], Function[\[ScriptC], Evaluate[Which \
@@ Flatten[MapIndexed[{#1, 
              If[EvenQ[#2[[1]]], GrayLevel[0], GrayLevel[1]]}&,
                                  Append[\[ScriptC] < #& /@ \[ScriptC]\
\[ScriptL]\[ScriptS], True]]]]]]]\
\>", "Input"],

Cell[TextData[{
  "We end with a larger Truchet pattern. Calculating the ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["361", "2"], TraditionalForm]]],
  " potential values takes a few hours. This time we use a random coloring. \
We mix gray colors with hue colors."
}], "Text"],

Cell[TextData[{
  "SeedRandom[555];\nchargedTruchetPattern[6, 12, 360, {10, 20, 50},\n        \
              ",
  StyleBox["(* need double nested pure function here *)", "CodeComment"],
  "\n                      ((If[Random[] < 1/2, GrayLevel[Random[]],\n        \
                                    Hue[Random[]]]&)&)]"
}], "Input"],

Cell["\<\
One could now go on and extract all connected quarter circles and \
apply different charges (in magnitude and polarity) to each connected \
component.\
\>", "Text"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Numerics Volume, Chapter 1", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " 1D Random Walk with Varying Stepsize"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider a random walk in 1D where the stepsize ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Lambda]", "n"], TraditionalForm]]],
  " of the ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "th step depends on ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ". For the two functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Lambda]", "n"], "=", 
          SuperscriptBox["n", "\[Alpha]"]}], TraditionalForm]]],
  " (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "<", "0"}], TraditionalForm]]],
  ") and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Lambda]", "n"], "=", 
          SuperscriptBox["\[Alpha]", "n"]}], TraditionalForm]]],
  " (",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "<", "\[Alpha]", "<", "1"}], TraditionalForm]]],
  "), visualize the density of the resulting walker positions after the first \
25 steps for various ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "To calculate the final positions of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["2", "25"], "=", "33554432"}], TraditionalForm]]],
  " possible walks, we use a compiled function. For a given list of stepsize \
",
  StyleBox["\[Lambda]List", "MR"],
  ", the function ",
  StyleBox["varyingStepSizeRandomWalkData", "MR"],
  " bins the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{
            RowBox[{"-", 
              StyleBox["max",
                "TI"]}], ",", 
            StyleBox["max",
              "TI"]}], "]"}], TraditionalForm]]],
  " into ",
  Cell[BoxData[
      FormBox["\[Delta]", TraditionalForm]]],
  " bins and returns a list of the counts for each bin."
}], "SolutionSubgroup"],

Cell[TextData[{
  "varyingStepSizeRandomWalkData[\[Lambda]List_, max_, \[Delta]_] := \n\
With[{o = Length[\[Lambda]List]},\nCompile[{}, Module[{L = Table[0, \
{\[Delta]}], x, k},\n               Do[",
  StyleBox["(* final walk position after o steps *)", "MR"],
  " x = #1.\[Lambda]List; \n                  ",
  StyleBox["(* bin final walk position *)", "CodeComment"],
  "\n                  k = Round[(x + max)/(2max) (\[Delta] - 1)] + 1;\n      \
            ",
  StyleBox["(* count binned final walk position *)", "CodeComment"],
  "\n                  L[[k]] = L[[k]] + 1, ##2];\n                  \
L]][]&[",
  StyleBox["(* left-right steps *)", "CodeComment"],
  " Table[i[k], {k, o}], \n                         ",
  StyleBox["(* left-right step iterators *)", "CodeComment"],
  "\n                         Sequence @@ Table[{i[k], -1, 1, 2}, {k, o}]]];"
}], "Input"],

Cell[TextData[{
  "The next series of graphics shows the results for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Lambda]", "n"], "=", 
          SuperscriptBox["\[Alpha]", "n"]}], TraditionalForm]]],
  ". For larger ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", we obtain a smooth bell\[Hyphen]shaped curve. For smaller ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", we obtain a fractal structure. For a detailed discussion of this case, \
see [",
  
  CounterBox["BibliographyCounter", "Krapivsky03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Krapivsky03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["\<\
opts = Sequence[PlotRange -> All, Frame -> True, FrameTicks -> \
False,
                DisplayFunction -> Identity, Axes -> False,
                PlotStyle -> {PointSize[0.0001]}];\
\>", "Input"],

Cell["\<\
With[{o = 25, \[Delta] = 1000}, 
Show[GraphicsArray[
    ListPlot[varyingStepSizeRandomWalkData[
              Table[#^k, {k, o}],  #/(1 - #), \[Delta]], opts]& /@ 
                      {0.4, 0.55, 1./GoldenRatio, 0.8}]]]; \
\>", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Lambda]", "n"], "=", 
          SuperscriptBox["n", "\[Alpha]"]}], TraditionalForm]]],
  ", we see nested structures forming for decreasing ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
With[{o = 25, \[Delta] = 1000}, 
Show[GraphicsArray[
    ListPlot[varyingStepSizeRandomWalkData[
              Table[k^#, {k, o}],  Sum[k^#, {k, o}], \[Delta]], opts]& /@ 
                                           {-0.4, -1., -1.5, -2.}]]]\
\>", \
"Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Three\[Hyphen]Disk Scattering"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the following 2D scattering system: A light ray is (potentially \
repeatedly) reflected in the interior region formed by three circles centered \
at the vertices of a regular triangle [",
  
  CounterBox["BibliographyCounter", "Aguirre03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Aguirre03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Gaspard89"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gaspard89",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Wirzba99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wirzba99",
    ButtonStyle->"Hyperlink"],
  "]. The ray can escape through the spaces between the circles. For (at \
least) 200 rays starting at equidistant points along the line connecting the \
(centers of) two circles, in (at least) 200 discrete directions, visualize \
the dependence of the three possible exit points on the starting points and \
the starting angles. Use circles of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"9", "/", "10"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"99", "/", "100"}], TraditionalForm]]],
  " of their maximal size."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "These are the three circles and the lines connecting them. ",
  Cell[BoxData[
      FormBox["\[Rho]", TraditionalForm]]],
  " is the radius of the circles and lies in the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"(", 
          RowBox[{"0", ",", 
            RowBox[{
              SuperscriptBox["3", 
                RowBox[{"1", "/", "2"}]], "/", "2"}]}], ")"}], 
        TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["Off[General::spell]; Off[General::spell1]; ", "Input"],

Cell["\<\
threeCircleConfiguration[\[Rho]_] := 
With[{\[ScriptS] = N[Sqrt[3], Precision[\[Rho]]]},
{Circle[{\[ScriptS], -1}/2, \[Rho]], Circle[{-\[ScriptS], -1}/2, \[Rho]], \
Circle[{0, 1}, \[Rho]], 
 Line[{{\[ScriptS] - \[Rho], -1 + \[ScriptS] \[Rho]}, {\[Rho], 2 - \[ScriptS] \
\[Rho]}}/2], 
 Line[{{-\[ScriptS] + \[Rho], -1 + \[ScriptS] \[Rho]}, {-\[Rho], 2 - \
\[ScriptS] \[Rho]}}/2], 
 Line[{{\[ScriptS] - 2\[Rho], -1}, {-\[ScriptS] + 2\[Rho], -1}}/2]}]\
\>", \
"Input"],

Cell["\<\
Show[Graphics[threeCircleConfiguration[0.5]],
     PlotRange -> All, AspectRatio -> Automatic, Frame -> True];\
\>", "Input"],

Cell[TextData[{
  "Given a ray ",
  StyleBox["Ray[", "MR"],
  StyleBox["p", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["d", "TI"],
  StyleBox["]", "MR"],
  " starting at the point ",
  Cell[BoxData[
      FormBox["p", TraditionalForm]]],
  " and moves in (normalized) direction ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  ", the function ",
  StyleBox["nearestIntersection", "MR"],
  " calculates the nearest intersection of this ray with a circle, or with a \
line segment joining the circles."
}], "Text"],

Cell[TextData[{
  StyleBox["(* nearest intersection (if any) of a ray with a circle *)", 
    "CodeComment"],
  "\nnearestIntersection[Ray[p_, d_], Circle[q_, \[Rho]_]] := \nModule[{eqs = \
(p - q + t d).(p - q + t d) - \[Rho]^2, sol},\n  ",
  StyleBox["(* next intersection if \"forward\" *)", "CodeComment"],
  "\n  sol = Select[t /. Solve[eqs == 0, t], (Im[#] == 0 && # > 0)&];\n  \
If[sol === {}, {}, {t, p + t d} /. t -> Min[sol]]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* nearest intersection (if any) of a ray with a line segment *)",
     "CodeComment"],
  "\nnearestIntersection[Ray[p_, d_], Line[{p1_, p2_}]] := \nModule[{eqs = \
Thread[p1 + s (p2 - p1) == p + t d], solPre, sol},\n  ",
  StyleBox["(* the ray is potentially parallel to the line segment *)", 
    "CodeComment"],
  "\n  solPre = Solve[eqs, {s, t}]; \n  If[solPre === {}, {}, ",
  StyleBox["(* crossing happens inside segment? *)", "CodeComment"],
  "\n     sol = Select[{s, t} /. solPre, (0 <= #[[1]] <= 1 && 0 < #[[2]])&];\n\
     If[sol === {}, {}, {t, p + t d} /. t -> Min[Last /@ sol]]]]"
}], "Input"],

Cell[TextData[{
  "To carry out the reflection at a point on the circle, we use the function \
",
  StyleBox["reflect", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* reflection of a ray at the point s at a circle *)", 
    "CodeComment"],
  "\nreflect[Ray[_, d_], s_, Circle[q_, _]] := \nModule[{n = #/Sqrt[#.#]&[s - \
q]}, Ray[s, d - 2d.n n]]"
}], "Input"],

Cell["\<\
To quickly decide if the intersection of a ray with a circle \
happens with the \"inside\" part of the circle, we define the angle ranges \
for the three circles.\
\>", "Text"],

Cell["\<\
Evaluate[angleRange /@ {1, 2, 3}] = 
         Interval /@ (Pi/3 {{2, 3}, {0, 1}, {-2, -1}});\
\>", "Input"],

Cell[TextData[{
  "Now, we have all functions defined that are needed to carry out one \
reflection (or the final escape step) for a ray. The function ",
  StyleBox["step", "MR"],
  " does this. In general, we will have to use a few hundred digits to carry \
out many reflections and obtain a correct result. But to find the next \
individual scatterer, we can use much lower precision to speed up the \
calculations."
}], "Text"],

Cell[TextData[{
  "step[\[Rho]_, {rayHP:Ray[p_, d_], lastCircle___}] :=\nModule[{tCC, ray, \
possibleCircles, iCs, iCs1, \[Alpha], result, \n        nextEvent, \
possibleLines, isL, isL1, tLMins, posL},\n tCC = threeCircleConfiguration[\
\[Rho]];\n ",
  StyleBox["(* use reduced precision to find next event *)", "CodeComment"],
  "\n ray = N[rayHP, 25];\n ",
  StyleBox["(* next reflection is not on last circle *)", "CodeComment"],
  "\n possibleCircles = Delete[Transpose[{{1, 2, 3}, Take[tCC, 3]}],\n        \
                  {lastCircle}];\n ",
  StyleBox["(* potential intersection with remaining circles *)", 
    "CodeComment"],
  "\n iCs = {#1, nearestIntersection[ray, #2]}& @@@ possibleCircles;    \n ",
  StyleBox["(* reflection happens on the inside circle segment *)", 
    "CodeComment"],
  "\n iCs1 = Select[iCs, (#[[2]] =!= {} && \n            \
IntervalMemberQ[angleRange[#[[1]]],\n                     ArcTan @@ (#[[2, \
2]] - tCC[[#[[1]]]][[1]])])&];\n ",
  StyleBox["(* is next event a reflection? *)", "CodeComment"],
  "\n If[iCs1 =!= {}, ",
  StyleBox["(* next event is a reflection *)", "CodeComment"],
  "\n    nextEvent = \"Reflection\";\n    \[Alpha] = iCs1[[Position[#, \
Min[#]]&[#[[2, 1]]& /@ iCs1][[1, 1]], 1]];   \n    {circleNumber, circle} = {\
\[Alpha], tCC[[\[Alpha]]]}];\n",
  StyleBox["(* escape *)", "CodeComment"],
  "\nIf[nextEvent =!= \"Reflection\", nextEvent = \"Escape\";  \n   ",
  StyleBox["(* happens only once, so test all three cases *)\n", 
    "CodeComment"],
  "   possibleLines = Transpose[{{1, 2, 3}, Take[tCC, -3]}];\n   isL = {#1, \
nearestIntersection[ray, #2]}& @@@ possibleLines;\n   isL1 = DeleteCases[isL, \
{_, {}}];\n   tLMins = #[[2, 1]]& /@ isL1;                                 \n \
  posL = Position[tLMins, Min[tLMins]][[1, 1]];\n   result = {isL1[[posL, \
1]], isL1[[posL, 2, 2]]}];\n",
  StyleBox["(* return result *)\n", "CodeComment"],
  "If[nextEvent === \"Reflection\",\n   ",
  StyleBox["(* high-precision reflection *)", "CodeComment"],
  "\n   ",
  StyleBox[" ", "CodeComment"],
  "\[ScriptS] = nearestIntersection[rayHP, circle][[2]];\n   {reflect[rayHP, \
\[ScriptS], tCC[[circleNumber]]], circleNumber}, \n   result]]"
}], "Input"],

Cell[TextData[{
  "The full path of a ray until it escapes (or until the ray data do not have \
enough precision anymore to follow the ray) can be calculated using the \
function ",
  StyleBox["rayPath", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "rayPath[\[Rho]_, ray:Ray[p_, d_]] :=\nNestWhileList[step[\[Rho], #]&, \
{ray}, \n              ",
  StyleBox["(* stop at exit or insufficient precision *)", "CodeComment"],
  "\n              ((Head[First[#]] === Ray) && (Precision[#] > 20))&]"
}], "Input"],

Cell[TextData[{
  "To visualize the path of a ray, we implement the function ",
  StyleBox["rayPathGraphic", "MR"],
  ". It colors the path from red to blue and draws a gray dot at the escape \
point. To concentrate on the ray path, we show only the relevant parts of the \
circles."
}], "Text"],

Cell[TextData[{
  "rayPathGraphic[\[Rho]_, rayPath_, opts___] :=\nWith[{",
  StyleBox["(* reflection points *)", "CodeComment"],
  "\n      points = If[Head[#[[1]]] === Ray, #[[1, 1]], #[[2]]]& /@ rayPath,\n\
      ",
  StyleBox["(* exit point *)", "CodeComment"],
  "\n      exitPoint = If[Head[rayPath[[-1, 1]]] =!= Ray, \n                  \
   {rayPath[[-1, 2]]}, {}],\n       xMin = -Sqrt[3]/2 + \[Rho]/2, xMax = \
Sqrt[3]/2 - \[Rho]/2, \n       yMin = -1/2, yMax = 1 - Sqrt[3]/2 \[Rho], \
\[Delta] = (Sqrt[3] - \[Rho])/20}, \nShow[Graphics[\n{",
  StyleBox["(* the three scattering circles *)", "CodeComment"],
  "\n {Thickness[0.006], GrayLevel[0], \n  MapIndexed[Function[{x, p}, \
Insert[x, angleRange[p[[1]]][[1]], 3]],\n           \
Take[threeCircleConfiguration[\[Rho]], 3]],\n  Take[threeCircleConfiguration[\
\[Rho]], -3]},\n ",
  StyleBox["(* ray path *)", "CodeComment"],
  "\n {Thickness[0.0001], \n  MapIndexed[{Hue[0.78 (#2[[1]] - \
1)/(Length[points] - 1)], Line[#1]}&, \n             Partition[points, 2, \
1]]},\n ",
  StyleBox["(* exit point *)", "CodeComment"],
  "\n {PointSize[0.025], GrayLevel[1/2], Point /@ exitPoint}}],\n     \
PlotRange -> {{xMin - \[Delta], xMax + \[Delta]}, {yMin - \[Delta], yMax + \
\[Delta]}}, \n     opts, AspectRatio -> Automatic, Frame -> True, FrameTicks \
-> False]]"
}], "Input"],

Cell["\<\
Here are four example paths. The parameter for the rightmost path \
are chosen to give 10 internal reflections.\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nrayPathGraphic[1/2, rayPath[1/2, Ray[{0, -1/2}, #] // \
N[#, 100]&],\n               DisplayFunction -> Identity]& /@\n        {{0, \
1}, {11, 1}, {1, 1}, ",
  StyleBox["(* long ray path *)", "CodeComment"],
  "\n         {65690846499036600543, 33168393638474293644}}]]"
}], "Input"],

Cell["\<\
Here is an animation showing the dependence of the paths from the \
starting angle. All paths start at the center between two circles.\
\>", \
"Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_ThreeCircleReflections.nb"],
           None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
With[{\[CurlyEpsilon] = 10^-6}, 
 Do[rayPathGraphic[4/5, rayPath[4/5, Ray[{0, -1/2}, 
                                ExpandAll[{Cos[\[CurlyPhi]], \
Sin[\[CurlyPhi]]}]] // N[#, 250]&]],
    {\[CurlyPhi], \[CurlyEpsilon], Pi - \[CurlyEpsilon], (Pi - 2\
\[CurlyEpsilon])/90}]]\
\>", "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "For an easier specification of the starting points of the rays for \
arbitrary circle radii, we define a scaled radius ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            FormBox["\[Rho]",
              "TraditionalForm"], "s"], "=", 
          RowBox[{"2", " ", 
            SuperscriptBox["3", 
              RowBox[{
                RowBox[{"-", "1"}], "/", "2"}]], "\[Rho]"}]}], 
        TraditionalForm]]],
  ". So, ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Rho]", "s"], TraditionalForm]]],
  " varies between 0 and 1. The initial position is measured with respect to \
the length of the line segment and ranges over the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"(", 
          RowBox[{
            RowBox[{"-", "1"}], ",", " ", "1"}], ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
scaled\[Rho][\[Rho]Rel_] := Sqrt[3]/2 \[Rho]Rel
      
scaledRayData[\[Rho]Rel_, {\[Xi]0_, \[CurlyPhi]0_}] :=
Module[{\[Rho] = scaled\[Rho][\[Rho]Rel]},  
      {\[Rho], Ray[{\[Xi]0 (Sqrt[3]/2 - \[Rho]), -1/2}, {Cos[\[CurlyPhi]0], \
Sin[\[CurlyPhi]0]}]}]\
\>", "Input"],

Cell["Here are two examples of paths for different circle radii.", "Text"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity},
Function[{\[Rho]Rel, \[Xi]0, \[CurlyPhi]0, prec}, rayPathGraphic[Sqrt[3]/2 \
\[Rho]Rel,
         rayPath @@ N[scaledRayData[\[Rho]Rel, {\[Xi]0, \[CurlyPhi]0}], \
prec]]] @@@
         {{9/10, -1/2, Pi/6, 300}, {99/100, 0, Pi/6, 300}}]]];\
\>", "Input"],

Cell[TextData[{
  "Now, we analyze the path length on a grid in the ",
  Cell[BoxData[
      FormBox["\[Xi]0", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["\[CurlyPhi]0", TraditionalForm]]],
  "\[Hyphen]plane. The function ",
  StyleBox["exitResult", "MR"],
  " returns a two element list of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            StyleBox["pathLength",
              FontSlant->"Italic"], ",", 
            StyleBox["exitNumber",
              FontSlant->"Italic"]}], "}"}], TraditionalForm]]],
  ". We use circles of relative size ",
  Cell[BoxData[
      FormBox[
        RowBox[{"9", "/", "10"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "exitResult[\[Rho]Rel_, {\[Xi]0_, \[CurlyPhi]0_}, prec_] :=\nModule[{rP}, \n\
  rP = rayPath @@ N[scaledRayData[\[Rho]Rel, {\[Xi]0, \[CurlyPhi]0}], prec]; \
\n  {Length[rP], ",
  StyleBox["(* return 0 if no exit was reached *)", "CodeComment"],
  "\n   If[MemberQ[Last[rP], _Ray, Infinity], 0, rP[[-1, 1]]]}]"
}], "Input"],

Cell[TextData[{
  "To generate the exit number data for a dense grid in the ",
  Cell[BoxData[
      FormBox["\[Xi]0", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["\[CurlyPhi]0", TraditionalForm]]],
  "\[Hyphen]plane, we make use of the mirror symmetry of the circle \
configuration along the ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]axis. The function ",
  StyleBox["make\[Xi]\[CurlyPhi]ExitData", "MR"],
  " calculates the exit numbers for angles ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "<", "\[CurlyPhi]", "\[LessEqual]", 
          RowBox[{"\[Pi]", "/", "2"}]}], TraditionalForm]]],
  " explicitly and calculates the exit numbers for angles ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Pi]", "/", "2"}], "\[LessEqual]", "\[CurlyPhi]", "<", 
          RowBox[{"\[Pi]", "/", "2"}]}], TraditionalForm]]],
  " using symmetry. "
}], "Text"],

Cell[TextData[{
  "make\[Xi]\[CurlyPhi]ExitData[er_, \[Rho]Rel_, pp_, prec_] :=\nModule[{\
\[CurlyPhi]M = Pi If[EvenQ[pp], 1/2 , 1/2 - (1 - 2/pp)/pp/2], t},\n ",
  StyleBox["(* join data and double mirrored data *)", "CodeComment"],
  "\n Join[#, Map[Reverse, Map[{{#[[1, 1]], Pi - #[[1, 2]]}, \n             \
{#[[2, 1]], #[[2, 2]] /. {1 -> 2, 2 -> 1}}}&, \n            If[EvenQ[pp], \
Drop[#, -1], #], {2}], {0, 1}]]&[\n ",
  StyleBox["(* half of the data *)", "CodeComment"],
  "\n Table[{{\[Xi]0, \[CurlyPhi]0}, er[\[Rho]Rel, {\[Xi]0, \[CurlyPhi]0}, \
prec]},\n        {\[CurlyPhi]0, Pi/pp, \[CurlyPhi]M, (\[CurlyPhi]M - \
Pi/pp)/If[EvenQ[pp], pp/2, (pp - 1)/2]},\n        {\[Xi]0, -1 + 1/pp, 1 - \
1/pp, (2 - 2/pp)/pp}]]]"
}], "Input"],

Cell["\<\
Here are the path length and exit numbers for the circles of 90% \
their possible maximum size.\
\>", "Text"],

Cell["\<\
data[9/10] = make\[Xi]\[CurlyPhi]ExitData[exitResult, 9/10, 200, \
250];\
\>", "Input"],

Cell["\<\
We display the path length as a density plot and the exit number we \
indicate by red (exit 1), green (exit 2), and blue (exit 3) squares. In case \
too much precision was lost in the calculation and the exit number could not \
be determined, we draw a white square.\
\>", "Text"],

Cell[TextData[{
  "exitResultGraphics[exitData_] := \nShow[GraphicsArray[\n\
Block[{$DisplayFunction = Identity,\n       opts = Sequence[Mesh -> False, \
PlotRange -> All,\n       MeshRange -> {{-1 + 1/#, 1 - \
1/#}&[Length[exitData[[1]]] - 1],\n                     Pi {1/#, 1 - \
1/#}&[Length[exitData] - 1]}]},\n      {",
  StyleBox["(* path length graphic *)", "CodeComment"],
  "\n       ListDensityPlot[Log @ Map[#[[2, 1]]&, exitData, {2}], opts, \n    \
                  ColorFunction -> GrayLevel],\n       ",
  StyleBox["(* exit number graphic *)", "CodeComment"],
  "\n       ListDensityPlot[Map[#[[2, 2]]&, exitData, {2}], opts, \n          \
            ColorFunction -> \n                      (If[# == 0, ",
  StyleBox["(* no exit found *)", "CodeComment"],
  " RGBColor[1, 1, 1],\n                          MapAt[1&, RGBColor[0, 0, \
0], #]]&),\n                      ColorFunctionScaling -> False]}]]]"
}], "Input"],

Cell[TextData[{
  "For the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"9", "/", "10"}], TraditionalForm]]],
  " circle, we see bands of equal exit numbers. "
}], "Text"],

Cell["exitResultGraphics[data[9/10]]", "Input"],

Cell["\<\
The next two graphics show one of the longest ray paths and the \
cumulative distribution of all path lengths.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* extract longest path parameters *)", "CodeComment"],
  "\nextractLongestPath[data_] := Expand[Part[data, ##]& @@@ \n        \
Position[#, Max[#]]&[Map[#[[2, 1]]&, data, {2}]]]\n        \nmaxData = \
extractLongestPath[data[9/10]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* function to visualize longest path and \n   cumulative path \
length distribution *)", "CodeComment"],
  "\nshowMaxDataResults[\[Rho]Rel_, data_, prec_] := \nShow[GraphicsArray[\n\
Block[{$DisplayFunction = Identity},\n{",
  StyleBox["(* the path with the most reflections *)", "CodeComment"],
  "\n Module[{maxData = extractLongestPath[data], \[Xi]0, \[CurlyPhi]0}, \n   \
      {\[Xi]0, \[CurlyPhi]0} = maxData[[1, 1]];\n     \
rayPathGraphic[Sqrt[3]/2 \[Rho]Rel,\n                    rayPath @@ \
N[scaledRayData[\[Rho]Rel, {\[Xi]0, \[CurlyPhi]0}], prec]]],\n",
  StyleBox[" (* cumulative distribution of path lengths *)", "CodeComment"],
  "\n ListPlot[MapIndexed[{#2[[1]], Log[#1]}&, \n            \
Sort[Flatten[Map[#[[2, 1]]&, data, {2}]]]],\n         PlotRange -> All]}]]];  \
                  "
}], "Input"],

Cell["showMaxDataResults[9/10, data[9/10], 300]", "Input"],

Cell[TextData[{
  "For circles of relative size ",
  Cell[BoxData[
      FormBox[
        RowBox[{"99", "/", "100"}], TraditionalForm]]],
  ", we have potentially very long paths and so need many digits to calculate \
the exit number. To not slow down the calculation of the exit number of \
shorter paths by using excessively many digits, we define a function ",
  StyleBox["adapativeExitResult", "MR"],
  " that starts with precision ",
  StyleBox["prec", "TI"],
  ". In case no exit can be found, ",
  StyleBox["adapativeExitResult", "MR"],
  " iteratively doubles the precision until an exit is found."
}], "Text"],

Cell["\<\
adapativeExitResult[\[Rho]Rel_, {\[Xi]0_, \[CurlyPhi]0_}, \
precInit_] := 
Module[{er, prec = precInit},
       While[er = exitResult[\[Rho]Rel, {\[Xi]0, \[CurlyPhi]0}, prec]; 
             Last[er] === 0, prec = 2 prec]; er]\
\>", "Input"],

Cell[TextData[{
  "The next input shows an example where ",
  StyleBox["exitResult", "MR"],
  " fails, but ",
  StyleBox["adapativeExitResult", "MR"],
  " succeeds."
}], "Text"],

Cell["\<\
{exitResult[##], adapativeExitResult[##]}& @@
           {99/100, {121/147, 59/441 Pi}, 200}\
\>", "Input"],

Cell[TextData[{
  "Using a 2 GHz computer, we can now in about two hours calculate the exits \
on a ",
  Cell[BoxData[
      FormBox[
        RowBox[{"200", "\[Times]", "200"}], TraditionalForm]]],
  " grid. (Because all rays are independent, this problem is, of course, \
ideal for parallelization.)"
}], "Text"],

Cell["\<\
(data[99/100] = make\[Xi]\[CurlyPhi]ExitData[adapativeExitResult, 
                               99/100, 200, 250]); // Timing\
\>", "Input"],

Cell[TextData[{
  "Now, the bands from above have nearly disappeared and the points of a \
given color have nearby points of the other two colors [",
  
  CounterBox["BibliographyCounter", "Aguirre03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Aguirre03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["exitResultGraphics[data[99/100]]", "Input"],

Cell["showMaxDataResults[99/100, data[99/100], 800]", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Vibrating Hilbert curve"
}], "ExerciseHeading"],

Cell[TextData[{
  "Take the 2D Hilbert curve from Exercise 20 of Chapter 2 of the Graphics \
volume and embed it in a square grid (so that the edges of the Hilbert curve \
are along neighboring lattice points). Assuming springs of stiffness 1 \
between all neighboring grid points and springs of stiffness ",
  Cell[BoxData[
      FormBox["\[ScriptK]", TraditionalForm]]],
  " along the segments of the Hilbert curve, allow the point mass lattice \
points to oscillate in vertical direction (outermost lattice points are kept \
fixed). Calculate and visualize some of the resulting eigenoscillations for \
various stiffnesses ",
  Cell[BoxData[
      FormBox["\[ScriptK]", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We begin by constructing the Hilbert curve. It consists of 5561 line \
segments. We embed the curve in the square grid ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"[", 
            RowBox[{"0", ",", "82"}], "]"}], "\[Times]", 
          RowBox[{"[", 
            RowBox[{"0", ",", "82"}], "]"}]}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
LSystemWithFAndLAndR[axiom_, rules_, iterations_, \[Delta]_] :=
Module[{minus, plus, \[ScriptCapitalR], last = {0, 0}, d = {1, 0}},
 minus = {{ Cos[ \[Delta]], Sin[ \[Delta]]}, {-Sin[ \[Delta]], Cos[ \
\[Delta]]}};
 plus  = {{ Cos[-\[Delta]], Sin[-\[Delta]]}, {-Sin[-\[Delta]], \
Cos[-\[Delta]]}};
 \[ScriptCapitalR] = rules /. {(a_ -> b_) -> (a :> Sequence @@ b)};
Select[Prepend[
 (Which[# == \"F\", last = last + d, # == \"+\", d = plus.d; Null,
        # == \"-\", d = minus.d; Null, # == \"R\", Null,   
        # == \"L\", Null]& /@ Nest[(# /. \[ScriptCapitalR])&, axiom, \
iterations]),
      {0, 0}], # =!= Null&]]\
\>", "Input"],

Cell["order = 4; {L =  3^(order) + 1, dim = 3^(2 order)}", "Input"],

Cell["\<\
Show[Graphics[
 MapIndexed[{Hue[(#2[[1]] - 1)/3^(2 order)],
  Thickness[0.001], Line[#]}&, Partition[line = 
  {1, 1} + {1, -1}#& /@ LSystemWithFAndLAndR[{\"-\", \"L\"},
   {\"L\" -> Characters[\"LF+RFR+FL-F-LFLFL-FRFR+\"],
    \"R\" -> Characters[\"-LFLF+RFRFR+F+RF-LFL-FR\"]},
    order, 2Pi/4], 2, 1]]], AspectRatio -> Automatic, 
     Frame -> True, PlotRange -> L {{0, 1}, {0, 1}}]\
\>", "Input"],

Cell[TextData[{
  "To calculate the oscillations of the vertical spring network, we need the \
connectivity of the grid. The equation of motion for the lattice points ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["u", 
            RowBox[{"i", ",", "j"}]], "(", "t", ")"}], TraditionalForm]]],
  " is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              OverscriptBox["u", ".."], 
              RowBox[{"i", ",", "j"}]], "(", "t", ")"}], "=", 
          RowBox[{"\[Sum]", 
            RowBox[{
              SubsuperscriptBox["k", 
                RowBox[{"i", ",", "j"}], 
                RowBox[{
                  SuperscriptBox["i", "\[Prime]"], ",", 
                  SuperscriptBox["j", "\[Prime]"]}]], "(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["u", 
                    RowBox[{
                      SuperscriptBox["i", "\[Prime]"], ",", 
                      SuperscriptBox["j", "\[Prime]"]}]], "(", "t", ")"}], 
                "-", 
                RowBox[{
                  SubscriptBox["u", 
                    RowBox[{"i", ",", "j"}]], "(", "t", ")"}]}], ")"}]}]}], 
        TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["k", 
          RowBox[{"i", ",", "j"}], 
          RowBox[{
            SuperscriptBox["i", "\[Prime]"], ",", 
            SuperscriptBox["j", "\[Prime]"]}]], TraditionalForm]]],
  " is the stiffness of the spring that connects the lattice points ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"i", ",", "j"}], "}"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SuperscriptBox["i", "\[Prime]"], ",", 
            SuperscriptBox["j", "\[Prime]"]}], "}"}], TraditionalForm]]],
  " and the sum extends over the four neighboring lattice points of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"i", ",", "j"}], "}"}], TraditionalForm]]],
  " . Assuming ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              OverscriptBox["u", ".."], 
              RowBox[{"i", ",", "j"}]], "(", "t", ")"}], "\[Tilde]", 
          RowBox[{
            SuperscriptBox["e", 
              RowBox[{"i", " ", "\[Omega]", " ", "t"}]], 
            SubscriptBox[
              OverscriptBox["u", "^"], 
              RowBox[{"i", ",", "j"}]]}]}], TraditionalForm]]],
  ", the calculation of the eigenoscillations reduces to the calculation of \
the eigenvalues and eigenvectors of the coefficient matrix of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Sum]", 
          RowBox[{
            SubsuperscriptBox["k", 
              RowBox[{"i", ",", "j"}], 
              RowBox[{
                SuperscriptBox["i", "\[Prime]"], ",", 
                SuperscriptBox["j", "\[Prime]"]}]], "(", 
            RowBox[{
              SubscriptBox[
                OverscriptBox["u", "^"], 
                RowBox[{
                  SuperscriptBox["i", "\[Prime]"], ",", 
                  SuperscriptBox["j", "\[Prime]"]}]], "-", 
              SubscriptBox[
                OverscriptBox["u", "^"], 
                RowBox[{"i", ",", "j"}]]}], ")"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "To obtain a linear numbering of the lattice points, we number them \
consecutively, first in the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]",
  ", then in the ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]direction."
}], "Text"],

Cell["\<\
Do[vertexNumber[{i, j}] = (j - 1) (L - 1) + i, {i, L -1}, {j, L - \
1}] \
\>", "Input"],

Cell["\<\
Next, we find all lattice points that are connected by the Hilbert \
curve.\
\>", "Text"],

Cell["\<\
hData = Function[x, {x[[1, 1, 1]], {#1[[2]], #2}& @@@ x}] /@
Split[Sort[Flatten[{{#1, #2}, {Reverse[#1], #2}}&  @@@
 MapIndexed[{#1, \[ScriptK][#2[[1]]]}&, Partition[line, 2, 1]], 1]],
      (#[[1, 1]] === #2[[1, 1]])&];\
\>", "Input"],

Cell[TextData[{
  "Now, we assemble the coefficient matrix. It is a sparse ",
  Cell[BoxData[
      FormBox[
        RowBox[{"6561", "\[Times]", "6561"}], TraditionalForm]]],
  " matrix with ",
  Cell[BoxData[
      FormBox["32481", TraditionalForm]]],
  " elements."
}], "Text"],

Cell[TextData[{
  StyleBox["(* make rules for coefficients for neighbors *)", "CodeComment"],
  "\nmakeRules[{p_, ps_List}] :=\nBlock[{qs, pn = vertexNumber[p], \[ScriptL] \
= Length[ps]}, \n qs = DeleteCases[\n      Complement[(p + #)& /@ {{-1, 0}, \
{1, 0}, {0, -1}, {0, 1}},\n                 ps], {0, _} | {L, _} | {_, 0} | \
{_, L}];  \n ",
  StyleBox["(* the nonvanishing matrix elements *)", "CodeComment"],
  "\n Flatten[{{pn, pn} -> (Plus @@ (Last /@ ps)) + (4 - \[ScriptL]) 1,\n     \
     ({pn, vertexNumber[#1]} -> -#2)& @@@ ps,\n          ({pn, \
vertexNumber[#1]} -> -1)& /@ qs}]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* all coefficients *)", "CodeComment"],
  "\nallRules[\[ScriptK]_] = makeRules /@ hData;\n",
  StyleBox["(* create sparse arrays *)", "CodeComment"],
  "\nM[\[ScriptK]_] := SparseArray[Flatten[allRules[\[ScriptK]]]]"
}], "Input"],

Cell[TextData[{
  "We use three different values of ",
  Cell[BoxData[
      FormBox["\[ScriptK]", TraditionalForm]]],
  ": a small one, a large one, and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptK]", "=", "1"}], TraditionalForm]]],
  " (meaning a uniform spring network). Here are the corresponding values of \
extreme eigenvalues."
}], "Text"],

Cell[TextData[{
  StyleBox["(* three stiffness values *)", "CodeComment"],
  "\n\[ScriptK]List = {1/100, 1, 100};\nEvaluate[\[ScriptCapitalM] /@ \
\[ScriptK]List] = N[M /@ (Function /@ \[ScriptK]List)];\n\n\
(\[CurlyEpsilon]Range[#] = \nReverse[Eigenvalues[\[ScriptCapitalM][#], 2, \n  \
Method -> {\"Arnoldi\", Criteria -> \"BothEnds\",  BasisSize -> 20,\n         \
    MaxIterations -> 10^4}]])& /@ \[ScriptK]List"
}], "Input"],

Cell[TextData[{
  "Given a list of eigenvectors, the function ",
  StyleBox["makeGraphicsArrays", "MR"],
  " creates graphics arrays with the eigenoscillations of the three different \
spring stiffnesses adjacent."
}], "Text"],

Cell["\<\
makeGraphicsArrays[evsList_] := Show[GraphicsArray[#]]& /@ 
Map[ListDensityPlot[Partition[#, L - 1], Mesh -> False, 
       PlotRange -> All, DisplayFunction -> Identity,
       FrameTicks -> None]&, Transpose[evsList], {-2}]\
\>", "Input"],

Cell[TextData[{
  "Finally, we set some option values for the Arnoldi iterations (a smaller \
than the default tolerance is enough for visualization purposes). We use the \
",
  StyleBox["Shift", "MR"],
  " suboption to obtain eigenfunctions to different elements of the \
spectrum."
}], "Text"],

Cell["\<\
\[ScriptCapitalO][\[Lambda]___] := Method -> {\"Arnoldi\", \
BasisSize -> 40, 
              MaxIterations -> 10^4, Tolerance -> 10^-5,
              If[{\[Lambda]} =!= {}, Shift -> \[Lambda], Sequence @@ \
{}]}\
\>", "Input"],

Cell[TextData[{
  "Here are the lowest states for the three spring networks. On the \
background of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptK]", "=", "1"}], TraditionalForm]]],
  " springs, we see modulations due to the different spring stiffnesses along \
the Hilbert curve."
}], "Text"],

Cell["\<\
lowestStates = Reverse[Eigenvectors[\[ScriptCapitalM][#], -4, \
\[ScriptCapitalO][]]& /@ \[ScriptK]List];
makeGraphicsArrays[lowestStates];          \
\>", "Input"],

Cell["The highest states oscillate as frequently as possible.", "Text"],

Cell["\<\
highestStates = Eigenvectors[\[ScriptCapitalM][#], 4, \
\[ScriptCapitalO][]]& /@ \[ScriptK]List;
makeGraphicsArrays[highestStates];          \
\>", "Input"],

Cell["\<\
The eigenfunctions corresponding to central eigenvalues show a \
complicated behavior. The imprint of the Hilbert curve springs is clearly \
visible.\
\>", "Text"],

Cell["\<\
Do[Print[\"\[Alpha] = \", \[Alpha]];
middleStates = Eigenvectors[\[ScriptCapitalM][#], 3, \[ScriptCapitalO][#2]]& \
@@@ Transpose[
                  {\[ScriptK]List, (#1 + \[Alpha] (#2 - #1))& @@@ (\
\[CurlyEpsilon]Range /@ \[ScriptK]List)}];
makeGraphicsArrays[middleStates], {\[Alpha], 1/4, 3/4, 1/4}]       \
\>", \
"Input"],

Cell["\<\
We end with two random realizations where each individual spring \
along the Hilbert curve has a random stiffness.\
\>", "Text"],

Cell[TextData[{
  "SeedRandom[1];\n{\[ScriptCapitalM]R[1], \[ScriptCapitalM]R[2]} = ",
  StyleBox["(* realize random spring constant *)", "CodeComment"],
  "\nTable[Block[{\[ScriptK]},  \[ScriptK][k_] := \[ScriptK][k] = \
10^Random[Real, {-1, 1}]; M[\[ScriptK]]], {2}];\n\n",
  StyleBox["(* lowest and highest eigenvalues *)", "CodeComment"],
  "\n(\[CurlyEpsilon]Range[#] = \nReverse[Eigenvalues[\[ScriptCapitalM]R[#], \
2, \n  Method -> {\"Arnoldi\", Criteria -> \"BothEnds\",  BasisSize -> 20,\n  \
           MaxIterations -> 10^4}]])& /@ {1, 2}"
}], "Input"],

Cell["\<\
The lowest states are not changed globally, but the higher states \
are become quickly localized due to the random spring stiffnesses.\
\>", \
"Text"],

Cell[TextData[{
  StyleBox["(* lowest states *)", "CodeComment"],
  "\nmakeGraphicsArrays[Reverse @ Eigenvectors[\[ScriptCapitalM]R[#], -2, \
\[ScriptCapitalO][]]& /@ {1, 2}]          "
}], "Input"],

Cell[TextData[{
  StyleBox["(* intermediate states *)", "CodeComment"],
  "\nmakeGraphicsArrays[Reverse @ Eigenvectors[\[ScriptCapitalM]R[#], +4, \
\[ScriptCapitalO][4]]& /@ {1, 2}]          "
}], "Input"],

Cell[TextData[{
  StyleBox["(* highest states *)", "CodeComment"],
  "\nmakeGraphicsArrays[Reverse @ Eigenvectors[\[ScriptCapitalM]R[#], +4, \
\[ScriptCapitalO][8]]& /@ {1, 2}]          "
}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  4.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Hypercube Projections"
}], "ExerciseHeading"],

Cell[CellGroupData[{

Cell[TextData[{
  "Calculate and visualize various \[OpenCurlyDoubleQuote]optimal\
\[CloseCurlyDoubleQuote] projections of ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D hypercubes (say ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"d", "=", "4"}], ",", "5", ",", "6"}], TraditionalForm]]],
  ") onto a 2D hyperplane. Interpret \[OpenCurlyDoubleQuote]optimal\
\[CloseCurlyDoubleQuote] to mean minimizing the sum of the relative errors of \
all vertex distances ",
  "[",
  
  CounterBox["BibliographyCounter", "Abramson03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Abramson03",
    ButtonStyle->"Hyperlink"],
  "] ",
  "or minimizing the sum of the relative errors of all face areas."
}], "SolutionSubgroup"],

Cell["\<\
We start with two function definitions for normalizing a vector and \
calculating the distance between two points.\
\>", "Text"],

Cell["\<\
\[ScriptN] = #/Sqrt[#.#]&; \[ScriptL] = Sqrt[(#2 - #1).(#2 - #1)]&;\
\
\>", "Input"],

Cell[TextData[{
  "The vertices of a hypercube in ",
  StyleBox["dim", "TI"],
  " dimensions."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the vertices of a dimD unit cube *)", "CodeComment"],
  "\nvertices[dim_] := vertices[dim] = \nFlatten[Outer[List, Sequence @@ \
Table[{-1, 1}/2, {dim}]], dim - 1]"
}], "Input"],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["2", 
          StyleBox["dum",
            FontSlant->"Italic"]], TraditionalForm]]],
  " edges of a hypercube in ",
  StyleBox["dim", "TI"],
  " dimensions. We will use them later for visualizations."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the edge vertices of a dimD unit cube *)", "CodeComment"],
  "\nedges[dim_] := edges[dim] = \n",
  StyleBox["(* all n-tuples with one differing element *)", "CodeComment"],
  "\nMap[Position[vertices[dim], #][[1, 1]]&, Union[Sort /@ Flatten[\n        \
Table[Table[{vertices[dim][[j]], \n                     MapAt[-#&, \
vertices[dim][[j]], k]}, {k, dim}],\n                      {j, \
Length[vertices[dim]]}], 1]], {2}]"
}], "Input"],

Cell[TextData[{
  "And these are the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["dim",
            "TI"], " ", 
          RowBox[{"(", 
            RowBox[{
              StyleBox["dim",
                "TI"], "-", "1"}], ")"}], 
          SuperscriptBox["2", 
            RowBox[{
              StyleBox["dim",
                "TI"], "-", "3"}]], " "}], TraditionalForm]]],
  " 2D faces of a hypercube in ",
  StyleBox["dim", "TI"],
  " dimensions. We will also use them for visualizations and for \
minimization."
}], "Text"],

Cell[TextData[{
  "edgeToFaces[edge_] := \n",
  StyleBox["(* sweep out a face by moving an edge *)", "CodeComment"],
  "\nModule[{posis = Flatten[Position[Equal @@@ Transpose[edge], True]]},\n   \
    Table[Join[edge, MapAt[-#&, #, posis[[k]]]& /@ \n                  \
Reverse[edge]], {k, Length[posis]}]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* the face vertices of a dimD unit cube *)", "CodeComment"],
  "\nfaces[dim_] := faces[dim] = \n",
  StyleBox["(* all n-tuples with two differing elements *)", "CodeComment"],
  "\nMap[Position[vertices[dim], #][[1, 1]]&, #[[1, -1]]& /@ \n",
  StyleBox["(* sweep out all faces and keep one of each *)", "CodeComment"],
  "\nSplit[Sort[{Sort[#], #}& /@ Flatten[edgeToFaces /@ \n               \
Map[vertices[dim][[#]]&, edges[dim], {-1}], 1]],\n               #1[[1]] === \
#2[[1]]&], {2}]"
}], "Input"],

Cell[TextData[{
  "Next we carry out the straightforward implementation of the objective \
function representing the cumulative relative deviation of all pairwise \
vertex distances. The two arguments of the function ",
  StyleBox["relativeVertexPositionErrorSum", "MR"],
  " are two vectors in ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[DoubleStruckCapitalR]", 
          StyleBox["dim",
            "TI"]], TraditionalForm]]],
  " that span a 2D hyperplane."
}], "Text"],

Cell[TextData[{
  "relativeVertexPositionErrorSum[{d1_?(VectorQ[#, NumberQ]&), d2_}] :=\n\
Module[{dim = Length[d1], \[ScriptD]1, \[ScriptD]2, verticesProjected},\n ",
  StyleBox["(* two orthogonal vectors *)", "CodeComment"],
  "\n \[ScriptD]1 = \[ScriptN][d1]; \[ScriptD]2 = \[ScriptN][d2 - \
\[ScriptD]1.d2 \[ScriptD]1]; \n ",
  StyleBox["(* the projected vertices *)", "CodeComment"],
  "\n verticesProjected = {\[ScriptD]1.#, \[ScriptD]2.#}& /@ vertices[dim]; \n\
 ",
  StyleBox["(* sum of squares of edge length errors *)", "CodeComment"],
  "\n Sum[Abs[\[ScriptL][verticesProjected[[i]], verticesProjected[[j]]]/\n   \
      \[ScriptL][vertices[dim][[i]], vertices[dim][[j]]] - 1]^2, \n           \
{i, 2^dim}, {j, i - 1}]]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["projectedEdgesGraphics", "MR"],
  " shows the projected edges."
}], "Text"],

Cell[TextData[{
  "projectedEdgesGraphics[{d1_?VectorQ, d2_?VectorQ}, opts___] :=\n\
Module[{dim = Length[d1], \[ScriptD]1, \[ScriptD]2, verticesProjected},\n ",
  StyleBox["(* two orthogonal vectors *)", "CodeComment"],
  "\n \[ScriptD]1 = \[ScriptN][d1]; \[ScriptD]2 = \[ScriptN][d2 - \
\[ScriptD]1.d2 \[ScriptD]1];\n ",
  StyleBox["(* the projected vertices *)", "CodeComment"],
  "\n verticesProjected = {\[ScriptD]1.#, \[ScriptD]2.#}& /@ vertices[dim]; \n\
 ",
  StyleBox["(* show projected vertices and edges *)", "CodeComment"],
  "\n Graphics[{{Hue[0], Thickness[0.001], \n            Line /@ \
Map[verticesProjected[[#]]&, edges[dim], {-1}]},\n           {GrayLevel[0], \
PointSize[0.02], \n            Point /@ verticesProjected}},\n      opts, \
PlotRange -> All, AspectRatio -> Automatic]]\n      \n\
projectedEdgesGraphics[{min_?NumericQ, vals_}] := \n\
projectedEdgesGraphics[Partition[Last /@ vals, \n                             \
    Length[vals]/2], PlotLabel -> min]"
}], "Input"],

Cell[TextData[{
  "Here are the results, the number of function evaluations, and the timings \
for the four methods ",
  StyleBox["\"SimulatedAnnealing\"", "MR"],
  ", ",
  StyleBox["\"RandomSearch\"", "MR"],
  ", ",
  StyleBox["\"DifferentialEvolution\"", "MR"],
  ", and ",
  StyleBox["\"NelderMead\"", "MR"],
  " shown. Modulo rotations, the four projections are identical. And the \
minima all agree to many digits. To see the progress in finding the minimum, \
we define an auxiliary function ",
  StyleBox["relativeVertexPositionErrorSumL", "MR"],
  " that keeps a list of the function values obtained."
}], "Text"],

Cell["\<\
relativeVertexPositionErrorSumL[
             {d1_?(VectorQ[#, NumberQ]&), d2_}, L_] :=
With[{res = relativeVertexPositionErrorSum[{d1, d2}]},
     L = {L, res}; res]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* show graphic and return timings and function evaluations *)", 
    "CodeComment"],
  "\n(Show[GraphicsArray[#[[2, 2]]& /@ #]]; \n {#[[2, 1]], #[[2, 3]], \
#[[1]]}& /@ #)&[\nTiming[{#, \[ScriptCapitalL][#] = {}; \
projectedEdgesGraphics[\n ",
  StyleBox["(* find optimal projection hyperplane parameters *)", 
    "CodeComment"],
  "\n NMinimize[relativeVertexPositionErrorSumL[\n                    {{d1x, \
d1y, d1z}, {d2x, d2y, d2z}}, \n           ",
  StyleBox["(* bag for values *)", "CodeComment"],
  " Unevaluated[\[ScriptCapitalL][#]]],\n                     {d1x, d1y, d1z, \
d2x, d2y, d2z},\n           PrecisionGoal -> 2, Method -> #]], \n           \
",
  StyleBox["(* function evaluations *)", "CodeComment"],
  " Length[Flatten[\[ScriptCapitalL][#]]]}]& /@ \n           ",
  StyleBox["(* the four methods *)", "CodeComment"],
  "\n            {\"SimulatedAnnealing\", \"RandomSearch\",\n             \
\"DifferentialEvolution\", \"NelderMead\"}]"
}], "Input"],

Cell[TextData[{
  "Displaying the calculated the objective function values depending on the \
iteration number shows that ",
  StyleBox["\"SimulatedAnnealing\"", "MR"],
  " and ",
  StyleBox["\"NelderMead\"", "MR"],
  " find a good minimum after less than 200 search steps. The ",
  StyleBox["\"RandomSearch\"", "MR"],
  " plot shows many locations for a good projection."
}], "Text"],

Cell[TextData[{
  "convergenceListPlot[l_, opts___] := \nModule[{\[ScriptL] = Flatten[l], \
\[Lambda] = Last[l]}, \n    Block[{$DisplayFunction = Identity}, \n       ",
  StyleBox["(* logarithm of absolute error *)", "CodeComment"],
  "\n       ListPlot[DeleteCases[MapIndexed[{#2[[1]], #1}&, \n                \
 Log[10, Abs[(# - \[Lambda])& /@ \[ScriptL]]]],\n                 {_, \
Indeterminate}], PlotRange -> All]]];"
}], "Input"],

Cell["\<\
Show[GraphicsArray[#]]& /@ 
Partition[convergenceListPlot[\[ScriptCapitalL][#], PlotLabel -> #]& /@ 
           {\"SimulatedAnnealing\", \"RandomSearch\",
            \"DifferentialEvolution\", \"NelderMead\"}, 2];\
\>", "Input"],

Cell[TextData[{
  "The last result suggests the use of ",
  StyleBox["\"SimulatedAnnealing\"", "MR"],
  " and/or ",
  StyleBox["\"NelderMead\"", "MR"],
  " for higher dimensions in the following. To speed up the calculations, we \
implement a compiled version of ",
  StyleBox["relativeVertexPositionErrorSum", "MR"],
  ". We also allow for projections into 3D, 4D, \[Ellipsis] hyperspaces."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the main compiled function *)", "CodeComment"],
  "\ncf[dim_] := cf[dim] = \nCompile[{{ds, _Real, 2}},\nModule[{\[ScriptD]\
\[ScriptS] = ds, \[Lambda] = Length[ds], verticesProjected, \
\[ScriptCapitalV]s = #},\n ",
  StyleBox["(* make orthogonal vectors *)", "CodeComment"],
  "\n Do[\[ScriptD]\[ScriptS][[k]] = #/Sqrt[#.#]&[ds[[k]] - Sum[\[ScriptD]\
\[ScriptS][[j]] \[ScriptD]\[ScriptS][[j]].ds[[k]], \n    {j, \[Lambda] - \
1}]], {k, \[Lambda]}];\n ",
  StyleBox["(* the projected vertices *)", "CodeComment"],
  "\n verticesProjected = Table[\[ScriptCapitalV]s[[k]].#& /@ \[ScriptD]\
\[ScriptS], {k, Length[\[ScriptCapitalV]s]}];\n ",
  StyleBox["(* sum of squares of edge length errors *)", "CodeComment"],
  "\n Sum[Sum[Abs[Sqrt[#.#]&[verticesProjected[[i]] - \
verticesProjected[[j]]]/\n             Sqrt[#.#]&[\[ScriptCapitalV]s[[i]] - \
\[ScriptCapitalV]s[[j]]] - 1]^2,\n        {j, i - 1}], {i, Length[\
\[ScriptCapitalV]s]}]]]&[vertices[dim]];\n        \n",
  StyleBox["(* interface function to the compiled function *)", 
    "CodeComment"],
  "\nrelativeVertexPositionErrorSumCF[\n        {d1_?(VectorQ[#, NumberQ]&), \
d2__}] := cf[Length[d1]][{d1, d2}];"
}], "Input"],

Cell["\<\
Here are these two methods applied to hypercubes of dimensions \
four, five, and six. Again, the two methods agree quite well with one \
another.\
\>", "Text"],

Cell["\<\
Do[Show[GraphicsArray[#]]&[projectedEdgesGraphics[
     NMinimize[{relativeVertexPositionErrorSumCF[
                        Table[d[j][k], {j, 2}, {k, dim}]]},
               Flatten[Table[d[j][k], {j, 2}, {k, dim}]],
               PrecisionGoal -> 2, Method -> #]]& /@ 
               {\"SimulatedAnnealing\", \"NelderMead\"}], {dim, 4, 6}]\
\>", \
"Input"],

Cell["\<\
For comparison we show projections resulring from determining \
principal components. \
\>", "Text"],

Cell[TextData[{
  StyleBox["(* make a square k\[Times]k array of graphics *)", 
    "CodeComment"],
  "\ntoSquareArray[l_, k_] := \nModule[{mod = Mod[Length[l], k]}, \nIf[mod \
=== 0, Partition[l, k],\n   Append[Partition[l, k], Join[Take[l, -mod], \n    \
      Table[Graphics[{}], {k - mod}]]]]]"
}], "Input"],

Cell[TextData[{
  "Function[d, ",
  StyleBox["(* print dimension *)", "CodeComment"],
  "\n StylePrint[\"dim = \" <> ToString[d], \"PrintText\"];\n ",
  StyleBox["(* project onto principal components *)", "CodeComment"],
  "\n Module[{svd = \
SingularValueDecomposition[Transpose@N[vertices[d]]][[1]]},\n  \
Show[GraphicsArray[#]]& /@\n  \
toSquareArray[Flatten[Table[projectedEdgesGraphics[{svd[[i]], svd[[j]]}],\n   \
                    {i, 2, d}, {j, i + 1, d}]], 6]]] /@ {6, 7}"
}], "Input"],

Cell["\<\
Next we project into 3D and show the 2D faces of the resulting 3D \
objects as holed planes. Here are some function to show the projected 2D \
faces of the hypercubes.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* quadrilateral spanned by p1, p2, p3, p4 *)", "CodeComment"],
  "\nmakeHoled3DPolygon[{p1_, p2_, p3_, p4_}, pp_, f_] := \nModule[{points = \
Table[p1 + i j/pp^2 (p1 + p3 - p2 - p4) +\n                       i/pp (p2 - \
p1) + j/pp (p4 - p1), \n                {i, 0, pp}, {j, 0, pp}], polys},\n \
polys = Table[Polygon[{points[[i, j]], points[[i + 1, j]], \n                 \
       points[[i + 1, j + 1]], points[[i, j + 1]]}], \n               {i, \
pp}, {j, pp}];\n makeHole[#, f]& /@ Flatten[polys]]\n\nmakeHole[Polygon[l_], \
f_] := ",
  StyleBox["(* cut a hole in a polygon *)", "CodeComment"],
  "\nModule[{mp = Plus @@ l/Length[l], L}, L = (mp + f(# - mp))& /@ l;\n      \
 {MapThread[Polygon[Join[#1, Reverse[#2]]]&, \n                  \
Partition[Append[#, First[#]], 2, 1]& /@ {l, L} ]}]"
}], "Input"],

Cell[TextData[{
  "projectedFacesGraphics3D[{d1_, d2_, d3_}, opts___] :=\nModule[{dim = \
Length[d1], \[ScriptD]1, \[ScriptD]2, \[ScriptD]3, verticesProjected},\n ",
  StyleBox["(* three orthogonal vectors *)", "CodeComment"],
  "\n \[ScriptD]1 = \[ScriptN][d1]; \[ScriptD]2 = \[ScriptN][d2 - \
\[ScriptD]1.d2 \[ScriptD]1]; \[ScriptD]3 = \[ScriptN][d3 - \[ScriptD]1.d3 \
\[ScriptD]1 - \[ScriptD]2.d3 \[ScriptD]2]; \n ",
  StyleBox["(* the projected vertices *)", "CodeComment"],
  "\n verticesProjected = {\[ScriptD]1.#, \[ScriptD]2.#, \[ScriptD]3.#}& /@ \
vertices[dim]; \nGraphics3D[{{SurfaceColor[Hue[Random[]], Hue[Random[]], 3 \
Random[]], \n             EdgeForm[], makeHoled3DPolygon[#, 6, 0.82]}& /@ \n  \
           Map[verticesProjected[[#]]&, faces[dim], {-1}],\n            \
{GrayLevel[0], PointSize[0.02], Point /@ verticesProjected}},\n      opts, \
PlotRange -> All, BoxRatios -> Automatic]]\n      \n\
projectedFacesGraphics3D[{min_?NumericQ, vals_}] := \n\
projectedFacesGraphics3D[Partition[Last /@ vals, Length[vals]/3]]"
}], "Input"],

Cell[TextData[{
  "These are the resulting 3D projections. We use only the ",
  StyleBox["\"NelderMead\"", "MR"],
  " method."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
    Table[projectedFacesGraphics3D[
      NMinimize[relativeVertexPositionErrorSumCF[
                        Table[d[j][k], {j, 3}, {k, dim}]],
             Flatten[Table[d[j][k], {j, 3}, {k, dim}]],
             PrecisionGoal -> 2, Method -> \"NelderMead\"]], {dim, 4, 5}]]]\
\
\>", "Input"],

Cell[TextData[{
  "We end with minimizing the area differences of all 2D faces in 2D \
projections. The function ",
  StyleBox["relativeErrorSumArea", "MR"],
  " calculates the cumulative relative face area deviation."
}], "Text"],

Cell[TextData[{
  StyleBox["(* the main compiled function *)", "CodeComment"],
  "\ncfArea[dim_] := cfArea[dim] = \nCompile[{{d1, _Real, 1}, {d2, _Real, \
1}},\nModule[{\[ScriptD]1, \[ScriptD]2, verticesProjected, p1, p2, p3, p4,\n  \
      a, b, c, \[ScriptCapitalA]1, \[ScriptCapitalA]2, area = 0., \
\[ScriptCapitalV]s = #1, \[ScriptCapitalF]s = #2},\n ",
  StyleBox["(* make orthogonal vectors *)", "CodeComment"],
  "\n \[ScriptD]1 = #/Sqrt[#.#]&[d1]; \[ScriptD]2 = #/Sqrt[#.#]&[d2 - \
\[ScriptD]1.d2 \[ScriptD]1]; \n ",
  StyleBox["(* the projected vertices *)", "CodeComment"],
  "\n verticesProjected = {\[ScriptD]1.#, \[ScriptD]2.#}& /@ \
\[ScriptCapitalV]s; \n ",
  StyleBox["(* sum of squares of face area errors *)", "CodeComment"],
  "\n Sum[{p1, p2, p3, p4} = Map[verticesProjected[[#]]&, \
\[ScriptCapitalF]s[[i]], {-1}];\n     ",
  StyleBox["(* split quadrilateral into two triangles *)", "CodeComment"],
  "\n     {a, b, c} = Sqrt[#.#& /@ {p1 - p2, p2 - p3, p3 - p1}]; \n     \
\[ScriptCapitalA]1 = Sqrt[(-a + b + c) (a + b - c) (a - b + c) (a + b + c)];\n\
     {a, b, c} = Sqrt[#.#& /@ {p3 - p4, p4 - p1, p1 - p3}];\n     \
\[ScriptCapitalA]2 = Sqrt[(-a + b + c) (a + b - c) (a - b + c) (a + b + c)]; \
\n     area = (\[ScriptCapitalA]1 + \[ScriptCapitalA]2)/4;                    \
     \n     (1/area - 1)^2, {i, \
Length[\[ScriptCapitalF]s]}]]]&[vertices[dim], faces[dim]]\n     \n",
  StyleBox["(* interface function to the compiled function *)", 
    "CodeComment"],
  "\nrelative2DFaceAreaErrorSumCF[\n        {d1_?(VectorQ[#, NumberQ]&), \
d2__}] := cfArea[Length[d1]][d1, d2];    "
}], "Input"],

Cell["\<\
This time, we obtain very symmetric projections. Again, the minima \
and the resulting projections agree for the two methods.\
\>", "Text"],

Cell["\<\
Do[Show[GraphicsArray[projectedEdgesGraphics[
 NMinimize[{relative2DFaceAreaErrorSumCF[Table[d[j][k], {j, 2}, {k, dim}]]},
           Flatten[Table[d[j][k], {j, 2}, {k, dim}]],
           PrecisionGoal -> 3, Method -> #]]& /@ 
                        {\"SimulatedAnnealing\", \"NelderMead\"}]], 
    {dim, 3, 6}]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  5.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Currents through a Penrose Tiling"
}], "ExerciseHeading"],

Cell["\<\
Let the edges of an aperiodic Penrose tiling made from darts and \
kites be wires with finite resistances. By selecting outer and inner vertices \
as the current source and drains, calculate and visualize the potential and \
current distribution through the edge network. Use identical and random \
resistance values along the edges.\
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with the construction of the Penrose tiling by slightly modifying \
the code from Chapter 1 of the Graphics volume. ",
  StyleBox["pTiling[", "MR"],
  StyleBox["o", "TI"],
  StyleBox["]", "MR"],
  " gives a list of the kites and darts for the ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  "th iteration of the tiling. We use high\[Hyphen]precision values to \
identify identical vertices in machine precision."
}], "SolutionSubgroup"],

Cell["Off[General::\"spell\"]; Off[General::\"spell1\"];", "Input"],

Cell[TextData[{
  StyleBox["(* the inflation rule *)", "CodeComment"],
  "\nkiteDartRule = {p_, kd:(\"kite\" | \"dart\")} :>\nModule[{\[ScriptF], a, \
b, c, d, e, f, g, h, i}, {a, b, c, d} = p;\n       \[ScriptF][a_, b_] = (a + \
GoldenRatio b)/(1 + GoldenRatio);\n       ",
  StyleBox["(* construct new dart and kites *)", "CodeComment"],
  "\n       Sequence @@ If[kd === \"kite\",\n          e = \[ScriptF][a, c]; \
f = \[ScriptF][b, a]; g = \[ScriptF][d, a];\n          h = a + c - d; i = a + \
c - b;\n          {{{b, c, e, f}, \"kite\"}, {{d, g, e, c}, \"kite\"},\n      \
     {{f, e, a, h}, \"dart\"}, {{g, i, a, e}, \"dart\"}},\n          ",
  StyleBox["(* last tile was a dart *)", "CodeComment"],
  " e = \[ScriptF][c, b]; f = \[ScriptF][c, d];\n          g = b + c - a; h = \
d + c - a;\n          {{{c, f, a, e}, \"kite\"}, {{e, a, b, g}, \"dart\"},\n  \
         {{f, h, d, a}, \"dart\"}}]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* start kite *)", "CodeComment"],
  "\npTiling[0] = {{{{0, 0}, GoldenRatio {Cos[36\[Degree]], \
Sin[36\[Degree]]},\n               GoldenRatio {1, 0}, GoldenRatio {Cos[36\
\[Degree]], -Sin[36\[Degree]]}},\n             \"kite\"}} // N[#, 30]&;\n     \
        \n",
  StyleBox["(* recursively apply kiteDartRule *)", "CodeComment"],
  "\npTiling[i_] := pTiling[i] = #[[1, 2]]& /@ \n Split[Sort[{N[#[[1]]], #}& \
/@ (pTiling[i - 1] /. kiteDartRule)], \n            ",
  StyleBox["(* identical tiles? *)", "CodeComment"],
  " #1[[1]] === #2[[1]]&]"
}], "Input"],

Cell[TextData[{
  "The functions ",
  StyleBox["edges", "MR"],
  " and ",
  StyleBox["vertices", "MR"],
  " give the edges and vertices after the ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  "th iteration."
}], "Text"],

Cell["\<\
edges[o_] := edges[o] = Union[Sort /@ 
     Flatten[Partition[Append[#, First[#]], 2, 1]& /@ 
                         N[First /@ pTiling[o]], 1]];\
\>", "Input"],

Cell["vertices[o_] := vertices[o] = Union[Level[edges[o], {-2}]];", "Input"],

Cell[TextData[{
  "For indexing the voltages and currents, we prefer to use integers instead \
of approximate coordinates. So, we define the two function ",
  StyleBox["vertexNumber", "MR"],
  " and ",
  StyleBox["vertexCoordinates", "MR"],
  " that convert the explicit coordinates to integer numbers, back and \
forth."
}], "Text"],

Cell[TextData[{
  "makeVertexDefinitions[o_] :=\nDo[",
  StyleBox["(* cache coordinates and number of the vertices *)", 
    "CodeComment"],
  "\n   vertexNumber[o][vertices[o][[k]]] = k;\n   vertexCoordinates[o][k] = \
vertices[o][[k]],\n   {k, Length[vertices[o]]}]"
}], "Input"],

Cell["\<\
allNumberedEdges[o_] := allNumberedEdges[o] =
           Map[vertexNumber[o], edges[o], {-2}];\
\>", "Input"],

Cell["\<\
Here are the counts of the vertices and edges for the first eight \
iterations. The eight iteration leads to more than 20000 equations for the \
current and voltages (edges and vertices).\
\>", "Text"],

Cell["\<\
Table[makeVertexDefinitions[o];
      {o, Length[edges[o]], Length[vertices[o]]}, {o, 8}] // 
 TableForm[#, TableHeadings -> {None, 
  StyleForm[#, FontWeight -> \"Bold\"]& /@ {\"\", \"edges\", \"vertices\"}}]& \
 \
\>", "Input"],

Cell["\<\
Now we start with the first actual constellation. We use the 8th \
iteration and place the current source and drains at the left lower and right \
upper vertices.\
\>", "Text"],

Cell["\<\
order = 8;
{zeroVVertices[order], oneVVertices[order]} = List /@
vertexNumber[order] /@ {#[[1]], #[[-1]]}&[Sort[vertices[order]]]\
\>", "Input"],

Cell["Here is a sketch of this configuration.", "Text"],

Cell[TextData[{
  "Show[Graphics[{{Thickness[0.001], ",
  StyleBox["(* all edges *)", "CodeComment"],
  "\n               {GrayLevel[1/2], Line[#]}& /@ edges[order]},\n            \
   ",
  StyleBox["(* source and drain vertices *)", "CodeComment"],
  "\n               {PointSize[0.04], Hue[0], Point /@ \n                \
vertexCoordinates[order] /@ zeroVVertices[order]},\n               \
{PointSize[0.04], Hue[0.76], Point /@ \n                \
vertexCoordinates[order] /@ oneVVertices[order]}}],\n                  \
AspectRatio -> Automatic]"
}], "Input"],

Cell["\<\
To write down the current conservation law at all vertices (the \
source and drain vertices are held at a fixed potential), we construct list \
of all edges that meet at a given vertex.\
\>", "Text"],

Cell["\<\
edgesAtVertices[o_] := edgesAtVertices[o] =
{#[[1, 1]], Last /@ #}& /@
Split[Sort[Flatten[{{#[[1]], #}, {#[[2]], #}}& /@ 
           allNumberedEdges[o], 1]], #1[[1]] === #2[[1]]&];\
\>", "Input"],

Cell[TextData[{
  "Now, we write all equations governing the current flow through the edges \
of the tiling. Along all edges, we have ",
  StyleBox["i[", "MR"],
  StyleBox["a", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["b", "TI"],
  StyleBox["] = (u[", "MR"],
  StyleBox["b", "TI"],
  StyleBox["] - u[", "MR"],
  StyleBox["a", "TI"],
  StyleBox["])/R[", "MR"],
  StyleBox["a", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["b", "TI"],
  StyleBox["]", "MR"],
  " where ",
  StyleBox["i[", "MR"],
  StyleBox["a", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["b", "TI"],
  StyleBox["]", "MR"],
  " is the current from vertex ",
  StyleBox["a", "TI"],
  " to vertex ",
  StyleBox["b", "TI"],
  ". And with all edges oriented, we can write down the current conservation \
equations for all nonsource and nondrain vertices. For a given network \
specified by the edges and the connectivity, the function ",
  StyleBox["makeUIEquations", "MR"],
  " returns the equations for the voltage values at the vertices and for the \
currents through the edges. Without loss of generality (because we assume a \
linear relation between current and voltage), we set the source potential to \
zero and the drain potential to one."
}], "Text"],

Cell[TextData[{
  "makeUIEquations[numberedEdges_, edgesAtVertices_,\n                \
{zeroVVertices_, oneVVertices_}, R_, {u_, i_}] :=\nFlatten @ {\n",
  StyleBox["(* voltage drops across a resistor *)", "CodeComment"],
  "\ni[#1, #2] == (u[#2] - u[#1])/R[#1, #2]& @@@ \n          numberedEdges,\n\
",
  StyleBox["(* current conservation at a vertex *)", "CodeComment"],
  "\nFunction[{vertex, edgeList}, 0 == ",
  StyleBox["(* all directed currents *)", "CodeComment"],
  "\n Plus @@ ((If[# === vertex, 1, -1] i[##])& @@@ edgeList)] @@@ \n    \
DeleteCases[edgesAtVertices, \n                ",
  StyleBox["(* no current conservation for \n                   source and \
drain vertices *)", "CodeComment"],
  "\n                Alternatives @@ ({#, _}& /@ \n                \
Flatten[{zeroVVertices, oneVVertices}])]} /.\n    ",
  StyleBox["(* source and drain voltage values *)", "CodeComment"],
  "\n    Dispatch[Join[(u[#] -> 0)& /@ zeroVVertices, \n                  \
(u[#] -> 1)& /@ oneVVertices]]"
}], "Input"],

Cell["\<\
We start by using identical resistance (value 1) for all edges. \
Here are the 20262 equations in 20262 variables.\
\>", "Text"],

Cell["\<\
eqs = makeUIEquations[allNumberedEdges[order], \
edgesAtVertices[order],
                      {zeroVVertices[order], oneVVertices[order]}, 
                      1&, {u, i}];\
\>", "Input"],

Cell["\<\
iuVariables[eqs_] := Cases[eqs, _u | _i, Infinity] // Union

vars = iuVariables[eqs];
Length /@ {eqs, vars}\
\>", "Input"],

Cell[TextData[{
  "We solve the equations with a direct call to ",
  StyleBox["Solve", "MR"],
  ". For an efficient solution, we numericalize the equations."
}], "Text"],

Cell[TextData[{
  StyleBox["(* avoid numericalizations of the variable numbering *)", 
    "CodeComment"],
  "\nSetAttributes[{u, i}, NHoldAll];\nsol1 = Solve[N @ eqs, vars];"
}], "Input"],

Cell[TextData[{
  "To visualize the result ",
  StyleBox["sol1", "MR"],
  ", we implement the two functions ",
  StyleBox["voltagePlot", "MR"],
  " and ",
  StyleBox["currentPlot", "MR"],
  ". The first plot draws the vertices colored according to the voltage. Blue \
is low and red is high. The second is a plot of the magnitudes of the current \
along the edges. Again blue is lowest and red is highest."
}], "Text"],

Cell[TextData[{
  "voltagePlot[o_, sol_, u_] :=\nModule[{\[Lambda] = Cases[sol, _u, Infinity] \
// Union // Length, us, cs},\n",
  StyleBox["(* different voltage values *)", "CodeComment"],
  "\nus = Union[Rationalize[SetPrecision[#, 6], 0]& @\n     Sort[Last /@ \
Cases[sol, HoldPattern[_u -> _], Infinity]]];\n",
  StyleBox["(* make groups of voltage values and color function *)", 
    "CodeComment"],
  "\ncs = Round[Length[us]/10]; ipo = Interpolation[\nMapIndexed[{#1, #2[[1]] \
- 1}&, Flatten[{0, \n    #[[Round[Length[#]/2]]]& /@ ",
  StyleBox["(* homogeneous coloring *)", "CodeComment"],
  "\n                Partition[us, Round[Length[us]/cs]], 1}]]];\n",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\nShow[Graphics[{",
  StyleBox["(* scale points *)", "CodeComment"],
  " PointSize[1/Sqrt[\[Lambda]]/2], \n({Hue[0.78 (1 -  Abs[ipo[u[#]]/cs])], \n\
Point[vertexCoordinates[o][#]]}& /@  \n      Range[Length[vertices[o]]]) /. \
Dispatch[sol[[1]]] /.\n    ",
  StyleBox["(* the drain and source vertices *)", "CodeComment"],
  "\n    Dispatch[Join[(u[#] -> 0)& /@ zeroVVertices[o], \n                  \
(u[#] -> 1)& /@ oneVVertices[o]]]}],\n      AspectRatio -> Automatic]];"
}], "Input"],

Cell[TextData[{
  "currentPlot[o_, sol_, i_] :=\nModule[{\[Lambda] = Length[Union[Cases[sol, \
_i, Infinity]]], is, cs},\n",
  StyleBox["(* different current values *)", "CodeComment"],
  "\nis = Union[Rationalize[SetPrecision[#, 6], 0]& @\n     (is0 = \
Sort[Abs[Last /@ Cases[sol, HoldPattern[_i -> _],\n                 \
Infinity]]])];\n",
  StyleBox["(* make groups of voltage values and color function *)", 
    "CodeComment"],
  "\ncs = Round[Length[is]/20]; ipo = Interpolation[\nMapIndexed[{#1, #2[[1]] \
- 1}&, Flatten[{is0[[1]], \n#[[Round[Length[#]/2]]]& /@ \n Partition[is, \
Round[Length[is]/cs]], is0[[-1]]}]]];\n",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\nShow[Graphics[{",
  StyleBox["(* scale line thickness *)", "CodeComment"],
  " Thickness[1/\[Lambda]], \n({Hue[0.78 (1 - Abs[ipo[Abs[i @@ #]]]/cs)], \n  \
Line[vertexCoordinates[o] /@ #]}& /@ allNumberedEdges[o]) /. \n               \
                   Dispatch[sol[[1]]]}],\n      AspectRatio -> Automatic]]"
}], "Input"],

Cell[TextData[{
  "We unite the two last types of plots in the function ",
  StyleBox["voltageCurrentPlot", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* show voltages and currents together *)", "CodeComment"],
  "\nvoltageCurrentPlot[o_, sol_] := \nShow[GraphicsArray[\n\
Block[{$DisplayFunction = Identity},\n      {voltagePlot[o, sol, u], \
currentPlot[o, sol, i]}]]];"
}], "Input"],

Cell["\<\
Here are the resulting voltage and current distribution for our \
first example. Coarse grained, the voltage is an increasing function from the \
left lower to the right upper corner. (The voltages can be considered as a \
discrete approximation to the Laplace equation of the electric potential. \
And, as a harmonic function it cannot have a local minimum or maximum.) The \
currents flow mainly along the diagonal. The occasional blue edges along the \
diagonal area are due to nearly or exactly identical voltages at their \
endpoints.\
\>", "Text"],

Cell["voltageCurrentPlot[order, sol1];    ", "Input"],

Cell["\<\
We repeat the voltage and current calculation for the last network \
with random resistances. We start with a uniform distribution of the \
resistance values. Now, the current distribution looks less regular.\
\>", \
"Text"],

Cell[TextData[{
  "SeedRandom[1];\n",
  StyleBox["(* form equations *)", "CodeComment"],
  "\neqs = makeUIEquations[allNumberedEdges[order], edgesAtVertices[order],\n \
                    {zeroVVertices[order], oneVVertices[order]}, \n           \
          Random[]&, {u, i}];\n",
  StyleBox["(* visualize solutions *) ", "CodeComment"],
  "                    \nvoltageCurrentPlot[order, sol2 = Solve[N @ eqs, \
vars]]                    "
}], "Input"],

Cell["\<\
Next, we use a more stretched out distribution with resistance \
values spanning eight orders of magnitude. The current from the left lower \
vertex to the right upper vertex occurs now along more pronounced paths \
instead in a more uniform manner along the diagonal. The voltage distribution \
looks nearly identical to the last one.\
\>", "Text"],

Cell[TextData[{
  "SeedRandom[2];\n",
  StyleBox["(* form equations *)", "CodeComment"],
  "\neqs = makeUIEquations[allNumberedEdges[order], edgesAtVertices[order],\n \
                    {zeroVVertices[order], oneVVertices[order]}, \n           \
          10^Random[Real, {-4, 4}]&, {u, i}];\n",
  StyleBox["(* visualize solutions *) ", "CodeComment"],
  "                     \nvoltageCurrentPlot[order, sol3 = Solve[N @ eqs, \
vars]]                   "
}], "Input"],

Cell[TextData[{
  "At this point, let us check the quality of the solutions. The maximal \
residual is about ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", "\[Times]", 
          SuperscriptBox["10", 
            RowBox[{"-", "11"}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["Max[Abs[(Subtract @@@ eqs) /. Dispatch[sol3[[1]]]]]", "Input"],

Cell[TextData[{
  "We could now continue by making the resistance of some edges infinite by \
using ",
  StyleBox["If[Random[] < ", "MR"],
  StyleBox["p", "TI"],
  StyleBox[", 1, Infinity],", "MR"],
  " effectively reducing the number of potential current paths from the \
source to the drain, but leave this to the reader."
}], "Text"],

Cell[TextData[{
  "We continue with a configuration where we make all outer vertices are \
current drains and the central vertex is the source. The functions ",
  StyleBox["outerVertices", "MR"],
  " and ",
  StyleBox["centralVertex", "MR"],
  " calculate these vertices for a given iteration order ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
outerVertices[o_] := outerVertices[o] = 
vertexNumber[order] /@ Union[Flatten[
Select[Split[Sort[Sort /@ Flatten[
              Partition[Append[#, First[#]], 2, 1]& /@ 
                       N[First /@ pTiling[o]], 1]]],
       Length[#] == 1&], 2]];\
\>", "Input"],

Cell["\<\
centralVertex[o_] := centralVertex[o] =
Module[{mp = Plus @@ vertices[o]/Length[vertices[o]], distances},
       distances = Sqrt[#.#]&[mp - #]& /@ vertices[o];
       vertexNumber[o] @ vertices[o][[
              Position[distances, Min[distances]][[1, 1]]]]]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* the outer and inner vertices for the current iteration order \
*)", "CodeComment"],
  "\n{zeroVVertices[order], oneVVertices[order]} = \n{outerVertices[order], \
{centralVertex[order]}};"
}], "Input"],

Cell["\<\
Here are the resulting voltage and current distributions for all \
edges having identical resistance values.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* form equations *)", "CodeComment"],
  "\neqs = makeUIEquations[allNumberedEdges[order], edgesAtVertices[order],\n \
                    {outerVertices[order], {centralVertex[order]}}, \n        \
             1&, {u, i}];"
}], "Input"],

Cell[TextData[{
  "vars = iuVariables[eqs];\n",
  StyleBox["(* visualize solutions *) ", "CodeComment"],
  "\nvoltageCurrentPlot[order, sol4 = Solve[N @ eqs, vars]]"
}], "Input"],

Cell["\<\
Using again random resistance values along the edges shows a \
network of current paths. The voltage distribution looks similar but has some \
different details.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* use two different resistance values *)", "CodeComment"],
  "\nSeedRandom[3];\n",
  StyleBox["(* form equations *)", "CodeComment"],
  "\neqs = makeUIEquations[allNumberedEdges[order], edgesAtVertices[order],\n \
                    {outerVertices[order], {centralVertex[order]}}, \n        \
              If[Random[] < 0.1, 1, 10^6]&, {u, i}];\n",
  StyleBox["(* visualize solutions *) ", "CodeComment"],
  "\nvoltageCurrentPlot[order, sol5 = Solve[N @ eqs, vars]]                   \
"
}], "Input"],

Cell[TextData[{
  StyleBox["(* use continuous distribution of resistance values *)", 
    "CodeComment"],
  "\nSeedRandom[4];\n",
  StyleBox["(* form equations *)", "CodeComment"],
  "\neqs = makeUIEquations[allNumberedEdges[order], edgesAtVertices[order],\n \
                    {outerVertices[order], {centralVertex[order]}}, \n        \
              10^Random[Real, {-4, 4}]&, {u, i}];\n",
  StyleBox["(* visualize solutions *) ", "CodeComment"],
  "\nvoltageCurrentPlot[order, sol6 = Solve[N @ eqs, vars]]"
}], "Input"],

Cell["We end with a plot of the currents on a logarithmic scale.", "Text"],

Cell["\<\
Show[
Graphics[{Hue[#1], PointSize[0.002],
  MapIndexed[If[#1 == 0., {}, Point[{#2[[1]], Log[10, #1]}]]&,
      Sort[Abs[Last /@ Cases[#2, HoldPattern[_i -> _], 
     Infinity]]]]}]& @@@
   {{0, sol1}, {0.1, sol2}, {0.2, sol3}, {0.33, sol4}, 
    {0.44, sol5}, {0.78, sol6}},
Frame -> True, PlotRange -> {-15, 0}]\
\>", "Input"],

Cell[TextData[{
  "For some theoretical results about the current distribution of random \
resistor networks, see [",
  
  CounterBox["BibliographyCounter", "Straley89"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Straley89",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Duxbury95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Duxbury95",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Barthelemy00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Barthelemy00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Stenull03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Stenull03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Pennetta02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Pennetta02",
    ButtonStyle->"Hyperlink"],
  "]. For the resistance of a Sierpinski carpet, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Barlow90"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Barlow90",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  6.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Various PDEs"
}], "ExerciseHeading"],

Cell["\<\
Collect various \[OpenCurlyDoubleQuote]interesting\
\[CloseCurlyDoubleQuote] 1+1 and 1+2 PDEs and PDE systems from the literature \
(or self\[Hyphen]constructed ones) and visualize the qualitative shape of \
their solutions. \
\>", "Text"],

Cell[CellGroupData[{

Cell["\<\
This is, of course, an exercise with endless solution \
possibilities. We present a selection of various PDEs and PDE systems.\
\>", \
"SolutionSubgroup"],

Cell[TextData[{
  "We start with a simple system of two coupled equations depending from the \
two independent variables ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["g", TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "Sakajo04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sakajo04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Derivative terms appear only for the variable ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  ". This means, this system is basically a parametrized coupled system of \
ordinary differential equations. The solution shows a spiral\[Hyphen]like \
behavior."
}], "Text"],

Cell[TextData[{
  "Module[{d = 0.4,  ppL = 5000, ndsol, x, y, t, g},\nndsol = ",
  StyleBox["(* pseudo PDE; no derivatives with respect to g *)", 
    "CodeComment"],
  "\nNDSolve[{D[x[t, g], t] == -1/2 Sinh[2 Pi y[t, g]]/\n                     \
          (Cosh[2 Pi y[t, g]] - Cos[2 Pi x[t, g]] + d^2),\n         D[y[t, \
g], t] == +1/2 Sin [2 Pi x[t, g]]/\n                               (Cosh[2 Pi \
y[t, g]] - Cos[2 Pi x[t, g]] + d^2),\n         x[0, g] == -1/2 + g, y[0, g] \
== 0}, \n        {x, y}, {t, -1, 1}, {g, 0, 1},\n         Method -> \
{\"MethodOfLines\", \"SpatialDiscretization\" -> \n                    \
{\"TensorProductGrid\", \"DifferenceOrder\" -> 4, \n                    \
\"MaxPoints\" -> {ppL}, \"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* 3D plot of {y[t, g], y[t, g], t} *)", "CodeComment"],
  "\nParametricPlot3D[Evaluate[{x[t, g], y[t, g], t} /. ndsol[[1]]],\n        \
         {g, 0, 1}, {t, -1/2, 1}, PlotRange -> All,\n                 \
PlotPoints -> {240, 60}, Axes -> False]]"
}], "Input"],

Cell[TextData[{
  "The following 1+2 PDE system generates interestingly structured labyrinth\
\[Hyphen]like solutions [",
  
  CounterBox["BibliographyCounter", "Cartwright02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cartwright02",
    ButtonStyle->"Hyperlink"],
  "]. It is used to model brain growth. The model has four parameters ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["\[Beta]", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["\[Nu]", TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox["\[Delta]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
eqs1[{\[Gamma]_, \[Beta]_, \[Nu]_, \[Delta]_}] := 
 {D[\[Psi][t, x, y], t] == \[Gamma] (\[Eta][t, x, y] - \[Psi][t, x, y]^3/3 + \
\[Psi][t, x, y]) + 
                      D[\[Psi][t, x, y], x, x] + D[\[Psi][t, x, y], y, y],
  D[\[Eta][t, x, y], t] == -1/\[Gamma] (\[Psi][t, x, y] + \[Nu] + \[Beta] \
\[Eta][t, x, y]) + 
                      \[Delta] (D[\[Eta][t, x, y], x, x] + D[\[Eta][t, x, y], \
y, y])}      \
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["ric", "MR"],
  " implements random periodic initial conditions."
}], "Text"],

Cell["\<\
ric[n_, m_, seed_][x_?NumberQ, y_?NumberQ] := (SeedRandom[seed]; 
Sum[Random[Real, {-1, 1}] Cos[Random[Integer, {1, m}] 2Pi x + 2 Pi Random[]]*
                          Cos[Random[Integer, {1, m}] 2Pi y + 2 Pi Random[]],
    {j, 0, n}])\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["solveAndMakeGraphics", "MR"],
  " solves the 2 PDEs and generates 3D plots of the two components."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics1[{\[Gamma]_, \[Beta]_, \[Nu]_, \[Delta]_}, \
{{n\[Psi]_, m\[Psi]_, seed\[Psi]_}, {n\[Eta]_, m\[Eta]_, seed\[Eta]_}},\n     \
                L_, T_, ppL_, do_, ndsolveOpts___, graphicsArrayOpts___] := \n\
Module[{ndsol},\n",
  StyleBox["(* solve PDE system *)", "CodeComment"],
  "\nndsol = NDSolve[Flatten[{eqs1[{\[Gamma], \[Beta], \[Nu], \[Delta]}], \n  \
       \[Psi][0, x, y] == ric[n\[Psi], m\[Psi], seed\[Psi]][x/L, y/L], \n     \
    \[Eta][0, x, y] == ric[n\[Eta], m\[Eta], seed\[Eta]][x/L, y/L],\n         \
\[Psi][t, -L, y] == \[Psi][t, +L, y], \[Psi][t, x, -L] == \[Psi][t, x, +L],\n \
        \[Eta][t, -L, y] == \[Eta][t, +L, y], \[Eta][t, x, -L] == \[Eta][t, \
x, +L]}],\n         {\[Psi], \[Eta]}, {t, 0, T}, {x, -L, L}, {y, -L, L}, \n   \
      Sequence @@ {ndsolveOpts}, MaxSteps -> 10^5,\n         Method -> \
{\"MethodOfLines\", \"SpatialDiscretization\" -> \n                    \
{\"TensorProductGrid\", \"DifferenceOrder\" -> do, \n                    \
\"MaxPoints\" -> {ppL, ppL}, \"MinPoints\" -> {ppL, ppL}}}];\n",
  StyleBox["(* make graphic of \[Psi] and \[Eta] *)", "CodeComment"],
  "\nShow[GraphicsArray[\nPlot3D[Evaluate[ndsol[[1, #, 2]][T, x, y]], {x, -L, \
L}, {y, -L, L}, \n       PlotRange -> All, PlotPoints -> 2 ppL, Mesh -> \
False,\n       DisplayFunction -> Identity, Axes -> False,\n       Axes -> \
{False, False, True}]& /@ {1, 2}], \n       Sequence @@ {graphicsArrayOpts}, \
PlotLabel -> do]]"
}], "Input"],

Cell[TextData[{
  "Here are two examples of solutions. Because of the periodic boundary \
conditions, we use the ",
  StyleBox["Pseudospectral", "MR"],
  " option setting."
}], "Text"],

Cell["\<\
Table[solveAndMakeGraphics1[{4.9331, 2.9971, 0.014014, 1.62681}, 
                           {{20, 4, k}, {20, 4, k + 1}},
                            100, 6, 120, Pseudospectral,
                           {PrecisionGoal -> 8, AccuracyGoal -> 8}], {k, 0, \
1}]\
\>", "Input"],

Cell[TextData[{
  "The second example is a 1+1 PDE that is used for describing surface \
evolution due to step bunching [",
  
  CounterBox["BibliographyCounter", "Gillet01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gillet01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Kallunki00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kallunki00",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Krug02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Krug02",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
eq2[\[Gamma]_] := D[h[t, z], t] == -D[h[t, z], {z, 2}] + \[Gamma] \
D[h[t, z], {z, 3}] -
           D[h[t, z], {z, 4}] + D[D[h[t, z], z]^2, {z, 2}]\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["solveAndMakeGraphics", "MR"],
  " solves the differential equation with the parameter value ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  " and the initial conditions ",
  Cell[BoxData[
      FormBox[
        StyleBox["ic",
          "TI"], TraditionalForm]]],
  ". We use periodic boundary conditions."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics2[\[Gamma]_, ic_, T_, pp_, do_] := \nModule[{ndsol, \
T1},\n",
  StyleBox["(* solve PDE *)\n", "CodeComment"],
  "ndsol = NDSolve[{eq2[\[Gamma]], h[0, z] == ic[z], h[t, -Pi] == h[t, Pi]},\n\
                 h[t, z], {t, 0, T}, {z, -Pi, Pi}, \n                 \
PrecisionGoal -> 3, AccuracyGoal -> 3, \n                 MaxSteps -> 10^5, \
Method -> StiffnessSwitching,\n Method -> {\"MethodOfLines\", \
\"SpatialDiscretization\" -> {\"TensorProductGrid\",\n            \
\"DifferenceOrder\"-> do, \"MinPoints\" -> pp, \"MaxPoints\" -> pp}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "            \nShow[Graphics3D[      \nT1 = ndsol[[1, 1, 2, 0, 1, 1, 2]];  \
\nPlot3D[Evaluate[{Abs[h[t, z]] /. ndsol[[1]],\n                 \
Hue[(Arg[h[t, z]] + Pi)/(2Pi) /. ndsol[[1]]]}], \n                 {z, -Pi, \
Pi}, {t, 0, 0.9 T1}, \n                PlotPoints -> 2 pp, Mesh -> False, \
PlotRange -> All, \n                DisplayFunction -> Identity]] /.\n        \
{h_Hue :> SurfaceColor[h, h, 2.4], p_Polygon :> {EdgeForm[], p}},\n        \
DisplayFunction -> $DisplayFunction, Lighting -> True]]"
}], "Input"],

Cell["\<\
For real values of \[Gamma], the solutions smooth the original \
oscillations. Here are two examples.\
\>", "Text"],

Cell[TextData[{
  "SeedRandom[111];\nShow[GraphicsArray[\nBlock[{$DisplayFunction = \
Identity}, \nTable[solveAndMakeGraphics2[0.3, Function[z, Evaluate[\n ",
  StyleBox["(* random periodic real initial condition *)", "CodeComment"],
  "\n Sum[Random[Real, {-1, 1}] Cos[k z + 2 Pi Random[]], {k, 6}]]], \n     \
0.01, 100, \"Pseudospectral\"], {2}]]]]"
}], "Input"],

Cell["\<\
For complex values of \[Gamma], the solutions frequently also \
smooth the original oscillations. But sometimes complicated patterns and \
singularities form. Here are two examples.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* suppress error messages *)", "CodeComment"],
  " Off[NDSolve::eerr];\nShow[GraphicsArray[\nBlock[{$DisplayFunction = \
Identity}, \nFunction[seed, SeedRandom[seed]; \nsolveAndMakeGraphics2[Exp[I \
2Pi Random[]], Function[z, Evaluate[\n Sum[Random[Complex, {-1 - I, 1 + I}] \
Cos[k z + 2 Pi Random[]], \n     {k, 0, Random[Integer, {3, 6}]}]]], 0.025, \
200, \n     \"Pseudospectral\"]] /@ {2165915158297496362, \
95157975033230510106}]]]"
}], "Input"],

Cell[TextData[{
  "For exactly integrable solutions with a variety of different solutions, \
see [",
  
  CounterBox["BibliographyCounter", "Tang02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Tang02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lou02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lou02",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "We continue with a variant of the Swift\[Dash]Hohenberg equation [",
  
  CounterBox["BibliographyCounter", "Chate87"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chate87",
    ButtonStyle->"Hyperlink"],
  "]. It is a one\[Hyphen]parameter 1+1 PDE."
}], "Text"],

Cell["\<\
eq3[\[Eta]_] :=  D[\[CapitalPsi][x, t], t] + \[Eta] \
\[CapitalPsi][x, t] + D[\[CapitalPsi][x, t], {x, 2}] + 
            D[\[CapitalPsi][x, t], {x, 4}] +  2 \[CapitalPsi][x, t] D[\
\[CapitalPsi][x, t], x] == 0\
\>", "Input"],

Cell[TextData[{
  "Again, the function ",
  StyleBox["solveAndMakeGraphics3", "MR"],
  " solves the PDE and visualizes the solution as a contour plot. The last \
argument specifies the function to be displayed and the contour values."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics3[\[Eta]_, L_, T_, ppL_, do_, {F_, cls_}] := \n\
Module[{ndsol},\n",
  StyleBox["(* solve PDE *)\n", "CodeComment"],
  "ndsol = NDSolve[{eq3[\[Eta]], \[CapitalPsi][x, 0] == Sum[Random[Real, {-1, \
1}] Sin[k x/L Pi], {k, 16}],\n                     \[CapitalPsi][0, t] == \
\[CapitalPsi][L, t]},\n         {\[CapitalPsi]}, {x, 0, L}, {t, 0, T}, \
MaxSteps -> 10^5,\n         PrecisionGoal -> 3, AccuracyGoal -> 3, \n         \
Method -> {\"MethodOfLines\", Method -> StiffnessSwitching,\n                 \
   \"SpatialDiscretization\" -> \n                     \
{\"TensorProductGrid\", \"DifferenceOrder\" -> 6, \n                      \
\"MaxPoints\" -> {ppL}, \"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "            \nContourPlot[Evaluate[F[\[CapitalPsi][x, t] /. ndsol[[1]]]], \
{x, 0, L}, {t, 0, T},\n            PlotRange -> All, PlotPoints -> 300, \
ContourLines -> False,\n            Contours -> cls, ContourStyle -> \
{Thickness[0.0001]},\n            FrameTicks -> {True, True, False, False}, \n\
            ColorFunction -> (Hue[0.8 #]&)]];"
}], "Input"],

Cell[TextData[{
  "Here are the solutions for two sets of parameters ",
  Cell[BoxData[
      FormBox["\[Eta]", TraditionalForm]]],
  " and the domain size ",
  Cell[BoxData[
      FormBox["L", TraditionalForm]]],
  ". The left graphic shows the regions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[CapitalPsi]", "(", 
            RowBox[{"x", ",", "t"}], ")"}], "\[LessGreater]", "0"}], 
        TraditionalForm]]],
  " and the right graphic shows ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[LeftBracketingBar]", 
          RowBox[{"\[CapitalPsi]", "(", 
            RowBox[{"x", ",", "t"}], ")"}], "\[RightBracketingBar]"}], 
        TraditionalForm]]],
  ". The qualitative behaviors of the solutions are quite different."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity},
 {SeedRandom[888];
  solveAndMakeGraphics3[1.400, 180,  40, 2400, 6, {Identity, {0}}],
  SeedRandom[666];
  solveAndMakeGraphics3[0.087, 110, 100, 2400, 6, {Abs, 50}]}]]]\
\>", "Input"],

Cell[TextData[{
  "Next, we use a 2D version of the Swift\[Dash]Hohenberg equation ",
  "[",
  
  CounterBox["BibliographyCounter", "LeBerre02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"LeBerre02",
    ButtonStyle->"Hyperlink"],
  "],",
  " [",
  
  CounterBox["BibliographyCounter", "Golovin03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Golovin03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "eq4[\[Epsilon]_, \[Alpha]_] =  D[\[Psi][x, y, t], t] == \[Epsilon] \
\[Psi][x, y, t] - ",
  StyleBox["(* biLaplacian *)", "CodeComment"],
  "\n                 Nest[(# + D[#, x, x] + D[#, y, y])&, \[Psi][x, y, t], \
2]\n                     \[Alpha] \[Psi][x, y, t]^2 - \[Psi][x, y, t]^3;"
}], "Input"],

Cell[TextData[{
  "Starting with random initial condition in the inner part of the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]domain, yields in most cases characteristic \
labyrinth\[Hyphen]like structures."
}], "Text"],

Cell["\<\
ricIUS[k_, {x_?NumberQ, y_?NumberQ}] :=
If[Max[Abs[{x, y}]] > 1/2, 0, 
   SeedRandom[ToString[N[k (x + Sqrt[2] y)]]]; Random[Real, {-1, 1}]]\
\>", \
"Input"],

Cell[TextData[{
  "solveAndMakeGraphics4[{\[Epsilon]_, \[Alpha]_, kSeed_}, L_, T_, ppL_, do_] \
:= \nModule[{ndsol},\n",
  StyleBox["(* solve PDE *)", "CodeComment"],
  "\nndsol = NDSolve[{eq4[\[Epsilon], \[Alpha]], \[Psi][x, y, 0] == \
ricIUS[kSeed, {x/L, y/L}],\n                 \[Psi][-L, y, t] == 0, \[Psi][L, \
y, t] == 0, \n                 \[Psi][x, -L, t] == 0, \[Psi][x, L, t] == 0,\n \
                Derivative[1, 0, 0][\[Psi]][-L, y, t] == 0,\n                 \
Derivative[1, 0, 0][\[Psi]][+L, y, t] == 0,\n                 Derivative[0, \
1, 0][\[Psi]][x, -L, t] == 0,\n                 Derivative[0, 1, \
0][\[Psi]][x, +L, t] == 0},\n         {\[Psi]}, {x, -L, L}, {y, -L, L}, {t, \
T, T}, MaxSteps -> 10^5,\n         PrecisionGoal -> 2, AccuracyGoal -> 2, \n  \
       Method -> {\"MethodOfLines\", Method -> Automatic,\n                   \
 \"SpatialDiscretization\" -> \n                    {\"TensorProductGrid\", \
\"DifferenceOrder\" -> do, \n                     \"MaxPoints\" -> {ppL, \
ppL}, \"MinPoints\" -> {ppL, ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "   \nContourPlot[Evaluate[\[Psi][x, y, T] /. ndsol[[1]]], {x, -L, L}, {y, \
-L, L}, \n       PlotRange -> All, PlotPoints -> 160, Contours -> 20, \n      \
 ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]"
}], "Input"],

Cell["\<\
Here are two examples, each starting from two different random \
initial conditions. With a higher difference order or/and more points, we \
could, at the expense of a longer calculation time, obtain a more reliable \
solution. \
\>", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ 
Block[{$DisplayFunction = Identity},
{Table[solveAndMakeGraphics4[{1.154, 0.482, k}, 50, 15, 80, 2], {k, 2}],
 Table[solveAndMakeGraphics4[{1.135, -1.4, 3k}, 50, 20, 80, 2], {k, \
2}]}];\
\>", "Input"],

Cell[TextData[{
  "The next PDE is of type 2+1 and has fourth order spatial derivatives [",
  
  CounterBox["BibliographyCounter", "Golovin03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Golovin03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["\<\
eq5[\[Epsilon]_] =  \[Epsilon]^2 D[A[x, y, t], t] ==  \[Epsilon]^2 \
A[x, y, t] - 
               (A[x, y, t] + 2 (D[A[x, y, t], {x, 2}] + D[A[x, y, t], {y, \
2}]) +
                D[A[x, y, t], {x, 4}] + D[A[x, y, t], {x, 2}, {y, 2}] + 
                D[A[x, y, t], {y, 4}]) +
           1/3 (D[#[[1]], x] + D[#[[2]], y])&[
                 {D[A[x, y, t], x], D[A[x, y, t], y]}*
                  (D[A[x, y, t], x]^2 + D[A[x, y, t], y]^2)];    \
\>", \
"Input"],

Cell[TextData[{
  "We will start with random initial conditions. The function ",
  StyleBox["randomPeriodicICs", "MR"],
  " generates random initial conditions with boundary values that are \
periodic in ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "1"}], ",", 
              RowBox[{"-", "1"}]}], "]"}], "\[Times]", 
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "1"}], ",", 
              RowBox[{"-", "1"}]}], "]"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
randomPeriodicICs[k_, {x_?NumberQ, y_?NumberQ}] :=
If[x == -1. || x == 1. || y == -1. || y == 1., 1., 
   SeedRandom[ToString[N[k (E x + Pi y)]]]; Random[Real, {-1, 1}]]\
\>", \
"Input"],

Cell[TextData[{
  "Next we solve the PDE for the value ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", 
          RowBox[{"-", "0.2833"}]}], TraditionalForm]]],
  ". While a difference order 2 does not suffice to deal with the spatial \
fourth order derivative, ",
  StyleBox["NDSolve", "MR"],
  " is smart enough to use the smallest order that will work. While carrying \
out the following input, we get some ",
  StyleBox["NDSolve::eerri", "MR"],
  " messages. Taking the noncontinuous nature of the initial conditions into \
account, these messages are expected."
}], "Text"],

Cell["\<\
ndsol = 
Module[{ppL = 80, L = 40, T = 4, \[Epsilon] = -0.2833},
NDSolve[{eq5[\[Epsilon]], A[x, y, 0] == randomPeriodicICs[1, {x/L, y/L}],
                 A[-L, y, t] == A[L, y, t], A[x, -L, t] == A[x, L, t]},
         {A}, {x, -L, L}, {y, -L, L}, {t, 0, T}, MaxSteps -> 10^5,
         PrecisionGoal -> 2, AccuracyGoal -> 2, 
         Method -> {\"MethodOfLines\", Method -> StiffnessSwitching,
                    \"SpatialDiscretization\" -> 
                    {\"TensorProductGrid\", \"DifferenceOrder\" -> 2, 
                     \"MaxPoints\" -> {ppL, ppL}, \"MinPoints\" -> {ppL, \
ppL}}}]];\
\>", "Input"],

Cell[TextData[{
  "Here are a sequence of graphics that show the evolution of the system from \
the random initial values to an ordered square pattern [",
  
  CounterBox["BibliographyCounter", "Golovin03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Golovin03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "Module[{pp = 160, L = 40, T = 4},\nShow[GraphicsArray[#]]& /@ Partition[\n\
ContourPlot[Evaluate[A[x, y, #] /. ndsol[[1]]], {x, -L, L}, {y, -L, L}, \n    \
   PlotRange -> All, PlotPoints -> pp, Contours -> 20, \n       ContourLines \
-> False, DisplayFunction -> Identity,\n       FrameTicks -> False, \
ColorFunction -> (Hue[0.8 #]&)]& /@\n       ",
  StyleBox["(* list of times for frames *)", "CodeComment"],
  "\n       Prepend[T Table[2^-k, {k, 7, 0, -1}], 0], 3]]"
}], "Input"],

Cell[TextData[{
  "Our next example is the Meinhardt equation set, a coupled system of three \
nonlinear reaction diffusion equations [",
  
  CounterBox["BibliographyCounter", "Bode01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bode01",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Scott03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Scott03",
    ButtonStyle->"Hyperlink"],
  "]",
  " that are used to model animal coats [",
  
  CounterBox["BibliographyCounter", "Koch94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Koch94",
    ButtonStyle->"Hyperlink"],
  "]. The system has twelve numerical parameters."
}], "Text"],

Cell["\<\
eqs6[{{Da_, \[Rho]a_, \[Kappa]a_, Ds_, \[Rho]s_, \[Mu]s_, \
\[Sigma]s_, \[Rho]Y_, \[Mu]Y_, \[Sigma]Y_}, {\[Kappa]s_, \[Kappa]Y_}}] = 
{D[a[x, y, t], t] == Da (D[a[x, y, t], x, x] + D[a[x, y, t], y, y]) +
                     \[Rho]a (a[x, y, t]^2 s[x, y, t]/(1 + \[Kappa]a a[x, y, \
t]^2) -
                     a[x, y, t]),
 D[s[x, y, t], t] == Ds (D[s[x, y, t], x, x] + D[s[x, y, t], y, y]) +
                     \[Sigma]s/(1 + \[Kappa]s Y[x, y, t]) -  \[Mu]s s[x, y, \
t] - 
                     \[Rho]s a[x, y, t]^2 s[x, y, t]/(1 + \[Kappa]a a[x, y, \
t]^2),
 D[Y[x, y, t], t] == \[Rho]Y Y[x, y, t]^2/(1 + \[Kappa]Y Y[x, y, t]^2) - 
                     \[Mu]Y Y[x, y, t] + \[Sigma]Y a[x, y, t]};               \
      \
\>", "Input"],

Cell["\<\
This time we use initial conditions that are constant for two of \
the dependent variables and mostly constant for the third. The third variable \
has a nonvanishing value only on a few random points.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* some nonvanishing point values; boundary value is 0 *)", 
    "CodeComment"],
  "\na0IC[{A_, o_, ppL_}, {x_?NumberQ, y_?NumberQ}] := \nIf[Max[Abs[{x, y}]] \
== 1., 0, If[Random[] < o 1/(ppL - 2)^2, A, 0]]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["solveAndMakeGraphics6", "MR"],
  " solves the Meinhardt system and generates a contour plot of the last \
variable."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics6[{T_, L_}, pdePars_, {A_, o_}, ppL_, do_] :=\n\
Module[{ndsol},\n",
  StyleBox["(* solve pde system *)", "CodeComment"],
  "\nndsol = NDSolve[{eqs6[pdePars], a[x, y, 0] == a0IC[{A, o, ppL}, {x, \
y}/L], \n                 s[x, y, 0] == 0, Y[x, y, 0] == 0,\n                 \
a[-L, y, t] == a[L,  y, t], a[x, -L, t] == a[x, L, t], \n                 \
s[-L, y, t] == s[L,  y, t], s[x, -L, t] == s[x, L, t], \n                 \
Y[-L, y, t] == Y[L,  y, t], Y[x, -L, t] == Y[x, L, t]},\n         {a, s, Y}, \
{x, -L, L}, {y, -L, L}, {t, T, T}, MaxSteps -> 10^5,\n         PrecisionGoal \
-> 2, AccuracyGoal -> 2, \n         Method -> {\"MethodOfLines\", Method -> \
BDF, \"SpatialDiscretization\" -> \n                    \
{\"TensorProductGrid\", \"DifferenceOrder\" -> do, \n                     \
\"MaxPoints\" -> ppL {1, 1}, \"MinPoints\" -> ppL {1, 1}}}]; \n",
  StyleBox["(* make contour plot of Y[x, y]^2 *)", "CodeComment"],
  "\nContourPlot[Evaluate[Abs[Y[x, y, T]]^2 /. ndsol[[1]]], {x, -L, L}, {y, \
-L, L}, \n       PlotRange -> All, ContourLines -> False, FrameTicks -> \
False, \n       PlotPoints -> 120, Contours -> 30, ColorFunction -> (Hue[0.8 \
#]&)]]"
}], "Input"],

Cell["\<\
Here are three examples. The first two show a Voronoi diagram\
\[Hyphen]like structure and the third shows a mixture between spots and \
stripes. We use 80 points in each spatial direction. While this suffices to \
obtain a qualitatively correct solution, it does not suffice to obtain a \
quantitatively correct one within the specified accuracy and precision goals. \
For the price of larger calculation time, one could calculate a better \
solution.\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity}, \n     \
(SeedRandom[111]; Print[#];\n      solveAndMakeGraphics6[#1, #3, {#2, 20}, \
80, 1])& @@@ \n ",
  StyleBox["(* parameter data found by searching *)", "CodeComment"],
  "\n {{{648, 66}, 5.58964, \n   {{0.015803, 0.070456, 0.003254, 0.826182, \
0.001030, 0.006167, \n     0.088085, 0.351054, 0.003161, 0.010544}, {2.07226, \
3.111023}}},\n  {{641, 57}, 9.0855, \n   {{0.065498, 0.247513, 0.002189, \
0.391285, 0.070575, 0.005826, \n     0.458718, 0.189077, 0.001017, 0.008231}, \
{2.38141, 0.235835}}},\n  {{437, 20}, 9.85503, \n   {{0.001890, 0.039474, \
0.002056, 0.887802, 0.003273, 0.006249, \n     0.537041, 0.006767, 0.115995, \
0.140463}, {3.04301, 1.058715}}}}]]]"
}], "Input"],

Cell["\<\
A rich source of complicated patterns are the cubic, quintic, \
\[Ellipsis] complex Ginzburg\[Dash]Landau equations. Here is a generalized \
relative of it.\
\>", "Text"],

Cell["\<\
eq7[d0_, cList_] := 
D[A[x, t], t] == d0 D[A[x, t], x, x] +
                 A[x, t] (Abs[A[x, t]]^Range[0, Length[cList] - \
1]).cList\
\>", "Input"],

Cell[TextData[{
  "We start with a localized smooth initial condition. The function ",
  StyleBox["solveAndMakeGraphics7", "MR"],
  " solves the PDE and generates a contour plot of the absolute value of its \
solution."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics7[{d0_, cList_}, ppL_, do_] := \nModule[{T = 80, L = \
60, ndsol, arg = If[# == 0., 0, Arg[#]]&,\n        cOpts = \
Sequence[PlotPoints -> 200, Contours -> 30, \n        ContourLines -> False, \
FrameTicks -> False]},\n ",
  StyleBox["(* solve PDE *)", "CodeComment"],
  " ndsol = \n NDSolve[{eq7[d0, cList], ",
  StyleBox["(* localized initial condition *)", "CodeComment"],
  "\n          A[x, 0] == If[Abs[x/L] < 1/2, Cos[Pi x/L]^2, 0],  \n          \
A[-L, t] == A[L,  t]}, {A}, {x, -L, L}, {t, 0, T}, \n          MaxSteps -> \
10^5, PrecisionGoal -> 3, AccuracyGoal -> 3, \n         Method -> \
{\"MethodOfLines\", Method -> StiffnessSwitching,\n                    \
\"SpatialDiscretization\" -> \n                    {\"TensorProductGrid\", \
\"DifferenceOrder\" -> do, \n                     \"MaxPoints\" -> {ppL}, \
\"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "\nBlock[{$DisplayFunction = Identity},\n{",
  StyleBox["(* absolute value *)", "CodeComment"],
  "\n ContourPlot[Evaluate[Abs[A[x, t] /. ndsol[[1]]]], {x, -L, L}, {t, 0, \
T}, \n            Evaluate[cOpts], ColorFunction -> (Hue[0.8 #]&),\n          \
  PlotRange -> All],\n ",
  StyleBox["(* argument *)", "CodeComment"],
  "\n ContourPlot[Evaluate[arg[A[x, t] /. ndsol[[1]]]], {x, -L, L}, {t, 0, \
T}, \n            Evaluate[cOpts], ColorFunction -> Hue,\n            \
PlotRange -> {-Pi, Pi}]}]]"
}], "Input"],

Cell["\<\
Here are some of the resulting solutions. We show the absolute \
value and the argument for six sets of parameters. Once more we use a \
moderate number of discretization points and the lowest order to calculate a \
qualitatively correct solution. Using more points (and/or other methods) will \
give quantitatively more reliable solutions.\
\>", "Text"],

Cell[TextData[{
  "Off[NDSolve::eerr]; \n\nShow[GraphicsArray[Transpose[#]]]& /@ \n\
Partition[solveAndMakeGraphics7[#, 200, 1]& /@ \n",
  StyleBox["(* parameters found by random searching *)", "CodeComment"],
  " {\n{ 0.562585, { 0.472726 + 0.331368 I,  0.801779 - 2.480545 I,  0.474796 \
- \n              0.776168 I, -2.519074 - 0.952473 I, -1.014533 + 0.210578 \
I}},\n{ 1.112343, { 0.333686 - 0.048153 I,  0.051441 + 0.346931 I,  0.262625 \
+ \n              0.254911 I,  0.059902 + 0.067229 I, -0.125889 + 0.072792 \
I}},\n{-0.457228, { 0.064266 + 0.219516 I,  0.103752 + 0.492474 I,  0.042513 \
- \n              0.062272 I, -0.190156 - 0.219106 I, -0.182677 - 0.551021 \
I}},    \n{ 5.078614, {-0.043256 + 0.262005 I,  0.269991 + 0.278785 I,  \
0.371664 - \n              0.118355 I, -0.573401 + 0.766421 I,  0.132533 + \
0.425168 I}},  \n{ 0.896841, {-0.004116 - 0.029930 I,  0.289541 - 0.120667 I, \
-0.230067 - \n              0.511332 I,  2.387745 - 0.110776 I, -1.770957 - \
1.860567 I}},\n{ 0.613237, { 0.188025 + 1.353056 I, -0.093262 - 1.959692 I,  \
0.977863 - \n              1.689762 I,  1.183884 + 0.821903 I, -2.001599 + \
0.123309 I}}}, 3]\n                               \nOn[NDSolve::eerr];        \
                "
}], "Input"],

Cell[TextData[{
  "Our next example is a system of two nonlinear 1+1D PDEs [",
  
  CounterBox["BibliographyCounter", "Reynolds94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Reynolds94",
    ButtonStyle->"Hyperlink"],
  "]. "
}], "Text"],

Cell["\<\
eq8[A_, B_, \[Delta]_] = 
{D[u[x, t], t] == D[u[x, t], x, x] - u[x, t] v[x, t]^2 + A (1 - u[x, t]),
 D[v[x, t], t] == \[Delta]^2 D[v[x, t], x, x] + u[x, t] v[x, t]^2 - B v[x, \
t]};                     \
\>", "Input"],

Cell["\<\
This time we start with a smooth localized bump in the center of \
the integration domain.\
\>", "Text"],

Cell["\<\
startBump[x_, \[Alpha]_, L_] := If[Abs[x/L] < 1/\[Alpha], Cos[Pi/2 \
(x/L)/(1/\[Alpha])]^3, 0]\
\>", "Input"],

Cell[TextData[{
  "Like always, the function ",
  StyleBox["solveAndMakeGraphics8", "MR"],
  " solves the PDEs and generates a graphic of the solution, concretely, a \
contour plot of the second component."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphics8[{{A_, B_, \[Delta]_}, {L_, T_}, \[Alpha]_, do_}, \
ppL_] := \nModule[{ndsol}, \n",
  StyleBox["(* solve PDEs *)", "CodeComment"],
  "\nndsol = NDSolve[{eq8[A, B, \[Delta]], \n                 v[x, 0] == \
startBump[x, \[Alpha], L], u[x, 0] == 1 - startBump[x, \[Alpha], L], \n       \
          Derivative[1, 0][u][-L, t] == 0, Derivative[1, 0][u][+L, t] == 0,\n \
                Derivative[1, 0][v][-L, t] == 0, Derivative[1, 0][v][+L, t] \
== 0},\n         {u, v}, {x, -L, L}, {t, 0, T}, \n         MaxSteps -> 10^5, \
PrecisionGoal -> 2, AccuracyGoal -> 2, \n         Method -> \
{\"MethodOfLines\", Method -> BDF,\n                    \
\"SpatialDiscretization\" -> \n                    {\"TensorProductGrid\", \
\"DifferenceOrder\" -> do, \n                     \"MaxPoints\" -> {ppL}, \
\"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "\nContourPlot[Evaluate[v[x, t] /. ndsol[[1]]], {x, -L, L}, {t, 0, T}, \n   \
    PlotRange -> All, PlotPoints -> 400, Contours -> 20, \n       \
ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]"
}], "Input"],

Cell[TextData[{
  "Here are three examples. The special property of these PDEs is that the \
localized initial structure repeatedly copies itself [",
  
  CounterBox["BibliographyCounter", "Reynolds94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Reynolds94",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Crampin01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Crampin01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Reynolds97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Reynolds97",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Parekh95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Parekh95",
    ButtonStyle->"Hyperlink"],
  "]",
  ". (For a variety of examples of such structure in expanding domains ",
  Cell[BoxData[
      FormBox[
        RowBox[{"L", "=", 
          RowBox[{"L", "(", "t", ")"}]}], TraditionalForm]]],
  ", see [",
  
  CounterBox["BibliographyCounter", "Crampin99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Crampin99",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Crampin02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Crampin02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Crampin02b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Crampin02b",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n      \
solveAndMakeGraphics8[#, 2400]& /@ \n       ",
  StyleBox["(* three sets of parameters *)", "CodeComment"],
  "\n       {{{0.011051, 0.021635, 0.026161}, { 8, 4000}, 16, 1},\n        \
{{0.373018, 0.095230, 0.003531}, { 5, 2000}, 29, 1},\n        {{0.591115, \
0.273925, 0.061422}, {10,  300}, 27, 1}}]]]"
}], "Input"],

Cell[TextData[{
  "We continue with a system of two coupled nonlinear PDEs in 2+1 dimensions \
[",
  
  CounterBox["BibliographyCounter", "Muratov01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Muratov01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Muratov96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Muratov96",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["\<\
eqs9[\[Epsilon]_, \[Alpha]_, A_] = 
{D[\[Theta][x, y, t], t] == (\[Epsilon]^2 (D[\[Theta][x, y, t], x, x] + D[\
\[Theta][x, y, t], y, y]) -
                      \[Theta][x, y, t]^3 + \[Theta][x, y, t] + \[Eta][x, y, \
t])/\[Alpha],
 D[\[Eta][x, y, t], t] == (D[\[Eta][x, y, t], x, x] + D[\[Eta][x, y, t], y, \
y]) -
                      \[Theta][x, y, t] - \[Eta][x, y, t] + A};               \
     \
\>", "Input"],

Cell["\<\
This time, we start with a ring\[Hyphen]shaped initial condition.\
\
\>", "Text"],

Cell[TextData[{
  "\[Theta]0[x_, y_, \[Theta]00_, L_] := ",
  StyleBox["(* ring-shaped elongation *)", "CodeComment"],
  "\nWith[{\[Gamma] = 1/8}, If[L/2 - \[Gamma] L <= Sqrt[x^2 + y^2] <= L/2 + \
\[Gamma] L, \n                   Sin[3 Pi x/L] Cos[Sqrt[x^2 + y^2]/L/\[Gamma] \
Pi/2]^2, 0]]"
}], "Input"],

Cell[TextData[{
  "solveAndMakeGraphics9[{{\[Epsilon]_, \[Alpha]_, A_}, {L_, T_}, \
\[Theta]00_}, do_, ppL_] := \nModule[{ndsol},\n ",
  StyleBox["(* solve PDEs *)", "CodeComment"],
  "\n ndsol = NDSolve[{eqs9[\[Epsilon], \[Alpha], A], \n                 \
\[Theta][x, y, 0] == \[Theta]0[x, y, \[Theta]00, L], \[Eta][x, y, 0] == 0,\n  \
               \[Theta][-L, y, t] == 0, \[Theta][L, y, t] == 0, \n            \
     \[Theta][x, -L, t] == 0, \[Theta][x, L, t] == 0, \n                 \
\[Eta][-L, y, t] == 0, \[Eta][L, y, t] == 0, \n                 \[Eta][x, -L, \
t] == 0, \[Eta][x, L, t] == 0},\n         {\[Theta], \[Eta]}, {x, -L, L}, {y, \
-L, L}, {t, T, T}, MaxSteps -> 10^5,\n         PrecisionGoal -> 2, \
AccuracyGoal -> 2, \n         Method -> {\"MethodOfLines\", Method -> \
Automatic,\n                    \"SpatialDiscretization\" -> \n               \
     {\"TensorProductGrid\", \"DifferenceOrder\" -> do, \n                    \
 \"MaxPoints\" -> {ppL, ppL}, \"MinPoints\" -> {ppL, ppL}}}];\n ",
  StyleBox["(* visualize \[Eta] part of the solution *)", "CodeComment"],
  "\n ContourPlot[Evaluate[Abs[\[Eta][x, y, T] /. ndsol[[1]]]], {x, -L, L}, \
{y, -L, L}, \n       PlotRange -> All, PlotPoints -> 80, Contours -> 20, \n   \
    ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]"
}], "Input"],

Cell["\<\
For many parameter values the initial ring disintegrates into \
closed, deformed pieces. Here are four examples.\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[#]]& /@ \nBlock[{$DisplayFunction = Identity}, \n \
Partition[solveAndMakeGraphics9[#, 8, 120]& /@ \n   ",
  StyleBox["(* four sets of parameter values *)", "CodeComment"],
  "\n   {{{ 0.500521, 0.798381, -0.0086344}, { 22, 68}, -1.666285},\n    \
{{-0.120092, 0.084926,  0.2385211}, { 13, 77}, -0.878614},\n    {{ 0.503609, \
1.048002, -0.0223839}, { 25, 42}, -1.632547},\n    {{-1.138091, 0.023999, \
-0.0019694}, {173, 16} ,  1.704992}}, 2]]"
}], "Input"],

Cell[TextData[{
  "We continue with a slightly nonlinear wave equation that models two \
different media [",
  
  CounterBox["BibliographyCounter", "Caputo01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Caputo01",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Huang04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Huang04",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* position-dependent c and \[Omega] *)", "CodeComment"],
  "\neq10[{c1_, c2_}, {\[Omega]1_, \[Omega]2_}] =\nD[u[x, t], t, t] - If[x > \
0, c1^2, c2^2] D[u[x, t], x, x] +\n                   If[x > 0, \[Omega]1^2 \
Tan[u[x, t]], \[Omega]2^2 Sin[u[x, t]]] == 0;"
}], "Input"],

Cell[TextData[{
  StyleBox["(* two localized initial packets *)", "CodeComment"],
  "\nstartPackets[{\[ScriptA]_, \[ScriptB]_}, x_] := \n Which[Abs[x - 1/3] <= \
\[ScriptB], \[ScriptA] Cos[Pi/2 (x - 1/3)/\[ScriptB]]^2,\n       Abs[x + 1/3] \
<= \[ScriptB], \[ScriptA] Cos[Pi/2 (x + 1/3)/\[ScriptB]]^2,\n       True, 0]; \
                                 "
}], "Input"],

Cell[TextData[{
  "solveAndMakeGraphicsTwoMediaWaveEquation[{{{c1_, c2_}, {\[Omega]1_, \
\[Omega]2_}}, \n                                 {\[ScriptA]_, \[ScriptB]_}, \
{L_, T_}, g_, do_}, ppL_] := \nModule[{ndsol}, \n",
  StyleBox["(* solve PDEs *)", "CodeComment"],
  "\nndsol = NDSolve[{eq10[{c1, c2}, {\[Omega]1, \[Omega]2}], \n              \
   u[x, 0] == startPackets[{\[ScriptA], \[ScriptB]}, x/L], \n                 \
Derivative[0, 1][u][x, 0] == 0, \n                 u[ L, t] == 0, u[-L, t] == \
0},\n         {u}, {x, -L, L}, {t, 0, T}, \n         MaxSteps -> 10^5, \
PrecisionGoal -> g, AccuracyGoal -> g, \n         Method -> \
{\"MethodOfLines\", Method -> Automatic,\n                    \
\"SpatialDiscretization\" -> \n                    {\"TensorProductGrid\", \
\"DifferenceOrder\" -> do, \n                     \"MaxPoints\" -> {ppL}, \
\"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "\nContourPlot[Evaluate[Abs[u[x, t]] /. ndsol[[1]]], {x, -L, L}, {t, 0, T}, \
\n       PlotRange -> All, PlotPoints -> 240, Contours -> 20, \n       \
ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]"
}], "Input"],

Cell[TextData[{
  "We clearly see reflections of the two spreading packets at the interface \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "=", "0"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n\
solveAndMakeGraphicsTwoMediaWaveEquation[\n                    {#1, #2, {10, \
12}, 3, Pseudospectral}, 81]& @@@\n  ",
  StyleBox["(* two parameter sets *)  ", "CodeComment"],
  "                \n  {{{{0.51314, 0.42573}, {1.5459, 0.0775}}, { 1.9945, \
0.11295}},\n   {{{0.09219, 0.38770}, {1.3690, 1.8004}}, {-0.6500, \
0.082157}}}]]] "
}], "Input"],

Cell[TextData[{
  "Our next example is the classical scalar wave equation with a piecewise \
constant speed of light. But now we consider the 2+1 case. The two materials \
are located above and below the line ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "\[GreaterLess]", "0"}], TraditionalForm]]],
  ". "
}], "Text"],

Cell[TextData[{
  StyleBox["(* 2D wave equation with position-dependent ", "CodeComment"],
  StyleBox["c *)", "CodeComment"],
  "\neq11[c_] = If[z > 0, 1, 1/c^2] D[u[x, z, t], t, t] == \n               \
D[u[x, z, t], x, x] + D[u[x, z, t], z, z];"
}], "Input"],

Cell[TextData[{
  "We start with a simple localized wave packet [",
  
  CounterBox["BibliographyCounter", "Bosanac83"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bosanac83",
    ButtonStyle->"Hyperlink"],
  "]. (For other packets, see [",
  
  CounterBox["BibliographyCounter", "Porras98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Porras98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Porras00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Porras00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Ciattoni04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ciattoni04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Ciattoni04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ciattoni04",
    ButtonStyle->"Hyperlink"],
  "]",
  ".) To avoid the use of complex arithmetic, instead of a factor ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{"i", " ", 
            RowBox[{
              StyleBox["k",
                FontWeight->"Bold",
                FontSlant->"Plain"], ".", 
              StyleBox["r",
                FontWeight->"Bold",
                FontSlant->"Plain"]}]}], ")"}], TraditionalForm]]],
  ", we will use two packets of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cos", "(", 
          RowBox[{
            StyleBox["k",
              FontWeight->"Bold",
              FontSlant->"Plain"], ".", 
            StyleBox["r",
              FontWeight->"Bold",
              FontSlant->"Plain"]}], ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sin", "(", 
          RowBox[{
            StyleBox["k",
              FontWeight->"Bold",
              FontSlant->"Plain"], ".", 
            StyleBox["r",
              FontWeight->"Bold",
              FontSlant->"Plain"]}], ")"}], TraditionalForm]]],
  " and add their contributions at the end. We then display the square of the \
absolute value of the field."
}], "Text"],

Cell[TextData[{
  StyleBox["(* field and derivative at t == 0 *)", "CodeComment"],
  "\nstartPacket2D[{\[Sigma]l_, \[Sigma]r_, \[Alpha]_, \[ScriptL]_, k0_, \
\[Beta]_}, {x_, z_}] := \nModule[{x0 = \[ScriptL] Cos[Pi - \[Alpha]], z0 = \
\[ScriptL] Sin[Pi - \[Alpha]], \n       \[ScriptK]0 = k0 {Cos[-\[Alpha]], \
Sin[-\[Alpha]]}, \n       \[Xi]D = {Cos[-\[Alpha]], -Sin[-\[Alpha]]}, \[Eta]D \
= {Sin[-\[Alpha]], Cos[-\[Alpha]]}, \[Xi]d, \[Eta]d},\n       \[Xi]d = ({x, \
z} - {x0, z0}).\[Xi]D; \[Eta]d = ({x, z} - {x0, z0}).\[Eta]D;\n      ",
  StyleBox["(* elongated moving Gaussian packet *)", "CodeComment"],
  "\n      Exp[-\[Xi]d^2/\[Sigma]r^2 - \[Eta]d^2/\[Sigma]l^2] \
Cos[\[ScriptK]0.{x, z} + \[Beta]]]   \n      \nstartPacket2DDerivative[{\
\[Sigma]l_, \[Sigma]r_, \[Alpha]_, \[ScriptL]_, k0_, \[Beta]_}, {x_, z_}] := \
\nModule[{t}, D[startPacket2D[{\[Sigma]l, \[Sigma]r, \[Alpha], \[ScriptL], \
k0, \[Beta]}, \n                     {x - Cos[\[Alpha]] t, z + Sin[\[Alpha]] \
t}], t] /. t -> 0]"
}], "Input"],

Cell[TextData[{
  "This time, we repeatedly solve the wave equation over a certain time \
interval and create a visual snapshot of the state and the end of this time \
interval. This method allows to follow the wave packet for a longer time \
without saving the potentially quite large interpolating function generated \
by ",
  StyleBox["NDSolve", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "solveAndMakeGraphicsListTwoMediaWaveEquation2D[\n     {c_, {\[Sigma]l_, \
\[Sigma]r_, \[Alpha]_, \[ScriptL]_, k0_}, g_, do_}, {L_, T_}, ppL_, frames_] \
:= \nModule[{\[CapitalDelta]T = T/frames, state, pps, xy0 = L {Cos[Pi - \
\[Alpha]], Sin[Pi - \[Alpha]]},\n        stateC, stateS}, \n",
  StyleBox["(* set up PDE;\n   use two initial conditions with shifted \
modulation to model\n   a complex field  *)", "CodeComment"],
  "\n{stateC, stateS} = NDSolve`ProcessEquations[{eq11[c], \n                 \
u[x, z, 0] == startPacket2D[{\[Sigma]l, \[Sigma]r, \[Alpha], \[ScriptL], k0, \
#}, {x, z}], \n                 Derivative[0, 0, 1][u][x, z, 0] == \n         \
        startPacket2DDerivative[{\[Sigma]l, \[Sigma]r, \[Alpha], \[ScriptL], \
k0, #}, {x, z}], \n                 u[ L, z, t] == 0, u[-L, z, t] == 0,\n     \
            u[x,  L, t] == 0, u[x, -L, t] == 0},\n         {u}, {x, -L, L}, \
{z, -L, L}, t, \n         MaxSteps -> 10^5, PrecisionGoal -> g, AccuracyGoal \
-> g, \n         Method -> {\"MethodOfLines\", Method -> Automatic,\n         \
           \"SpatialDiscretization\" -> \n                    \
{\"TensorProductGrid\", \"DifferenceOrder\" -> do, \n                     \
\"MaxPoints\" -> {ppL, ppL}, \n                     \"MinPoints\" -> {ppL, \
ppL}}}][[1]]& /@ {0, Pi/2};\n",
  StyleBox["(* propagate solution in time and make visualizations *)", 
    "CodeComment"],
  "\nTable[",
  StyleBox["(* solve wave equation in time steps \[CapitalDelta]T *)", 
    "CodeComment"],
  "\n   NDSolve`Iterate[stateC, j \[CapitalDelta]T]; NDSolve`Iterate[stateS, \
j \[CapitalDelta]T]; \n   ",
  StyleBox["(* form current solution *)", "CodeComment"],
  "\n   {ppsC, ppsS} = NDSolve`ProcessSolutions[#, \"Forward\"]& /@ {stateC, \
stateS};   \n   ",
  StyleBox["(* visualize solution *)\n   ", "CodeComment"],
  "Show[Graphics[ContourPlot[Evaluate[Abs[ppsC[[1, 2]]]^2] + Abs[ppsS[[1, \
2]]]^2, \n                 {x, -L, L}, {z, -L, L}, Contours -> 20, \n         \
        ContourLines -> False, DisplayFunction -> Identity,\n                 \
FrameTicks -> False, ColorFunction -> (GrayLevel[1 - #]&),\n                 \
PlotRange -> All, PlotPoints -> 160, Epilog -> \n       ",
  StyleBox["(* lines along the reflected and refracted rays *)", 
    "CodeComment"],
  "\n       {{Hue[0], Thickness[0.008], Line[{{-L, 0}, {L, 0}}]},\n        \
{GrayLevel[0], Thickness[0.004], \n         Line[2 {xy0, {0, 0}, L {Cos[\
\[Alpha]], Sin[\[Alpha]]}}]}}]],\n            PlotRange -> L {{-1, 1}, {-1, \
1}}, Frame -> True], {j, frames}]]"
}], "Input"],

Cell[TextData[{
  "The following two rows of graphics show the temporal evolution of two \
packets impinging on the surface under different angles. The material on the \
left has a smaller phase velocity than the material on the right hand side. \
In the left row, one sees that a large fraction of the initial wave packet \
gets reflected. The two black lines represent the classical reflection law \
for the center of the wave packet. For larger times, the reflected wave \
packet is clearly to right of the ray prediction (analog to the Goos\[Dash]H\
\[ADoubleDot]nchen effect in optics [",
  
  CounterBox["BibliographyCounter", "Goos47"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Goos47",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Goos49"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Goos49",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lai00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lai00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Ignatovich04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ignatovich04",
    ButtonStyle->"Hyperlink"],
  "])."
}], "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Transpose[
 solveAndMakeGraphicsListTwoMediaWaveEquation2D @@@
     {{{1/Sqrt[4], {1/2, 1/2, Pi/8, 3, 12}, 3, 1}, {4, 7}, 140, 5},
      {{1/Sqrt[2], {1/2, 1/2, Pi/3, 3, 16}, 3, 1}, {4, 7}, 140, 5}}]\
\>", \
"Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_WavepacketReflection.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel",
  GeneratedCell->False],

Cell["\<\
Show[GraphicsArray[#]]& /@ Transpose[
 solveAndMakeGraphicsListTwoMediaWaveEquation2D @@@
     {{{1/Sqrt[4], {1/2, 1/2, Pi/8, 3, 12}, 3, 1}, {4, 7}, 140, 24},
      {{1/Sqrt[2], {1/2, 1/2, Pi/3, 3, 16}, 3, 1}, {4, 7}, 140, 24}}]\
\>", \
"Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "For refraction on negative ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " materials, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Ziolkowski01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ziolkowski01",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Lu04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lu04",
    ButtonStyle->"Hyperlink"],
  "]. For a nonlinear reaction\[Hyphen]diffusion system with two different \
media, see [",
  
  CounterBox["BibliographyCounter", "Gutman04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gutman04",
    ButtonStyle->"Hyperlink"],
  "]. "
}], "Text"],

Cell[TextData[{
  "We continue with the local induction approximation PDE for vortices ",
  "[",
  
  CounterBox["BibliographyCounter", "Betchov65"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Betchov65",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Cieslinski86"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cieslinski86",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Gutierrez04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gutierrez04",
    ButtonStyle->"Hyperlink"],
  "]. Given a curve ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["X",
            FontWeight->"Bold",
            FontSlant->"Plain"], "(", "s", ")"}], TraditionalForm]]],
  ", where ",
  Cell[BoxData[
      FormBox["s", TraditionalForm]]],
  " is the arc length, the time evolution of the curve is assumed to be"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        FractionBox[
          RowBox[{"\[PartialD]", 
            RowBox[{
              StyleBox["X",
                FontWeight->"Bold",
                FontSlant->"Plain"], "(", 
              RowBox[{"t", ",", "s"}], ")"}]}], 
          RowBox[{"\[PartialD]", "t"}]], "=", 
        RowBox[{
          RowBox[{
            RowBox[{
              SubscriptBox[
                StyleBox["X",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], "s"], "(", 
              RowBox[{"t", ",", "s"}], ")"}], "\[Cross]", 
            RowBox[{
              SubscriptBox[
                StyleBox["X",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], 
                RowBox[{"s", " ", "s"}]], "(", 
              RowBox[{"t", ",", "s"}], ")"}]}], "."}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell["\<\
The length of a curve stays constant under this \
time\[Hyphen]evolution.
Using any parametrization instead of the arc length, we obtain the similar \
PDE\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        FractionBox[
          RowBox[{"\[PartialD]", 
            RowBox[{
              StyleBox["X",
                FontWeight->"Bold",
                FontSlant->"Plain"], "(", 
              RowBox[{"t", ",", "\[Sigma]"}], ")"}]}], 
          RowBox[{"\[PartialD]", "t"}]], "=", 
        RowBox[{
          FractionBox[
            RowBox[{
              RowBox[{
                SubscriptBox[
                  StyleBox["X",
                    FontWeight->"Bold",
                    FontSlant->"Plain"], "\[Sigma]"], "(", 
                RowBox[{"t", ",", "\[Sigma]"}], ")"}], "\[Cross]", 
              RowBox[{
                SubscriptBox[
                  StyleBox["X",
                    FontWeight->"Bold",
                    FontSlant->"Plain"], 
                  RowBox[{"\[Sigma]", " ", "\[Sigma]"}]], "(", 
                RowBox[{"t", ",", "\[Sigma]"}], ")"}]}], 
            SqrtBox[
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{
                    RowBox[{
                      SubscriptBox[
                        StyleBox["X",
                          FontWeight->"Bold",
                          FontSlant->"Plain"], "\[Sigma]"], "(", 
                      RowBox[{"t", ",", "\[Sigma]"}], ")"}], ".", 
                    RowBox[{
                      SubscriptBox[
                        StyleBox["X",
                          FontWeight->"Bold",
                          FontSlant->"Plain"], "\[Sigma]"], "(", 
                      RowBox[{"t", ",", "\[Sigma]"}], ")"}]}], ")"}], "3"]]], 
          "."}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "We define the function ",
  StyleBox["solveAndMakeGraphicsLIAEquation", "MR"],
  " to solve the solution numerically and to display the time\[Hyphen]evolved \
curve as a surface sept out."
}], "Text"],

Cell["\<\
X[t_, \[Sigma]_] := {x[t, \[Sigma]], y[t, \[Sigma]], z[t, \
\[Sigma]]};\
\>", "Input"],

Cell["\<\
eq12[\[Alpha]_, {t_, \[Sigma]_}] = 
Thread @ (D[X[t, \[Sigma]], t] == \[Alpha] Together @
          Cross[1/Sqrt[D[X[t, \[Sigma]], \[Sigma]].D[X[t, \[Sigma]], \
\[Sigma]]] D[X[t, \[Sigma]], \[Sigma]],
                1/Sqrt[D[X[t, \[Sigma]], \[Sigma]].D[X[t, \[Sigma]], \
\[Sigma]]]*
                 D[1/Sqrt[D[X[t, \[Sigma]], \[Sigma]].D[X[t, \[Sigma]], \
\[Sigma]]] D[X[t, \[Sigma]], \[Sigma]], \[Sigma]]]);\
\>", "Input"],

Cell[TextData[{
  "solveAndMakeGraphicsLIAEquation[{curve_, \[Sigma]_}, \[Alpha]_, ppd_, T_, \
ppg_, opts___] :=\nModule[{ndsol, \[CapitalTau]},\n   ndsol = ",
  StyleBox["(* solve local induction approximation PDE *)", "CodeComment"],
  "\n    NDSolve[Flatten[{eq12[1, {t, \[Sigma]}], Thread[X[0, \[Sigma]] == \
curve],\n                                      Thread[X[t, 0] == X[t, \
2Pi]]}],\n         {x, y, z}, {t, 0, T}, {\[Sigma], 0, 2Pi},\n         \
MaxSteps -> 10^5, PrecisionGoal -> 4,\n         ",
  StyleBox["(* use \"Pseudospectral\" because of periodic boundary conditions \
*)", "CodeComment"],
  "\n         Method -> {\"MethodOfLines\", \"SpatialDiscretization\" -> \n   \
                 {\"TensorProductGrid\", \"DifferenceOrder\" -> \
\"Pseudospectral\", \n                    \"MaxPoints\" -> {ppd}, \"MinPoints\
\" -> {ppd}}}];\n   \[CapitalTau] = ndsol[[1, 1, 2, 1, 1, 2]]; \n   ",
  StyleBox["(* visualize evolved curve as a parametrized surface *)", 
    "CodeComment"],
  "\n   Show[ParametricPlot3D[Evaluate[Append[X[t, \[Sigma]] /. ndsol[[1]], \n\
                               {EdgeForm[Thickness[0.001]],\n                 \
               SurfaceColor[Hue[0.8 t/\[CapitalTau]], Hue[0.8 \
t/\[CapitalTau]], 2]}]],\n                 {\[Sigma], 0, 2Pi}, {t, 0, \
\[CapitalTau]}, PlotPoints -> ppg,\n                 DisplayFunction -> \
Identity] /. Polygon[l_] :> \n                 Polygon[Plus @@@ \
Partition[Append[l, First[l]], 2, 1]/2],\n     opts, DisplayFunction -> \
$DisplayFunction, \n     PlotRange -> All, Axes -> False, Boxed -> False]]\n  \
                  "
}], "Input"],

Cell["Here are the evolution of two knots.", "Text"],

Cell["\<\
solveAndMakeGraphicsLIAEquation[
 {{Sin[\[Sigma]] + 2 Sin[2\[Sigma]], Cos[\[Sigma]] - 2 Cos[2\[Sigma]], Sin[3\
\[Sigma]]}, \[Sigma]}, 1, 120, 20, {90, 60}]\
\>", "Input"],

Cell["\<\
solveAndMakeGraphicsLIAEquation[
 {{Sin[\[Sigma]] + 3/2 Sin[3\[Sigma]], Cos[\[Sigma]] - 3/2 Cos[3\[Sigma]], \
Sin[4\[Sigma]]}, \[Sigma]}, 1, 120, 10, {180, 50}]\
\>", "Input"],

Cell["And here is the evolution of a Lissajou curve.", "Text"],

Cell["\<\
solveAndMakeGraphicsLIAEquation[
 {{Sin[2\[Sigma]], Cos[3\[Sigma]], Cos[\[Sigma]]}, \[Sigma]}, 1, 120, 3, \
{120, 50}]\
\>", "Input"],

Cell[TextData[{
  "By letting the curve change its topology when two curve segments are near \
to each other, complicated vertex tangles can be formed [",
  
  CounterBox["BibliographyCounter", "Schwarz88"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Schwarz88",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Buttke88"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Buttke88",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Tsubota00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Tsubota00",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "We continue with a partial differential equation that contains mixed \
spatial and temporal derivatives. Solving such differential equations is \
currently not yet supported. We start with a relatively simple equation, a \
Born\[Dash]Infeld\[Hyphen]type wave equation [",
  
  CounterBox["BibliographyCounter", "BialnynickiBirula83"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"BialnynickiBirula83",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Brunelli97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Brunelli97",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Denisov00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Denisov00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lemos99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lemos99",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Kong04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kong04",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Brenier04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Brenier04",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Felder02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Felder02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Blochintsev52"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Blochintsev52",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Barbashov67"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Barbashov67",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Chellone71"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chellone71",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Chruscinski98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chruscinski98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Radozycki04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Radozycki04",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Ferraro04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ferraro04",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "  "
}], "ProgramLabel"],

Cell[TextData[{
  StyleBox["(* simplest Born\[Dash]Infeld wave equation for a scalar field \
*)", "CodeComment"],
  "\neqBornInfeld[] := (1 + D[\[Phi][x, t], x]^2) D[\[Phi][x, t], t, t] - \n  \
                 2 D[\[Phi][x, t], x] D[\[Phi][x, t], t] D[\[Phi][x, t], x, \
t] -\n                  (1 - D[\[Phi][x, t], t]^2) D[\[Phi][x, t], x, x] == 0\
\n \n",
  StyleBox["(* two smooth initial wave packets *)", "CodeComment"],
  "                                  \nstartPackets[\[Beta]_, x_] := \n \
Which[Abs[x - 1/3] <= \[Beta], Cos[Pi/2 (x - 1/3)/\[Beta]]^2,\n       Abs[x + \
1/3] <= \[Beta], Cos[Pi/2 (x + 1/3)/\[Beta]]^2, True, 0];                     \
             \n\nsolveAndMakeGraphicsBornInfeld[{\[Beta]_, {L_, T_}, g_, \
do_}, ppL_] := \nModule[{ndsol}, \n",
  StyleBox["(* solve PDEs *)", "CodeComment"],
  "\nndsol = NDSolve[{eqBornInfeld[], \[Phi][x, 0] == startPackets[\[Beta], \
x/L], \n                 Derivative[0, 1][\[Phi]][x, 0] == 0,\n               \
  \[Phi][ L, t] == \[Phi][-L, t]},\n         {\[Phi]}, {x, -L, L}, {t, 0, T}, \
\n         MaxSteps -> 10^5, PrecisionGoal -> g, AccuracyGoal -> g, \n        \
 Method -> {\"MethodOfLines\", Method -> Automatic,\n                    \
\"SpatialDiscretization\" -> \n                    {\"TensorProductGrid\", \
\"DifferenceOrder\" -> do, \n                     \"MaxPoints\" -> {ppL}, \
\"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "\nContourPlot[Evaluate[\[Phi][x, t] /. ndsol[[1]]], {x, -L, L}, {t, 0, T}, \
\n       PlotRange -> All, PlotPoints -> 240, Contours -> 20, \n       \
ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]\n       \n",
  StyleBox["(* example solution *)", "CodeComment"],
  "       \nsolveAndMakeGraphicsBornInfeld[{1/6, {10, 25}, 3, \
Pseudospectral}, 121] "
}], "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "(The relativistic diffusion equation also exhibits mixed spatial and \
temporal derivatives [",
  
  CounterBox["BibliographyCounter", "Kostadt00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kostadt00",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"],

Cell[TextData[{
  "The next example generates graphics that show how an initially localized \
smooth perturbation splits into peakon trains [",
  
  CounterBox["BibliographyCounter", "Holm03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Holm03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Holm03b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Holm03b",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Liu01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Liu01",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Camassa94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Camassa94",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "  "
}], "ProgramLabel"],

Cell[TextData[{
  StyleBox["(* peakon PDEs *)", "CodeComment"],
  "\neqPeakon[u_, {x_, t_}, \[Alpha]_] := \n Function[m, D[m, t] + u[x, t] \
D[m, x] + 2 D[u[x, t], x] m == 0][\n                                   u[x, \
t] - \[Alpha]^2 D[u[x, t], x, x]];\n",
  StyleBox["(* smooth initial bump *)", "CodeComment"],
  "                                  \nstartBump[\[Beta]_, x_] := If[Abs[x] \
>= \[Beta], 0, Cos[Pi/2 x/\[Beta]]^2];      \n\nsolveAndMakeGraphicsPeakon[{{\
\[Alpha]_, \[Beta]_}, {L_, T_}, g_, do_}, ppL_] := \nModule[{ndsol, u}, \n",
  StyleBox["(* solve PDEs *)", "CodeComment"],
  "\nndsol = NDSolve[{eqPeakon[u, {x, t}, \[Alpha]], u[x, 0] == startBump[\
\[Beta], x/L], \n                 u[ L, t] == u[-L, t]},\n         {u}, {x, \
-L, L}, {t, 0, T}, \n         MaxSteps -> 10^5, PrecisionGoal -> g, \
AccuracyGoal -> g, \n         Method -> {\"MethodOfLines\", Method -> \
Automatic,\n                    \"SpatialDiscretization\" -> \n               \
     {\"TensorProductGrid\", \"DifferenceOrder\" -> do, \n                    \
 \"MaxPoints\" -> {ppL}, \"MinPoints\" -> {ppL}}}];\n",
  StyleBox["(* visualize solution *)", "CodeComment"],
  "\nContourPlot[Evaluate[u[x, t] /. ndsol[[1]]], {x, -L, L}, {t, 0, T}, \n   \
    PlotRange -> All, PlotPoints -> 240, Contours -> 20, \n       \
ContourLines -> False, FrameTicks -> False, \n       ColorFunction -> \
(Hue[0.8 #]&)]]\n       \n",
  StyleBox["(* solutions for two parameter sets *)", "CodeComment"],
  "       \nShow[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n \
{solveAndMakeGraphicsPeakon[{{-1.61667, 0.234245}, {121, 80}, 3, 8}, 80],\n  \
solveAndMakeGraphicsPeakon[{{+1.31838, 0.624857}, { 62, 80}, 3, 8}, 80]}]]]   \
  "
}], "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "For further partial differential equations that contain mixed spatial and \
temporal derivatives, see [",
  
  CounterBox["BibliographyCounter", "Belmonte01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Belmonte01",
    ButtonStyle->"Hyperlink"],
  "] (describing a the motion of a vibrating hanging shoe string)."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  7.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Vibrating Koch Drum"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider a square Koch curve of order 2. Solve the Helmholtz equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"-", "\[CapitalDelta]"}], " ", 
            RowBox[{"u", "(", 
              RowBox[{"x", ",", "y"}], ")"}]}], "=", 
          RowBox[{
            SuperscriptBox["\[Omega]", "2"], " ", 
            RowBox[{"u", "(", 
              RowBox[{"x", ",", "y"}], ")"}]}]}], TraditionalForm]]],
  " in this Koch curve with Dirichlet boundary conditions. Estimate accuracy \
of the eigenvalues through comparison with state that is locally everywhere a \
product state of sine functions. Visualize some of the eigenfunctions as 3D \
plots and as contour plots. Visualize the values of the gradients of some of \
the lowest and some of the higher eigenfunctions.\nCalculate the first 1000 \
lowest eigenvalues and compare the number of eigenfunctions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "(", "\[Omega]", ")"}], TraditionalForm]]],
  " as function of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " with the asymptotic Weyl\[Dash]Berry law [",
  
  CounterBox["BibliographyCounter", "Baltes76"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Baltes76",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Berry79"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Berry79",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Hobiki95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hobiki95",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Hobiki96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hobiki96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Homolya03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Homolya03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Netrusov03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Netrusov03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Homolya03b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Homolya03b",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        StyleBox[
          RowBox[{
            RowBox[{
              RowBox[{
                RowBox[{"n", "(", "\[Omega]", ")"}], "~", "A"}], "/", 
              RowBox[{"(", 
                RowBox[{"4", "\[Pi]"}], ")"}]}], " ", 
            SuperscriptBox["\[Omega]", "2"]}],
          AutoStyleOptions->{"UnmatchedBracketStyle"->None}], 
        StyleBox["-",
          AutoStyleOptions->{"UnmatchedBracketStyle"->None}], 
        RowBox[{
          StyleBox["{",
            AutoStyleOptions->{"UnmatchedBracketStyle"->None},
            SpanMinSize->3.5,
            SpanMaxSize->Infinity], 
          StyleBox[GridBox[{
                {
                  RowBox[{"c", " ", 
                    SuperscriptBox["\[Omega]", "d"]}], 
                  RowBox[{"for", " ", "fractal", " ", "boundaries"}]},
                {
                  RowBox[{
                    RowBox[{"a", " ", "/", 
                      RowBox[{"(", 
                        RowBox[{"4", "\[Pi]"}], ")"}]}], "\[Omega]"}], 
                  RowBox[{"for", " ", "smooth", " ", 
                    RowBox[{"boundaries", "."}]}]}
                }],
            AutoStyleOptions->{"UnmatchedBracketStyle"->None},
            SpanMinSize->Automatic,
            SpanMaxSize->Infinity,
            GridBoxOptions->{ColumnAlignments->{Left}}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[CellGroupData[{

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox["A", TraditionalForm]]],
  " is the area of the (holefree) drum, ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " is its circumference length, and ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  " is the fractal (interior Minkowski ",
  "[",
  
  CounterBox["BibliographyCounter", "Mattila95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Mattila95",
    ButtonStyle->"Hyperlink"],
  "]",
  ") dimension of the boundary."
}], "SolutionSubgroup"],

Cell["\<\
The solve the eigenvalue problem of the Helmholtz equation, the \
piecewise horizontal and vertical boundary segments suggest a finite \
difference discretization of the interior of the Koch curve. To achieve a \
solution of sufficiently high precision, we will use higher order finite \
difference approximations. \
\>", "Text"],

Cell["Off[General::spell]; Off[General::spell1];", "Input"],

Cell["\<\
We start by calculating the 1D finite difference weights. For the \
actual 2D Koch curve problem, we use a tensor product form of these \
differences.\
\>", "Text"],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th element of ",
  StyleBox["FDWeightLists[", "MR"],
  Cell[BoxData[
      FormBox["\[Nu]", TraditionalForm]]],
  StyleBox["][", "MR"],
  StyleBox["o", "TI"],
  StyleBox["]", "MR"],
  " gives the list of length ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  " of the weights of the function values to approximate the ",
  Cell[BoxData[
      FormBox["\[Nu]", TraditionalForm]]],
  "th derivative at the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th point from the left through the function values at ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  " points. It is obtained by forming an interpolating polynomial through the \
(symbolic) function values, differentiating this polynomial, and extracting \
the coefficients of the function values [",
  
  CounterBox["BibliographyCounter", "Fornberg99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Fornberg99",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Fornberg98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Fornberg98",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "FDWeightLists[\[Nu]_][o_] :=\nModule[{ipo, poly}, \n       ",
  StyleBox["(* interpolating polynomial *)", "CodeComment"],
  " \n       ipo[x_] = InterpolatingPolynomial[Table[{x0 + k h, f[k]}, \n     \
                                          {k, 0, o - 1}], x];\n      ",
  StyleBox[" (* loop over all o grid points *)", "CodeComment"],
  "\n       Table[",
  StyleBox["(* value of derivative at j-th grid point *)", "CodeComment"],
  "\n           poly = Expand[h^\[Nu] Together[D[ipo[x], {x, \[Nu]}] /. x -> \
x0 + j h]];\n           ",
  StyleBox["(* coefficients of function values *)", "CodeComment"],
  "\n           Coefficient[poly, Table[f[k], {k, 0, o - 1}]], {j, 0, o - \
1}]]"
}], "Input"],

Cell["\<\
Here are two examples: the first and second derivative of a stencil \
of length three.\
\>", "Text"],

Cell["FDWeightLists[1][3]", "Input"],

Cell["FDWeightLists[2][3]", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["hOrder[", "MR"],
  Cell[BoxData[
      FormBox["\[Nu]", TraditionalForm]]],
  StyleBox[", ", "MR"],
  StyleBox["fdws", "TI"],
  StyleBox["]", "MR"],
  " calculates the order of the approximation of the derivative ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["f", 
            RowBox[{"(", "\[Nu]", ")"}]], "(", "x", ")"}], 
        TraditionalForm]]],
  " for the finite difference weights ",
  StyleBox["fdws", "TI"],
  " at the point ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " and step size ",
  Cell[BoxData[
      FormBox["h", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "hOrder[\[Nu]_, fdws_, {x_, h_}] := \nNormal[",
  StyleBox["(* keep only highest order in h *) ", "CodeComment"],
  "\n       Series[#, {h, 0, Position[Rest[#[[3]]], _?(# =!= 0&), \n          \
  {1}, 1, Heads -> False][[1, 1]]}]]& /@ \nSeries[",
  StyleBox["(* expand in series about h == 0 *)", "CodeComment"],
  "\n",
  StyleBox["(* form expression approximating the derivative *)", 
    "CodeComment"],
  "\nMapIndexed[Function[{w, p}, w.Table[f[x + k h], \n               {k, 1 - \
p[[1]], -p[[1]] + Length[w]}]/h^\[Nu]], fdws],\n       {h, 0, \
Length[fdws[[1]]]}]"
}], "Input"],

Cell["\<\
Here are the approximation properties of the second derivative \
using three and five points. We see that the derivatives at the center points \
are approximated to an higher order.\
\>", "Text"],

Cell["hOrder[2, FDWeightLists[2][3], {x, h}]", "Input"],

Cell["hOrder[2, FDWeightLists[2][5], {x, h}]", "Input"],

Cell[TextData[{
  "We remark that the finite difference weights can be obtained from one of \
the built\[Hyphen]in supporting functions from the ",
  StyleBox["NDSolve`", "MR"],
  " context, namely through the function ",
  StyleBox["NDSolve`FiniteDifferenceDerivative", "MR"],
  "."
}], "Text"],

Cell["\<\
FDWeightListsBI[\[Nu]_][o_] :=
With[{grid = Range[o]}, Coefficient[#, f /@ grid]& /@ 
     NDSolve`FiniteDifferenceDerivative[Derivative[\[Nu]], grid, 
                        f /@ grid, DifferenceOrder -> o - \[Nu]]]\
\>", \
"Input"],

Cell[TextData[{
  StyleBox["(* quick check that the two functions give identical weights *)", 
    "CodeComment"],
  "\nTable[FDWeightLists[\[Nu]][o] == FDWeightListsBI[\[Nu]][o], \n      {\
\[Nu], 1, 6}, {o, \[Nu] + 1, 6}] // Flatten // Union"
}], "Input"],

Cell[TextData[{
  "The following graphic shows the central finite difference approximation \
weights for the second derivative. The graphic shows substantial changes for \
the first few values of ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " (we take a stencil of size ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"2", "\[Alpha]"}], "+", "1"}], TraditionalForm]]],
  "). As a result, we expect substantially different results for the \
eigenvalues for small ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ". Later, we will use ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "3"}], TraditionalForm]]],
  ", which will give results accurate to less than 0.1% over a large \[Omega]\
\[Hyphen]range."
}], "Text"],

Cell["\<\
Show[Graphics[Reverse @ Table[{Hue[(\[Alpha] - 1)/10], 
Line[MapIndexed[{#2[[1]] - \[Alpha] - 1, #1}&,
                FDWeightListsBI[2][2 \[Alpha] + 1][[\[Alpha] + 1]]]]},
                {\[Alpha], 7}]], PlotRange -> All, Frame -> True]\
\>", \
"Input"],

Cell[TextData[{
  "For later convenience, we define one more finite difference \
weight\[Hyphen]related function. Given a point on a 1D grid, the function ",
  StyleBox["stencilWeightList", "MR"],
  " gives the list of weights approximating the ",
  Cell[BoxData[
      FormBox["v", TraditionalForm]]],
  "th derivative by using ",
  StyleBox["leftPoints", "TI"],
  " to the left and ",
  StyleBox["rightPoints", "TI"],
  " to the right (and the center point itself)."
}], "Text"],

Cell["\<\
stencilWeightList[\[Nu]_][leftPoints_, rightPoints_] :=
        stencilWeightList[\[Nu]][leftPoints, rightPoints] = 
        FDWeightListsBI[\[Nu]][leftPoints + 1 + rightPoints][[leftPoints + \
1]]\
\>", "Input"],

Cell[TextData[{
  "Next, we construct the Koch drum. A Koch drum is obtained by recursively \
applying the following rule ",
  StyleBox["edgeRule", "MR"],
  " to the line segments of the last iteration drum. The 0th order drum is \
just a square."
}], "Text"],

Cell["\<\
edgeRule[{p_, q_}] := 
Module[{d = (q - p)/4, n = -Reverse[q - p]{-1, 1}/4},
       Partition[FoldList[Plus, p, {d, n, d, -n, -n, d, n, d}], 2, 1]]
       
startSquare = 
     Partition[{{-1, -1}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}}, 2, 1];\
\>", \
"Input"],

Cell["\<\
The following graphic shows the zeroth order drum in red, the first \
order in green, and the second order in violet. In the following, we will \
calculate the eigenvibrations of the second order Koch drum. The underlying \
square grid that will be used to partition the interior of the drum in the \
following is shown too.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* list of the first few the Koch drum iterations *)", 
    "CodeComment"],
  "\niterationOrder = 2;\nnl = NestList[Flatten[edgeRule /@ #, 1]&, \
startSquare, iterationOrder];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* edge length *)", "CodeComment"],
  "\n\[Lambda] = 2^-(2 iterationOrder - 1);"
}], "Input"],

Cell[TextData[{
  "Module[{L = 2 - 2^-iterationOrder}, \nShow[Graphics[{\n {",
  StyleBox["(* background mesh *)", "CodeComment"],
  "\n  Thickness[0.001], GrayLevel[0.8], {#, Map[Reverse, #, {3}]}&[\n   \
Table[Line[{{-L, z}, {L, z}}], {z, -L, L, \[Lambda]}]]},\n   \
MapIndexed[{Hue[0.78 (#2[[1]] - 1)/\n               If[iterationOrder == 0, \
1, iterationOrder]],   \n  Thickness[0.01/#2[[1]]], Line /@ #1}&, nl]}], \n  \
PlotRange -> All, AspectRatio -> Automatic, Axes -> True]]"
}], "Input"],

Cell[TextData[{
  "These are the line segments forming the boundary of the Koch drum. To test \
if a line segment is part of the boundary, we implement the function ",
  StyleBox["outerEdgeQ", "MR"],
  "."
}], "Text"],

Cell["\<\
drumEdges = Sort /@ nl[[-1]];
(outerEdgeQ[#] = True)& /@ drumEdges;\
\>", "Input"],

Cell["\<\
translateSquare[mp_, edge_, square_]  :=
With[{t = 2 ((Plus @@ edge/2) - mp)}, Map[(t + #)&, square, {-2}]]\
\>", \
"Input"],

Cell[TextData[{
  "Until now, we only have the boundary of the Koch drum. While for a \
boundary element method, this would be enough to calculate the eigenvalues, \
for a finite difference approximation, we need explicit points in the \
interior. The interior of the Koch drum is naturally subdivided into squares \
of edge lengths equal to the length of a boundary segments. We obtain all \
squares by starting in the center and recursively select all neighboring \
squares until we hit the boundary. The list ",
  StyleBox["allInnerSquares", "MR"],
  " contains the inner squares in the form ",
  StyleBox["Square[", "MR"],
  StyleBox["midpoint", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["squareEdges", "TI"],
  StyleBox["]", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* form squares that are neighbors of a given square sq *)", 
    "CodeComment"],
  "\nneighborSquares[sq:Square[mp_, edges_]] :=\nModule[{sortedEdges = Sort \
/@ edges, growEdges, newSquares}, \n       ",
  StyleBox["(* the edges of the square that are not boundaries of the drum \
*)", "CodeComment"],
  "\n       growEdges = Complement[sortedEdges, Select[sortedEdges, \
outerEdgeQ]];\n       newSquares = translateSquare[mp, #, sq]& /@ growEdges]"
}], "Input"],

Cell[TextData[{
  "allInnerSquares",
  StyleBox[" = \n", "CodeComment"],
  "Module[{usedMpQ, currentSquares, squaresBag, newSquareLayer},\nIf[",
  StyleBox["(* zeroth order is special *)", "CodeComment"],
  "\n iterationOrder === 0, {Square[{0, 0}, startSquare]},",
  StyleBox["\n (* the four squares around the center *)", "CodeComment"],
  "\n currentSquares = Square[Plus @@ Flatten[#, 1]/8, #]& /@  \n  \
(Partition[Append[#, First[#]], 2, 1]& /@ \n     ({{{ 0,  0}, { \[Lambda],  \
0}, { \[Lambda],  \[Lambda]}, { 0,  \[Lambda]}}, \n       {{-\[Lambda],  0}, \
{ 0,  0}, { 0,  \[Lambda]}, {-\[Lambda],  \[Lambda]}},\n       {{ 0, -\
\[Lambda]}, { \[Lambda], -\[Lambda]}, { \[Lambda],  0}, { 0,  0}}, \n       \
{{-\[Lambda], -\[Lambda]}, { 0, -\[Lambda]}, { 0,  0}, {-\[Lambda],  0}}}));\n\
",
  StyleBox["(* currently already used squares *)", "CodeComment"],
  "\n squaresBag = currentSquares;\n (usedMpQ[#[[1]]] = True)& /@ \
currentSquares;\n",
  StyleBox["(* form outside neighbor square layers as long as possible *)", 
    "CodeComment"],
  "\nWhile[newSquareLayer = First /@ Split[Sort[Flatten[neighborSquares /@\n  \
                                                 currentSquares]],\n          \
                            #1[[1]] === #2[[1]]&];\n      currentSquares = \
Complement[newSquareLayer, \n                                  \
Select[newSquareLayer, usedMpQ[#[[1]]]&]];\n      currentSquares =!= {},\n    \
  ",
  StyleBox["(* update *)", "CodeComment"],
  "\n      squaresBag = {squaresBag, currentSquares};\n     (usedMpQ[#[[1]]] \
= True)& /@ currentSquares];\n",
  StyleBox["(* the squares forming the interior of the Koch drum *)", 
    "CodeComment"],
  "\nallInnerSquares = Flatten[squaresBag]]];"
}], "Input"],

Cell["Here are all the 256 interior squares.", "Text"],

Cell[TextData[{
  "Show[Graphics[{",
  StyleBox["(* the interior squares, colored randomly *)", "CodeComment"],
  "\n               {Hue[Random[]], #}& /@ allInnerSquares /. \n              \
  Square[mp_, edges_] :> Polygon[First /@ edges],\n               ",
  StyleBox["(* the drum edges *)", "CodeComment"],
  "\n               {GrayLevel[0], Thickness[0.005], Line /@ drumEdges}},\n   \
   AspectRatio -> Automatic]]"
}], "Input"],

Cell["\<\
We generate lists of all vertices, the outer (boundary) vertices, \
and the strictly inner vertices.\
\>", "Text"],

Cell["\<\
allVertices = Union[Flatten[Last /@ allInnerSquares, 2]];
outerVertices = Union[Flatten[drumEdges, 1]];
innerVertices = Complement[allVertices, outerVertices];\
\>", "Input"],

Cell[TextData[{
  "To obtain a good resolution of the solution in the thin bays of the Koch \
drum, we will now subdivide each square into ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          StyleBox["rL",
            FontSlant->"Italic"], "2"], TraditionalForm]]],
  " smaller squares. We use ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["rL",
            "TI"], "=", "8"}], TraditionalForm]]],
  " in the following. ",
  StyleBox["L", "TI"],
  " denotes the shortest distance between two neighboring discretization \
points."
}], "Text"],

Cell[TextData[{
  StyleBox["(* order of refinement within each square *)", "CodeComment"],
  " rL = 8;\n",
  StyleBox["(* distance between two adjacent vertices *) ", "CodeComment"],
  "L = \[Lambda]/rL;"
}], "Input"],

Cell[TextData[{
  StyleBox["(* subdivide a square into rL\[Times]rL smaller squares *)", 
    "CodeComment"],
  "\nrefineSquare[Square[mp_, edges_], rL_]  :=\nModule[{p1, p2, p3, p4, d1, \
d2},\n       {p1, p2, p3, p4} = First /@ edges;\n       d1 = p2 - p1; d2 = p4 \
- p1;\n       Table[Square[{p1 + j/rL d1 + k/rL d2, p1 + (j + 1)/rL d1 + k/rL \
d2,\n                     p1 + (j + 1)/rL d1 + (k + 1)/rL d2, \n              \
       p1 + j/rL d1 + (k + 1)/rL d2}],\n             {j, 0, rL - 1}, {k, 0, \
rL - 1}] // Flatten];"
}], "Input"],

Cell[TextData[{
  "We now create lists of inner vertices ",
  StyleBox["innerRefinedVertices", "MR"],
  " (of the small squares) and vertices ",
  StyleBox["boundaryVertices", "MR"],
  " (of the small) squares that lie on the boundary of the drum."
}], "Text"],

Cell["\<\
allRefinedInnerSquares = Flatten[refineSquare[#, rL]& /@ \
allInnerSquares];
allRefinedVertices = Union[Flatten[First /@ allRefinedInnerSquares, 1]];

boundaryVertices = 
Union[Flatten[Table[#1 + j/rL (#2 - #1), {j, 0, rL}]& @@@ drumEdges, 1]];

innerRefinedVertices = Complement[allRefinedVertices, \
boundaryVertices];\
\>", "Input"],

Cell["\<\
So we have 15361 inner vertices. At these inner vertices, we will \
have to calculate the values of the eigenvibrations. (Due to the Dirichlet \
boundary conditions we are using all boundary vertex values are identically \
zero.)\
\>", "Text"],

Cell["\<\
Length /@ {allRefinedVertices, boundaryVertices, \
innerRefinedVertices}\
\>", "Input"],

Cell["\<\
Here is a sketch of the Koch drum with the inner vertices in red \
and the boundary vertices in black.\
\>", "Text"],

Cell["\<\
Show[Graphics[{{PointSize[0.004], GrayLevel[0], Point /@ \
boundaryVertices},
               {PointSize[0.002], Hue[0], Point /@ innerRefinedVertices}}],
     PlotRange -> All, AspectRatio -> Automatic]\
\>", "Input"],

Cell[TextData[{
  "Now the values of the eigenvibrations at the inner vertices have to be \
determined. This means that we have to find eigenvalues and eigenvectors of a \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", "\[Times]", "d"}], TraditionalForm]]],
  " matrix, where for the Dirichlet boundary conditions ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  " is the number of the interior vertices."
}], "Text"],

Cell["dimD = Length[innerRefinedVertices];", "Input"],

Cell["\<\
We define some functions that number the vertices, return their \
coordinates, and test if a vertex is an inner vertex.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* convert between vertex coordinates and vertex number *)", 
    "CodeComment"],
  "\nDo[vertexDNumber[innerRefinedVertices[[k]]] = k;\n   \
vertexDCoordinates[k] = innerRefinedVertices[[k]];\n   \
isInnerDVertex[innerRefinedVertices[[k]]] = True, {k, dimD}];\n   \n",
  StyleBox["(* is a vertex an inner vertex? *)", "CodeComment"],
  "\nisInnerDVertexQ[vertex_] := isInnerDVertexQ[vertex] = \n                 \
           TrueQ[isInnerDVertex[vertex]]"
}], "Input"],

Cell["We define similar functions for the boundary vertices.", "Text"],

Cell[TextData[{
  "Do[boundaryVertexNumber[boundaryVertices[[k]]] = k;\n   \
boundaryVertexCoordinates[k] = boundaryVertices[[k]];\n   \
isBoundaryVertex[boundaryVertices[[k]]] = True, \n   {k, \
Length[boundaryVertices]}];\n   \n",
  StyleBox["(* is a vertex a boundary vertex? *)", "CodeComment"],
  "\nisBoundaryVertexQ[vertex_] := isBoundaryVertexQ[vertex] = \n             \
                 TrueQ[isBoundaryVertex[vertex]]"
}], "Input"],

Cell[TextData[{
  "For all inner vertices, we now define a neighborhood and approximate the \
Laplacian through the weighted average of the function values at neighboring \
vertices. The auxiliary function ",
  StyleBox["addVertexWeights", "MR"],
  " adds the contributions of the list of finite difference weights ",
  StyleBox["vws", "TI"],
  " for each vertex."
}], "Text"],

Cell["\<\
addVertexWeights[vws_] := 
If[Length[#] === 1, First[#], #[[1, 1]] -> (Plus @@ (Last /@ #))]& /@ 
                              Split[Sort[vws], #1[[1]] === #2[[1]]&]\
\>", \
"Input"],

Cell[TextData[{
  "For a given stencil of odd length ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"2", "\[Alpha]"}], "+", "1"}], TraditionalForm]]],
  ", the function ",
  StyleBox["makeNonVanishingDMatrixElements", "MR"],
  " returns a list of the nonvanishing elements of the discretization of the \
negative of the 2D Laplace operator. We incorporate the Dirichlet boundary \
conditions through an antisymmetric continuation of the function across the \
boundary. By using an odd stencil length, we make sure that is always \
possible."
}], "Text"],

Cell[TextData[{
  "makeNonVanishingDMatrixElements[\[Alpha]_Integer] := addVertexWeights @\n\
Module[{centerVertex, jB, swl = -stencilWeightList[2][\[Alpha], \[Alpha]]},\n\
Table[centerVertex = innerRefinedVertices[[k]]; \n       {{k, k} -> 2 swl[[\
\[Alpha] + 1]],\n        Function[dir, jB =.;\n        ",
  StyleBox["(* loop over neighbors *)", "CodeComment"],
  "\n        Table[nextVertex = centerVertex + j L dir;\n              ",
  StyleBox["(* neighbor is inner vertex, boundary vertex, \n                 \
or outer vertex *)", "CodeComment"],
  "\n              Which[isInnerDVertexQ[nextVertex], \n                    \
{k, vertexDNumber[nextVertex]} -> swl[[\[Alpha] + 1 + j]], \n                 \
   isBoundaryVertexQ[nextVertex], jB = j; Sequence @@ {},\n                   \
 True, reflectedVertex = ",
  StyleBox["(* reflect *)", "CodeComment"],
  "\n                             centerVertex + jB L dir - (j - jB) L dir;\n \
                   {k, vertexDNumber[reflectedVertex]} -> \n                  \
                      -swl[[\[Alpha] + 1 + j]]], \n                    {j, 1, \
\[Alpha]}]] /@ ",
  StyleBox["(* horizontal and vertical neighbors *)", "CodeComment"],
  "\n                    {{+1, 0}, {-1, 0}, {0, 1}, {0, -1}}},",
  StyleBox[" \n                    (* all inner vertices *) ", 
    "CodeComment"],
  "{k, dimD}] // Flatten];"
}], "Input"],

Cell[TextData[{
  "Here is the resulting sparse matrix for stencil length seven. ",
  StyleBox["MD7", "MR"],
  " is of dimensions 15361\[Times]15361 and has 187429 nonvanishing elements. \
By construction, the matrix ",
  StyleBox["MD7", "MR"],
  " is symmetric."
}], "Text"],

Cell["MD7 = SparseArray[makeNonVanishingDMatrixElements[3]]", "Input"],

Cell[TextData[{
  StyleBox["(* check that MD7 is a symmetric matrix *)", "CodeComment"],
  "\nMax[MD7 - Transpose[MD7]]"
}], "Input"],

Cell["\<\
We visualize the nonzero elements of the resulting matrix. It is \
nicely banded.\
\>", "Text"],

Cell["\<\
Show[Graphics[{GrayLevel[0], Rectangle[#1 - 1/2, #1 + 1/2]}& @@@ 
                                    makeNonVanishingDMatrixElements[3]],
     PlotRange -> All, Frame -> True, AspectRatio -> Automatic]\
\>", "Input"],

Cell[TextData[{
  "To find the eigenvalues and eigenvectors of the matrix ",
  StyleBox["MD7", "MR"],
  ", we will use the ",
  StyleBox["\"Arnoldi\"", "MR"],
  " method. We obtain the extremal eigenvalues with the ",
  StyleBox["\"BothEnds\"", "MR"],
  " criteria. We multiply by the square of the discretization length ",
  StyleBox["L", "TI"],
  " to obtain the eigenvalues for the original drum."
}], "Text"],

Cell["\<\
Eigenvalues[N[MD7], 2, Method -> {\"Arnoldi\", Criteria -> \
\"BothEnds\",  
                                  BasisSize -> 30}]/L^2\
\>", "Input"],

Cell[TextData[{
  "Next, we calculate the eight lowest eigenvalues. The function ",
  StyleBox["drumEigensystem", "MR"],
  " calculates some selected eigenvalues of the matrix ",
  StyleBox["MD7", "MR"],
  ".",
  " We see the unique lowest eigenvalue and that the next two eigenvalues are \
degenerate. Because of the fourfold rotational symmetry of the Koch curve, \
such a degeneracy is expected."
}], "Text"],

Cell["\<\
drumEigensystem[n_, opts___] := MapAt[1/L^2 #&, Reverse /@ 
    Eigensystem[N[MD7], n, Method -> {\"Arnoldi\", opts, Tolerance -> 10^-10,
                BasisSize -> Abs[20 n], MaxIterations -> 10^4}], 1]\
\>", \
"Input"],

Cell["\<\
{evalsD7Low, evecsD7Low} = drumEigensystem[-8];
ListPlot[evalsD7Low, PlotRange -> All, PlotStyle -> {PointSize[0.03]},
         AxesOrigin -> {0, 0}]\
\>", "Input"],

Cell[TextData[{
  "We also calculate the eigenvalues near the exactly known eigenvalues of \
the state, that is in each subsquare a product state of sine functions [",
  
  CounterBox["BibliographyCounter", "Sapoval93"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sapoval93",
    ButtonStyle->"Hyperlink"],
  "]. The lowest of these functions has the eigenvalue ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CapitalLambda]", "=", 
          RowBox[{
            RowBox[{"2", 
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{"\[Pi]", "/", "\[Lambda]"}], ")"}], "2"]}], 
            "\[TildeTilde]", "1263.31"}]}], TraditionalForm]]],
  ". The following list of eigenvalues clearly suggests that the third \
element of ",
  StyleBox["evecsD7Sin1", "MR"],
  " is this state. Its eigenvalue deviates by only 0.0006% from the exact \
value."
}], "Text"],

Cell["\<\
\[CapitalLambda] = 2 (Pi/\[Lambda])^2;
{evalsD7Sin1, evecsD7Sin1} = drumEigensystem[6, Shift -> \[CapitalLambda] \
L^2];
(evalsD7Sin1/\[CapitalLambda] - 1) \
\>", "Input"],

Cell[TextData[{
  "The next state that is a product of sine functions has eigenvalue ",
  Cell[BoxData[
      FormBox[
        RowBox[{"4", "\[CapitalLambda]"}], TraditionalForm]]],
  ". The eigenvalue of the fourth state of the list deviates by about 0.04% \
from the exact value. This indicates that the states up to this energy are \
clearly precisely enough calculated for any visualization purposes we are \
primarily interested in."
}], "Text"],

Cell["\<\
{evalsD7Sin2, evecsD7Sin2} = drumEigensystem[6, Shift -> 4 \
\[CapitalLambda] L^2];
(evalsD7Sin2/(4 \[CapitalLambda]) - 1)                                  \
\
\>", "Input"],

Cell[TextData[{
  "Now that we have the eigenvectors, we will visualize them. We start with \
3D plots. To construct them, we just use the small squares ",
  StyleBox["allRefinedInnerSquares", "MR"],
  " from above and add as the ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]value the eigenvector components to their vertices."
}], "Text"],

Cell[TextData[{
  StyleBox["(* plot a general surface with height values over the drum \
vertices *)", "CodeComment"],
  "\ndrum3DPlot[vertexValueFunction_, opts___] :=\nGraphics3D[{EdgeForm[], ",
  StyleBox["(* add z-component from eigenvector evec *)", "CodeComment"],
  "\n            Map[vertexValueFunction, \n            ",
  StyleBox["(* the small squares *)", "CodeComment"],
  "             \n            Polygon /@ (List @@ (First /@ \
allRefinedInnerSquares)), {-2}],\n                {GrayLevel[0], \
Thickness[0.006], ",
  StyleBox["(* drum boundary *)", "CodeComment"],
  "\n                 Line /@ Map[Append[#, 0]&, drumEdges, {-2}]}},\n        \
  opts, PlotRange -> All, BoxRatios -> {1, 1, 0.4}];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* plot Dirichlet eigenfunctions *)", "CodeComment"],
  "\neigenDVibration3DPlot[evec_, opts___] :=\nWith[{ev = evec/Sign[Plus @@ \
evec]},\n     drum3DPlot[Function[v, Append[v, If[isInnerDVertexQ[v], \n      \
                      ev[[vertexDNumber[v]]], 0]]], opts]]"
}], "Input"],

Cell["Here are the eigenvibrations of the nine lowest states.", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@
     Partition[eigenDVibration3DPlot /@ evecsD7Low, 2];\
\>", "Input"],

Cell["\<\
The 3D plots of the higher eigenvalues show generally complicated \
patterns of the minima and maxima. The fourth of the above states though, is \
very regular. It is the lowest state that is globally a product of sine \
functions.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@
     Partition[eigenDVibration3DPlot /@ evecsD7Sin1, 2]\
\>", "Input"],

Cell[TextData[{
  "Here are two higher eigenfunctions whose oscillating parts are largely \
concentrated in the four bay areas ",
  "[",
  
  CounterBox["BibliographyCounter", "Sapoval97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sapoval97",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[eigenDVibration3DPlot[
       drumEigensystem[1, Shift -> # L^2][[2, 1]]]& /@ {176.642, 525.582}]]\
\
\>", "Input"],

Cell[TextData[{
  "As an alternative to the last 3D plots and as a better visualization \
method for the highly oscillating higher states, we will now implement a \
contour plot for the Koch drum. The built\[Hyphen]in contour plot will, of \
course, not work directly. Two possibilities to construct a contour plot for \
the semiregular shape of the Koch drum come to mind: a) Extending the Koch \
curve to a square array by adding vertices with value zero, and b) making \
independent contour plots for all of the small squares and displaying them \
together. We will follow the method b) in the following. (This method is more \
flexible and can be easily generalized to say, the triangular Koch curve) The \
function ",
  StyleBox["eigenVibrationContourPlot", "MR"],
  " generates a contour graphic of the eigenvalue ",
  StyleBox["evec", "TI"],
  " using ",
  StyleBox["contours", "TI"],
  " contours."
}], "Text"],

Cell[TextData[{
  StyleBox["(* vertex numbers inside the refined squares  *)", 
    "CodeComment"],
  "\nrefinedSquareVertexArray[\n Square[mp_, {{p1_, _}, {p2_, _}, {p3_, _}, \
{p4_, _}}], rL_]  :=\nModule[{d1 = p2 - p1, d2 = p4 - p1, vertex},\n       \
{Table[vertex = p1 + j/rL d1 + k/rL d2;\n              \
If[isInnerDVertexQ[vertex], vertexDNumber[vertex], 0],\n              {k, 0, \
rL}, {j, 0, rL}],\n        {Min[#], Max[#]}& /@ Transpose[{p1, p2, p3, \
p4}]}];\n        \nrefinedSquareData = refinedSquareVertexArray[#, rL]& /@ \
allInnerSquares;"
}], "Input"],

Cell[TextData[{
  StyleBox["(* contour values for contours *) ", "CodeComment"],
  "\ncontourValues[evec_, contours_] := \nModule[{eD = Length[evec]}, ",
  StyleBox["(* homogeneous contour spacing *)", "CodeComment"],
  "\n       #[[Round[eD/contours/2]]]& /@ \n           Partition[Sort[evec], \
Round[eD/contours]]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* contour plot inside each of the squares of the Koch drum *)\n",
     "CodeComment"],
  "smallSquareContourPlot[evec_, {vertexArray_, meshRange_}, cvs_] :=\n\
Module[{lcpData},\n       lcpData = Map[If[# =!= 0, evec[[#]], 0.]&, \
vertexArray, {2}];\n       Graphics[ListContourPlot[lcpData, \n       ",
  StyleBox["(* set options so that the single plots fit together *)", 
    "CodeComment"],
  "\n        Contours -> cvs, MeshRange -> meshRange, PlotRange -> {0, 1},\n  \
      ColorFunctionScaling -> False, ContourLines -> False, \n        \
ContourSmoothing -> True, ColorFunction -> GrayLevel]]]"
}], "Input"],

Cell[TextData[{
  "eigenVibrationContourPlot[evec_, contours_, opts___] :=\nModule[{ev = \
evec/Sign[Plus @@ evec], min, max, cs},\n       min  = Min[ev]; max = \
Max[ev];\n       ",
  StyleBox["(* scale eigenvector values to [0, 1] *)", "CodeComment"],
  "\n       scaledEv = (ev - min)/(max - min);\n       cvs = \
contourValues[scaledEv, contours];\n       Block[{$DisplayFunction = \
Identity},\n        ",
  StyleBox["(* make contour plots in all small squares *)", "CodeComment"],
  "\n        cs = smallSquareContourPlot[scaledEv, #, cvs]& /@ \
refinedSquareData;\n        Show[{cs, ",
  StyleBox["(* the Koch drum boundary *)", "CodeComment"],
  "\n              Graphics[{{Hue[0], Thickness[0.008], \n                    \
         Line /@ drumEdges}}]},\n             PlotRange -> All, Frame -> \
False]] /. \n                               Identity -> $DisplayFunction]"
}], "Input"],

Cell["Here are contour plots for the nine lowest states.", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@
     Partition[eigenVibrationContourPlot[#, 30]& /@ evecsD7Low,  2]\
\>", \
"Input"],

Cell["\<\
Show[GraphicsArray[#]]& /@
     Partition[eigenVibrationContourPlot[#, 30]& /@ evecsD7Sin1, 2]\
\>", \
"Input"],

Cell["\<\
Show[GraphicsArray[#]]& /@
     Partition[eigenVibrationContourPlot[#, 30]& /@ evecsD7Sin2, 2]\
\>", \
"Input"],

Cell[TextData[{
  "Now let us look at the Weyl\[Dash]Berry law. A direct call to ",
  StyleBox["Eigenvalues[N[MD7], -1000, \[Ellipsis]]", "MR"],
  " is not realistic for most computers due to the large memory requirements \
(about 10 GB for a basis size of 10 times the number of eigenvalues). So, \
instead we will move through the spectrum and calculate 24 eigenvalues at \
once, align the newly calculated eigenvalues with the last batch and extract \
the new higher eigenvalues. Because some eigenvalues have finite \
multiplicity, we will align four eigenvalues. Using this method we will get \
the first 1000 states in about an hour with the moderate memory usage of less \
than 300 MB. Because the Arnoldi method gives not only the eigenvalues, but \
the eigenvectors too, we also form the cumulative sum of the squares of \
eigenvectors ",
  StyleBox["evecSum", "MR"],
  ". And we keep a truncated version of ",
  StyleBox["evecSum", "MR"],
  ", called ",
  StyleBox["evecSumSmall", "MR"],
  " that sums only states for which ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Omega]", "\[GreaterTilde]", 
          RowBox[{"2", 
            RowBox[{"\[Pi]", "/", "\[Lambda]"}]}]}], TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  " is the length of a straight boundary segment of our Koch curve."
}], "Text"],

Cell[TextData[{
  StyleBox["(* center of the next set of eigenvalues *)", "CodeComment"],
  "\nnextEvalCenter[l_] := (Plus @@ Take[l, -4]/4) + \n                      \
",
  StyleBox["(* avoid eigenvalue  *) ", "CodeComment"],
  "1/2 (l[[5]] - l[[4]])"
}], "Input"],

Cell[TextData[{
  "evalNumberMax = 1000;\n\n",
  StyleBox["(* start data *)", "CodeComment"],
  "\n{currentEvals, currentEvecs} = {evalsD7Low, evecsD7Low};\nevalList = \
currentEvals; evecSum = Plus @@ (currentEvecs^2); \n\n\nWhile[\n ",
  StyleBox["(* get additional, higher eigenvalues *)\n ", "CodeComment"],
  "evDim = 24;\n While[",
  StyleBox["(* the next higher eigenvalues and corresponding vectors *)", 
    "CodeComment"],
  "\n {nextEvals, nextEvecs} = \n      drumEigensystem[evDim, Shift -> L^2 \
nextEvalCenter[evalList]];\n ",
  StyleBox["(* align with last set of eigenvalues *)", "CodeComment"],
  "\n \[Delta]s = #.#& /@ ((Take[evalList, {-4, -1}] - #)& /@  \n             \
                   Partition[nextEvals, 4, 1]);\n minPos = \
Position[\[Delta]s, _?((# < 10^-6)&)];                        \n ",
  StyleBox["(* genuinely new eigenvalues *)", "CodeComment"],
  "\n newPosis = If[minPos =!= {{Length[\[Delta]s]}} && minPos =!= {}, \n     \
          {minPos[[1, 1]] + 4, Length[nextEvals]}, {}];\n newPosis === {}, ",
  StyleBox["(* in case of spectral gaps use additive shift *) ", 
    "CodeComment"],
  " \n                  evDim = Round[3/2 evDim]];\n ",
  StyleBox["(* update list of eigenvalues and sum of eigenvectors squared *)",
     "CodeComment"],
  "\n evalList = Join[evalList, Take[nextEvals, newPosis]];\n evecSum = \
evecSum + Plus @@ (Take[nextEvecs, newPosis]^2);\n If[Max[nextEvals] < (Pi/\
\[Lambda])^2, evecSumSmall = evecSum];\n ",
  StyleBox["(* use evalNumberMax lowest states *)", "CodeComment"],
  "\n Length[evalList] < evalNumberMax, Null]"
}], "Input"],

Cell["Length[evalList]", "Input"],

Cell["\<\
Here are the cumulative sums of the squares of the eigenfunctions \
for the first 135 and all 1000 eigenfunctions. These castles over the Koch \
curve show a flat Thomas\[Dash]Fermi interior density and pronounced spikes \
at the boundaries.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[
 Block[{DisplayFunction = Identity},
       eigenDVibration3DPlot[#, Boxed -> False]& /@ 
                               {evecSumSmall, evecSum}]]]\
\>", "Input"],

Cell[TextData[{
  "For the visualization of the Weyl\[Dash]Berry law, we subtract the leading \
term ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{
            RowBox[{"A", "/", 
              RowBox[{"(", 
                RowBox[{"4", "\[Pi]"}], ")"}]}], " ", 
            SuperscriptBox["\[Omega]", "2"]}],
          AutoStyleOptions->{"UnmatchedBracketStyle"->None}], 
        TraditionalForm]]],
  " to obtain a less steep curve."
}], "Text"],

Cell["\<\
{drumBoundaryLength, drumArea} = 
  {Plus @@ (Sqrt[#.#]& /@ (Subtract @@@ drumEdges)),
   Plus @@ (Sqrt[#.#]^2& /@ (Subtract @@@ (#[[2, 1]]& /@ \
allInnerSquares)))}\
\>", "Input"],

Cell[TextData[{
  "The following graphic shows that the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"c", " ", 
          SuperscriptBox["\[Omega]", "d"]}], TraditionalForm]]],
  " term is a good approximation for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Omega]", "\[LessTilde]", 
          RowBox[{"0.9", " ", "2", 
            RowBox[{"\[Pi]", "/", "\[Lambda]"}]}]}], TraditionalForm]]],
  " and the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"a", " ", "/", 
            RowBox[{"(", 
              RowBox[{"4", "\[Pi]"}], ")"}]}], "\[Omega]"}], 
        TraditionalForm]]],
  " term for larger ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "Homolya03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Homolya03",
    ButtonStyle->"Hyperlink"],
  "]",
  ". The fitted exponent agrees well with fractal dimension 1.5 of the Koch \
drum."
}], "Text"],

Cell[TextData[{
  StyleBox["(* subtract volume term *)", "CodeComment"],
  "\n\[CapitalDelta]IDOS = MapIndexed[{#1, -(#2[[1]] - 1/Pi #1^2)}&, \
Sqrt[evalList]];\n",
  StyleBox["(* fit exponent *)", "CodeComment"],
  "\nFindFit[Select[\[CapitalDelta]IDOS, #[[1]] < 22&], a x^b, {{a, 0.6}, {b, \
1.5}}, x]"
}], "Input"],

Cell["\<\
Show[Graphics[{
{Hue[0], Thickness[0.002], Line[Table[{\[Omega], 0.57 \[Omega]^(3/2)}, {\
\[Omega], 0, 40}]]},
{Hue[0.8], Thickness[0.002], Line[Table[{\[Omega], 32/(4Pi) \[Omega]}, {\
\[Omega], 0, 60}]]},
{GrayLevel[0], PointSize[0.006], Point /@ \[CapitalDelta]IDOS}}], 
     Frame -> True, PlotRange -> All, FrameLabel -> {\"\[Omega]\", \
\"\[Delta]IDOS\"}]\
\>", "Input"],

Cell[TextData[{
  "For a boundary with more corners, we should take into account \
contributions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "/", 
          RowBox[{"(", 
            RowBox[{"128", " ", 
              SuperscriptBox["\[Pi]", "2"]}], ")"}]}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "2"}], TraditionalForm]]],
  " corners and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"-", "5"}], "/", 
          RowBox[{"(", 
            RowBox[{"1152", 
              SuperscriptBox["\[Pi]", "2"]}], ")"}]}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"3", "/", "2"}], "\[Pi]"}], TraditionalForm]]],
  " corners ",
  "[",
  
  CounterBox["BibliographyCounter", "Baltes76"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Baltes76",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
We continue with the visualization of the absolute values of the \
gradients for the lowest eigenstates. We use again the finite difference \
approximations derived above, this time for the first derivative. We now use \
noncentered finite difference formulas.\
\>", "Text"],

Cell[TextData[{
  "grad1DValue[vertex_, dir_, maxStencilWidth_, evec_] :=\nModule[{jL, jR, j, \
\[Alpha], sData, swl, vcs}, \n",
  StyleBox["(* special rule for boundary vertices *)", "CodeComment"],
  "\nIf[isBoundaryVertexQ[vertex],\n   Which[isBoundaryVertexQ[vertex + L \
dir] || \n         isBoundaryVertexQ[vertex - L dir], {jL, jR} = {0, 0},\n    \
     isInnerDVertexQ[vertex + L dir], {jL, jR} = {0, maxStencilWidth}, \n     \
    isInnerDVertexQ[vertex - L dir], {jL, jR} = {maxStencilWidth, 0}],\n",
  StyleBox["(* go to the left and the right of an inner vertex *)\n", 
    "CodeComment"],
  "{jL, jR} = (j = 1; While[nextVertex = vertex + # j L dir;\n                \
         j <= maxStencilWidth + 1 && \n                         \
isInnerDVertexQ[nextVertex], j++]; \n            j - 1)& /@ {-1, +1};     \n \
\[Alpha] = (maxStencilWidth - 1)/2; \n ",
  StyleBox["(* use maxStencilPoints *)", "CodeComment"],
  "\n Which[jL > \[Alpha] && jR > \[Alpha], {jL, jR} = {\[Alpha], \[Alpha]},\n\
       jL + jR > maxStencilWidth,\n       If[jR >= jL, \n          jL = Min[\
\[Alpha], jL]; jR = maxStencilWidth - jL,\n          jR = Min[\[Alpha], jR]; \
jL = maxStencilWidth - jR]]]; \n",
  StyleBox[" (* the weight vector *)", "CodeComment"],
  "\n swl = stencilWeightList[1][jL, jR];\n ",
  StyleBox["(* approximate value of the 1D derivative *)", "CodeComment"],
  "\n vcs = Table[vertexDNumber[vertex + j L dir], {j, -jL, jR}] /.\n         \
                                  _vertexDNumber :> 0;\n ",
  StyleBox["(* deal special with boundary vertices *)", "CodeComment"],
  "\n Which[{jL, jR} === {0, 0}, 0, \n       vcs[[+1]] === 0, \
Rest[swl].evec[[Rest[vcs]]],\n       vcs[[-1]] === 0, \
Most[swl].evec[[Most[vcs]]],\n       True, swl.evec[[vcs]]]]"
}], "Input"],

Cell["\<\
gradValue[vertex_, maxStencilWidth_, evec_] := Sqrt[#.#]& @
{grad1DValue[vertex, {1, 0}, maxStencilWidth, evec],
 grad1DValue[vertex, {0, 1}, maxStencilWidth, evec]}\
\>", "Input"],

Cell[TextData[{
  "Given a list of the absolute values of the gradient vector at the inner \
vertices of the Koch drum, the function ",
  StyleBox["eigenVibrationGrad3DPlot", "MR"],
  " makes a 3D plot of the values over the Koch drum domain."
}], "Text"],

Cell["\<\
eigenVibrationGrad3DPlot[gradInnerVector_, gradBoundaryVector_, \
opts___] :=
     drum3DPlot[Function[v, Append[v, If[isInnerDVertexQ[v], 
                     gradInnerVector[[vertexDNumber[v]]], 
                     gradBoundaryVector[[boundaryVertexNumber[v]]]]]]]\
\>", \
"Input"],

Cell[TextData[{
  "Here are the magnitudes of the gradients for the four lowest states. The \
gradients have singularities due to the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"270", "\[Degree]"}], TraditionalForm]]],
  " corners of the Koch curve at some points [",
  
  CounterBox["BibliographyCounter", "Russ02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Russ02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Yosibash98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Yosibash98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Wigley72"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wigley72",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Kuttler84"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kuttler84",
    ButtonStyle->"Hyperlink"],
  "] (for better discretizations near corners, see [",
  
  CounterBox["BibliographyCounter", "Hauswirth00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hauswirth00",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Yosibash98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Yosibash98",
    ButtonStyle->"Hyperlink"],
  "]",
  ")."
}], "Text"],

Cell[TextData[{
  StyleBox["(* turn of message for low order finite differences *)", 
    "CodeComment"],
  "\nOff[NDSolve`FiniteDifferenceDerivative::aord];\n\
Off[NDSolve`FiniteDifferenceDerivative::nonopt];\n\nShow[GraphicsArray[#]]& \
/@ \nPartition[eigenVibrationGrad3DPlot[\n \
Table[gradValue[vertexDCoordinates[k], 7, evecsD7Low[[#]]], {k, dimD}],\n \
Table[gradValue[boundaryVertexCoordinates[k], 7, evecsD7Low[[#]]], \n       \
{k, Length[boundaryVertices]}]]& /@ {1, 2, 4, 5}, 2]"
}], "Input"],

Cell[TextData[{
  "We end with a small excursion into the world of eigenfunctions with \
Neumann boundary conditions [",
  
  CounterBox["BibliographyCounter", "Hobiki96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hobiki96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Russ97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Russ97",
    ButtonStyle->"Hyperlink"],
  "]. Now we have to take into account all boundary vertices too. This yields \
17409 vertices."
}], "Text"],

Cell["dimN = Length[allRefinedVertices];", "Input"],

Cell["\<\
Similar to the Dirichlet case, we define various functions for \
numbering and checking the type of a vertex.\
\>", "Text"],

Cell["\<\
Do[vertexNNumber[allRefinedVertices[[k]]] = k;
   vertexNCoordinates[k] = allRefinedVertices[[k]];
   isInnerNVertex[allRefinedVertices[[k]]] = True, {k, dimN}];
   
isInnerNVertexQ[vertex_] := isInnerNVertexQ[vertex] = 
                            TrueQ[isInnerNVertex[vertex]]\
\>", "Input"],

Cell["\<\
This time, we also differentiate between horizontal and vertical \
edges.\
\>", "Text"],

Cell["\<\
horizontalEdges = Select[drumEdges, #[[1, 2]] == #[[2, 2]]&];
verticalEdges   = Select[drumEdges, #[[1, 1]] == #[[2, 1]]&];\
\>", "Input"],

Cell["\<\
{horizontalBoundaryVertices, verticalBoundaryVertices} = 
Union[Flatten[Table[#1 + j/rL (#2 - #1), {j, 0, rL}]& @@@ #, 1]]& /@ 
{horizontalEdges, verticalEdges};\
\>", "Input"],

Cell["\<\
Do[isHorizontalBoundaryVertex[horizontalBoundaryVertices[[k]]] = \
True, 
   {k, Length[horizontalBoundaryVertices]}];
   
Do[isVerticalBoundaryVertex[verticalBoundaryVertices[[k]]] = True, 
   {k, Length[verticalBoundaryVertices]}];   
   
isHorizontalBoundaryVertexQ[vertex_] := isHorizontalBoundaryVertexQ[vertex] = \

TrueQ[isHorizontalBoundaryVertex[vertex]]

isVerticalBoundaryVertexQ[vertex_] := isVerticalBoundaryVertexQ[vertex] = 
TrueQ[isVerticalBoundaryVertex[vertex]]\
\>", "Input"],

Cell["\<\
isBoundaryVertexQ[dir_, vertex_] := isBoundaryVertexQ[dir, vertex] \
= 
Which[Abs[dir] === {1, 0}, isVerticalBoundaryVertexQ[vertex],
      Abs[dir] === {0, 1}, isHorizontalBoundaryVertexQ[vertex]]\
\>", "Input"],

Cell["\<\
For the construction of the matrix to be diagonalized, we proceed \
largely as in the Dirichlet case. But this time, we continue the function \
symmetrically across the boundary vertices to ensure Neumann boundary \
conditions. We again use a stencil of length 7.\
\>", "Text"],

Cell[TextData[{
  "nonVanishingNMatrixElements = addVertexWeights @\nModule[{maxStencilSize = \
7, \[Alpha], swl, centerVertex, jB},\n\[Alpha] = (maxStencilSize - 1)/2;\nswl \
= -stencilWeightList[2][\[Alpha], \[Alpha]];\n(tab = Table[centerVertex = \
allRefinedVertices[[k]]; \n       {{k, k} -> 2 swl[[\[Alpha] + 1]],\n        \
Function[dir, jB =.;\n        If[isBoundaryVertexQ[dir, centerVertex], jB = \
0];\n        Table[nextVertex = centerVertex + j L dir; \n              \
Which[isInnerNVertexQ[nextVertex], \n                    \
If[isBoundaryVertexQ[dir, nextVertex], jB = j];\n                    {k, \
vertexNNumber[nextVertex]} -> swl[[\[Alpha] + 1 + j]],\n                    \
True, ",
  StyleBox["(* continue symmetrically *", "CodeComment"],
  ")\n                    reflectedVertex = centerVertex + jB L dir - (j - \
jB) L dir;\n                    {k, vertexNNumber[reflectedVertex]} -> \n     \
                                   +swl[[\[Alpha] + 1 + j]]], \n              \
      {j, 1, \[Alpha]}]] /@ ",
  StyleBox["(* horizontal and vertical neighbors *)", "CodeComment"],
  "\n                    {{+1, 0}, {-1, 0}, {0, 1}, {0, -1}}},",
  StyleBox[" \n                    (* all inner vertices *) ", 
    "CodeComment"],
  "{k, dimN}]) // Flatten];"
}], "Input"],

Cell["\<\
We form the sparse matrix of dimension 17409\[Times]17409 with \
214005 nonvanishing elements.\
\>", "Text"],

Cell["MN7 = SparseArray[nonVanishingNMatrixElements]", "Input"],

Cell[TextData[{
  "Unfortunately, because of the symmetric continuation, the resulting matrix \
is not symmetric. (Using a discretization scheme that has discretization \
points shifted by ",
  Cell[BoxData[
      FormBox[
        RowBox[{"L", "/", "2"}], TraditionalForm]]],
  ", so that the boundary would lie in the middle between two points would \
result in a symmetric matrix [",
  
  CounterBox["BibliographyCounter", "Homolya03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Homolya03",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"],

Cell["Max[MN7 - Transpose[MN7]]", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["drumNEigensystem", "MR"],
  " calculates the eigenvalues and eigenfunctions of ",
  StyleBox["MN7", "MR"],
  ". This time we use a higher tolerance because the nonsymmetric nature of \
the matrix will result in numerically complex eigenvalues and \
eigenfunctions."
}], "Text"],

Cell["\<\
drumNEigensystem[n_, opts___] := MapAt[1/L^2 #&, Reverse /@ 
    Eigensystem[N[MN7], n, Method -> {\"Arnoldi\", opts, Tolerance -> 10^-12,
                BasisSize -> 20 n, MaxIterations -> 10^4}], 1]\
\>", "Input"],

Cell[TextData[{
  "Here are a few of the states. The lowest eigenvalue is basically zero, \
reflecting the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"u", "(", 
            RowBox[{"x", ",", "y"}], ")"}], "=", 
          StyleBox["constant",
            FontSlant->"Italic"]}], TraditionalForm]]],
  " solution. As expected, some eigenvalues have small imaginary parts."
}], "Text"],

Cell["\<\
{evalsN7Low, evecsN7Low} = drumNEigensystem[12, Shift -> 0]; 
evalsN7Low\
\>", "Input"],

Cell[TextData[{
  "We visualize the eigenfunctions using the routine ",
  StyleBox["eigenNVibration3DPlot", "MR"],
  ". This time, we do not show the drum outline, because the functions do not \
vanish on the boundary."
}], "Text"],

Cell[TextData[{
  StyleBox["(* plot Neumann eigenfunctions *)", "CodeComment"],
  "\neigenNVibration3DPlot[evec_, opts___] :=\nWith[{ev = Re[evec]}, \
DeleteCases[#, _Line, Infinity]& @\n     drum3DPlot[Function[v, Append[v, \
ev[[vertexNNumber[v]]]]], opts,\n                Boxed -> False, PlotRange -> \
1.01 Max[Abs[ev]] {-1, 1}]]"
}], "Input"],

Cell["Here are the first few eigenfunctions.", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Partition[
             eigenNVibration3DPlot /@ evecsN7Low[[{1, 2, 4, 5, 6, 12}]], 3]\
\
\>", "Input"],

Cell["\<\
And here are three slightly higher states that are prominently \
localized in the four bays.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[eigenNVibration3DPlot /@
              drumNEigensystem[3, Shift -> 98.8646\[InvisibleSpace] \
L^2][[2]]]]\
\>", "Input"],

Cell[TextData[{
  "We end here and leave it to the reader to explore more of the world of \
eigenvalues and eigenfunctions of 2D domains with fractal boundaries. One \
could now continue and investigate the distribution of the eigenvalue \
spacings, and the distribution of the eigenfunction values [",
  
  CounterBox["BibliographyCounter", "Russ01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Russ01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "McDonald88"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"McDonald88",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Shigehara94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Shigehara94",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Hlushchuk03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hlushchuk03",
    ButtonStyle->"Hyperlink"],
  "]. One could calculate and analyze the eigensystems of triangular Koch \
drums [",
  
  CounterBox["BibliographyCounter", "Lapidus96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lapidus96",
    ButtonStyle->"Hyperlink"],
  "] (which are slightly less interesting, because the bay areas are less \
pronounced and so the eigenfunctions can not reach them easily) and other \
shapes (for instance the areas bounded by some of the space\[Hyphen]filling \
Peano and Hilbert curves). (For experimental results on fractal Koch drums, \
see [",
  
  CounterBox["BibliographyCounter", "Sapoval89"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sapoval89",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Sapoval91"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sapoval91",
    ButtonStyle->"Hyperlink"],
  "]; for classical paths in square Koch drums, see [",
  
  CounterBox["BibliographyCounter", "Lyubomudrov03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lyubomudrov03",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  8.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Duffing Oscillator Wigner Function"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider a quantum version of the undamped Duffing oscillator (a forced, \
friction\[Hyphen]free anharmonic oscillator [",
  
  CounterBox["BibliographyCounter", "Balcou96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Balcou96",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Englisch91"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Englisch91",
    ButtonStyle->"Hyperlink"],
  "]",
  ")"
}], "InlineFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"i", " ", "\[HBar]", " ", 
          FractionBox[
            RowBox[{"\[PartialD]", 
              RowBox[{"\[Psi]", "(", 
                RowBox[{"x", ",", "t"}], ")"}]}], 
            RowBox[{"\[PartialD]", "t"}]]}], "=", 
        RowBox[{
          RowBox[{
            RowBox[{"-", 
              FractionBox[
                SuperscriptBox["\[HBar]", "2"], 
                RowBox[{"2", "m"}]]}], 
            FractionBox[
              RowBox[{
                SuperscriptBox["\[PartialD]", "2"], 
                RowBox[{"\[Psi]", "(", 
                  RowBox[{"x", ",", "t"}], ")"}]}], 
              RowBox[{"\[PartialD]", 
                SuperscriptBox["t", "2"]}]]}], "+", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{"\[Alpha]", " ", 
                  SuperscriptBox["x", "4"]}], "-", 
                RowBox[{"\[Beta]", " ", 
                  SuperscriptBox["x", "2"]}], "-", 
                RowBox[{"\[Gamma]", " ", "x", " ", 
                  RowBox[{"cos", "(", 
                    RowBox[{"\[Omega]", " ", "t"}], ")"}]}]}], ")"}], 
            RowBox[{"\[Psi]", "(", 
              RowBox[{"x", ",", "t"}], ")"}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "with minimum uncertainty wave packet initial condition, localized around \
",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "0"], TraditionalForm]]],
  " with mean momentum ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "0"], TraditionalForm]]]
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[Psi]", "(", 
          RowBox[{"x", ",", "0"}], ")"}], "=", 
        RowBox[{
          FractionBox["1", 
            SqrtBox[
              RowBox[{
                SqrtBox[
                  RowBox[{"2", " ", "\[Pi]"}]], " ", 
                SubscriptBox["\[Sigma]", "x"]}]]], 
          RowBox[{
            RowBox[{"exp", "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox[
                    SuperscriptBox[
                      RowBox[{"(", 
                        RowBox[{"x", "-", 
                          SubscriptBox["x", "0"]}], ")"}], "2"], 
                    RowBox[{"4", " ", 
                      SubsuperscriptBox["\[Sigma]", "x", "2"]}]]}], "+", 
                FractionBox[
                  RowBox[{"i", " ", 
                    SubscriptBox["p", "0"], " ", "x"}], "\[HBar]"]}], ")"}], 
            "."}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For the parameters ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", 
          RowBox[{"1", "/", "2"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Beta]", "=", "10"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", "=", "10"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Omega]", "=", "6"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["x", "0"], "=", 
          RowBox[{"-", "3"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "0"], "=", "10"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Sigma]", "x"], "=", 
          RowBox[{"1", "/", "4"}]}], TraditionalForm]]],
  ", solve the Schr\[ODoubleDot]dinger equation over a few periods ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", 
          RowBox[{"\[Pi]", "/", "\[Omega]"}]}], TraditionalForm]]],
  " and visualize the resulting ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{"\[LeftBracketingBar]", 
            RowBox[{"\[Psi]", "(", 
              RowBox[{"x", ",", "t"}], ")"}], "\[RightBracketingBar]"}], "2"],
         TraditionalForm]]],
  " for some ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[HBar]", "<", "1"}], TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Habib98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Habib98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Zurek03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Greenbaum04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Greenbaum04",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell[TextData[{
  "Make an animation of the corresponding Wigner distribution ",
  "[",
  
  CounterBox["BibliographyCounter", "Bayfield99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bayfield99",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"W", "(", " ", 
          RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}], "=", 
        RowBox[{
          FractionBox["1", 
            RowBox[{"2", "\[Pi]", " ", "\[HBar]"}]], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", 
              RowBox[{"-", "\[Infinity]"}], "\[Infinity]"], 
            RowBox[{
              SuperscriptBox["e", 
                RowBox[{"i", " ", 
                  FractionBox["p", "\[HBar]"], " ", "y"}]], 
              RowBox[{"\[Psi]", "(", 
                RowBox[{
                  RowBox[{"x", "-", 
                    FractionBox["y", "2"]}], ",", "t"}], ")"}], 
              OverscriptBox[
                RowBox[{"\[Psi]", "(", 
                  RowBox[{
                    RowBox[{"x", "+", 
                      FractionBox["y", "2"]}], ",", "t"}], ")"}], "_"], "d", 
              "\[InvisibleSpace]", "y"}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "as a function of ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  ". Color regions of positive and negative ",
  Cell[BoxData[
      FormBox[
        RowBox[{"W", "(", " ", 
          RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}], TraditionalForm]]],
  " differently. ",
  Cell[BoxData[
      FormBox[
        RowBox[{"W", "(", " ", 
          RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}], TraditionalForm]]],
  " obeys the differential equation ",
  "[",
  
  CounterBox["BibliographyCounter", "Bolivar04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bolivar04",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        FractionBox[
          RowBox[{"\[PartialD]", " ", 
            RowBox[{"W", "(", " ", 
              RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}]}], 
          RowBox[{"\[PartialD]", "t"}]], "=", 
        RowBox[{
          RowBox[{
            RowBox[{"-", 
              FractionBox["p", "m"]}], 
            FractionBox[
              RowBox[{"\[PartialD]", " ", 
                RowBox[{"W", "(", " ", 
                  RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}]}], 
              RowBox[{"\[PartialD]", "x"}]]}], "-", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{"2", "\[Beta]", " ", "x"}], "-", 
                RowBox[{"4", " ", "\[Alpha]", " ", 
                  SuperscriptBox["x", "3"]}], "+", 
                RowBox[{"\[Gamma]", " ", 
                  RowBox[{"cos", "(", 
                    RowBox[{"\[Omega]", " ", "t"}], ")"}]}]}], ")"}], 
            FractionBox[
              RowBox[{"\[PartialD]", " ", 
                RowBox[{"W", "(", " ", 
                  RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}]}], 
              RowBox[{"\[PartialD]", "p"}]]}], "+", 
          RowBox[{
            SuperscriptBox["\[HBar]", "3"], 
            FractionBox["\[Alpha]", "8"], " ", "x", 
            RowBox[{
              FractionBox[
                RowBox[{
                  SuperscriptBox["\[PartialD]", "3"], " ", 
                  RowBox[{"W", "(", " ", 
                    RowBox[{"x", ",", "p", ",", " ", "t"}], ")"}]}], 
                RowBox[{"\[PartialD]", 
                  SuperscriptBox["p", "3"]}]], "."}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell["\<\
For the corresponding classical Duffing oscillator with the \
equation of motion\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SuperscriptBox["x", "\[DoublePrime]"], "(", "t", ")"}], "-", 
          RowBox[{"2", "\[Beta]", " ", 
            RowBox[{"x", "(", "t", ")"}]}], "+", 
          RowBox[{"4", " ", "\[Alpha]", " ", 
            SuperscriptBox[
              RowBox[{"x", "(", "t", ")"}], "3"]}]}], "=", 
        RowBox[{"\[Gamma]", " ", 
          RowBox[{"cos", "(", 
            RowBox[{"\[Omega]", " ", "t"}], ")"}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "model the time\[Hyphen]evolution for ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "6"], TraditionalForm]]],
  " particles with initial position\[Hyphen]momentum distribution according \
to the above ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Psi]", "(", 
          RowBox[{"x", ",", "0"}], ")"}], TraditionalForm]]],
  ". Make a corresponding animation of the time\[Hyphen]evolution of the \
classical ensemble."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with the quantum version of the problem. ",
  StyleBox["MinimumUncertaintyPacket", "MR"],
  " is a Gaussian minimal uncertainty packet with ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftAngleBracket]", "x", "\[RightAngleBracket]"}], "=", 
          SubscriptBox["x", "0"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftAngleBracket]", "p", "\[RightAngleBracket]"}], "=", 
          SubscriptBox["p", "0"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftAngleBracket]", 
            RowBox[{"x", "-", 
              RowBox[{"\[LeftAngleBracket]", "x", "\[RightAngleBracket]"}]}], 
            "\[RightAngleBracket]"}], "=", 
          SubscriptBox["\[Sigma]", "x"]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftAngleBracket]", 
            RowBox[{"p", "-", 
              RowBox[{"\[LeftAngleBracket]", "p", "\[RightAngleBracket]"}]}], 
            "\[RightAngleBracket]"}], "=", 
          RowBox[{
            SubscriptBox["\[Sigma]", "p"], "=", 
            RowBox[{"\[HBar]", "/", 
              RowBox[{"(", 
                RowBox[{"2", 
                  SubscriptBox["\[Sigma]", "x"]}], ")"}]}]}]}], 
        TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
MinimumUncertaintyPacket[{x0_, p0_, \[Sigma]x_}, \[HBar]_] = 
1/Sqrt[Sqrt[2 Pi] \[Sigma]x] Exp[-(x - x0)^2/(4 \[Sigma]x^2) + I p0 \
x/\[HBar]];\
\>", "Input"],

Cell["\<\
Next, we solve the Schr\[ODoubleDot]dinger equation for the Duffing \
potential. To obtain a numerically accurate solution, we use an eighth order \
difference scheme and a couple thousand spatial discretization points. In \
addition, we will use a precision and accuracy goal of about six.\
\>", "Text"],

Cell[TextData[{
  "DuffingSchr\[ODoubleDot]dingerSolution[{\[HBar]_, m_, \[Alpha]_, \[Beta]_, \
\[Gamma]_, \[Omega]_}, {x0_, p0_, \[Sigma]x_}, \n                           \
{L_, tMax_, pag_:5}, ppL_] :=\nNDSolve[{",
  StyleBox["(* Schr\[ODoubleDot]dinger equation *)", "CodeComment"],
  "\n         I \[HBar] D[\[Psi][x, t], t] == -\[HBar]^2/(2 m) D[\[Psi][x, \
t], {x, 2}] + \n                              (\[Alpha] x^4 - \[Beta] x^2 - \
\[Gamma] x Cos[\[Omega] t]) \[Psi][x, t],\n         ",
  StyleBox["(* minimum uncertainty initial wave packet *)", "CodeComment"],
  "\n         \[Psi][x, 0] == MinimumUncertaintyPacket[{x0, p0, \[Sigma]x}, \
\[HBar]], \n         ",
  StyleBox["(* Dirichlet boundary conditions *)", "CodeComment"],
  " \[Psi][-L, t] == 0, \[Psi][L, t] == 0},\n         \[Psi], {x, -L, L}, {t, \
0, tMax},\n        ",
  StyleBox["(* option for accurate solution *)", "CodeComment"],
  "\n         MaxSteps -> 10^5, PrecisionGoal -> pag, AccuracyGoal -> pag, \n \
        Method -> {\"MethodOfLines\",  Method -> StiffnessSwitching,\n        \
            \"SpatialDiscretization\" -> \n                    \
{\"TensorProductGrid\", \"DifferenceOrder\" -> 8,\n                     \
\"MaxPoints\" -> ppL, \"MinPoints\" -> ppL}}]"
}], "Input"],

Cell[TextData[{
  "For the parameters at hand, at ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "=", 
          RowBox[{"\[PlusMinus]", "8"}]}], TraditionalForm]]],
  " the value of the Duffing potential is always greater than 1300. Taking a \
WKB approximation for a free particle with momentum ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "0"], TraditionalForm]]],
  " and approximating the classical turning point to ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["x", "t"], "\[TildeTilde]", 
          RowBox[{"-", "5"}]}], TraditionalForm]]],
  ", this means that at ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "=", 
          RowBox[{"\[PlusMinus]", "8"}]}], TraditionalForm]]],
  ", the wave function is attenuated by more than 20 orders of magnitude \
compared with its maximal value inside the double well. So, we can safely set \
",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", 
            RowBox[{
              RowBox[{"x", "=", 
                RowBox[{"\[PlusMinus]", "8"}]}], ",", "t"}], ")"}], "=", 
          "0"}], TraditionalForm]]],
  ". Next, we declare the values of the parameters we will use in the \
following as globally visible variables. We follow the time\[Hyphen]evolution \
of the packet for seven/eight periods."
}], "Text"],

Cell[TextData[{
  StyleBox["(* system phase space sizes *)", "CodeComment"],
  " \nL = 8; P = 20; \n",
  StyleBox["(* \[HBar], m, and potential parameters *)", "CodeComment"],
  " \n\[HBar] = 1/3; m = 1; \[Alpha] = 1/2; \[Beta] = 10; \[Gamma] = 10;\n",
  StyleBox["(* wave packet parameters *)", "CodeComment"],
  " \nx0 = -3; p0 = 10; \[Sigma]x = 1/4; \[Sigma]p = \[HBar]/(2 \[Sigma]x);\n\
",
  StyleBox["(* external force and time parameters *)", "CodeComment"],
  " \n\[Omega] = 6; T = 2 Pi/\[Omega]; \[ScriptP] = 8; tMax = \[ScriptP] T;\n\
",
  StyleBox["(* animation and density plot parameters *)", "CodeComment"],
  "\nframesPerPeriod = 10; pp = 256;\n\[CapitalDelta]t = tMax/(\[ScriptP] \
framesPerPeriod);"
}], "Input"],

Cell["\<\
Using now 3600 spatial discretization points gives a solution less \
in than 30 minutes on a 2GHz computer.\
\>", "Text"],

Cell["\<\
(dsNDSol = DuffingSchr\[ODoubleDot]dingerSolution[{\[HBar], m, \
\[Alpha], \[Beta], \[Gamma], \[Omega]}, 
                                      {x0, p0, \[Sigma]x}, {L, tMax, 5.5}, \
3600]) // 
                                                                      Timing\
\
\>", "Input"],

Cell[TextData[{
  "The time\[Hyphen]dependent Duffing potential is a double well potential in \
which the depth/height of the two minima oscillates periodically. As a \
result, a wave function initially localized in one of the wells and having an \
average momentum comparable to the height of the middle wall of the \
potential, will quickly spread out over both wells. The following graphic \
shows this quite clearly. After each reflection as the outer potential walls, \
the wave function acquires a complicated interference pattern with the \
adiabatic bound state structure of the double well imprinted. (For the time\
\[Hyphen]development of localized states in a static double\[Hyphen]well \
potential, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Novaes03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Novaes03",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"],

Cell["\<\
DensityPlot[Evaluate[Abs[\[Psi][x, t]]^(1/4) /. dsNDSol[[1]]], 
            {x, -L, L}, {t, 0, tMax}, 
            PlotRange -> All, Mesh -> False, PlotPoints -> 600]\
\>", "Input"],

Cell[TextData[{
  "As a check for quality of solution, we check wether the wavefunction ",
  Cell[BoxData[
      FormBox["\[Psi]", TraditionalForm]]],
  " is still normalized to ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Integral]", 
              RowBox[{"-", "L"}], "L"], 
            RowBox[{
              RowBox[{"\[Psi]", "(", 
                RowBox[{"x", ",", "t"}], ")"}], 
              OverscriptBox[
                RowBox[{"\[Psi]", "(", 
                  RowBox[{"x", ",", "t"}], ")"}], "_"], " ", "d", 
              "\[InvisibleSpace]", "x"}]}], "=", "1"}], TraditionalForm]]],
  " at ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["t", "max"], TraditionalForm]]],
  ". At ",
  Cell[BoxData[
      FormBox[
        RowBox[{"t", "=", 
          RowBox[{"7", " ", "T"}]}], TraditionalForm]]],
  ", the deviation of the norm is less than 0.03%. Using precision and \
accuracy goal settings of 6, this error could be reduced to 0.01%. The \
visualizations to be created later would be visually identical, so we use the \
faster\[Hyphen]to\[Hyphen]process solution ",
  StyleBox["dsNDSol", "MR"],
  "."
}], "Text"],

Cell["\<\
NIntegrate[Evaluate[Abs[\[Psi][x, tMax]]^2 /. dsNDSol[[1]]], {x, \
-L, L},
           MaxRecursion -> 24, PrecisionGoal -> 10] // InputForm\
\>", "Input"],

Cell["\<\
For comparison, here is a time evolution that starts in one well \
and only slowly leaks out into the neighbor well.\
\>", "Text"],

Cell[TextData[{
  "DensityPlot[Evaluate[Abs[\[Psi][x, t]]^(1/4) /. \n",
  StyleBox["(* solve Schr\[ODoubleDot]dinger equation *)", "CodeComment"],
  "\n(DuffingSchr\[ODoubleDot]dingerSolution[\n  {0.326, 1, 0.929, 18.896, \
1.767, 1.420},  \n  {-1.503, 5.397, 0.476}, {7, 6, 3}, 1200])[[1]]], \n       \
     {x, -7, 7}, {t, 0, 6}, \n            PlotRange -> All, Mesh -> False, \
PlotPoints -> 600];"
}], "Input"],

Cell[TextData[{
  "To calculate the Wigner functions, we do not use directly its 2+1D \
differential equation, but rather use ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Psi]", "(", 
          RowBox[{"x", ",", "t"}], ")"}], TraditionalForm]]],
  " from above and perform a numerical Fourier transform. Given a wave \
functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Psi]", "(", 
          RowBox[{"x", ",", "t"}], ")"}], TraditionalForm]]],
  " for a fixed ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  ", the function ",
  StyleBox["\[CapitalPsi]ToW", "MR"],
  " generates an array of dimension ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "\[Times]",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  " that approximates the Wigner functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"W", "(", 
          RowBox[{"t", ",", "x", ",", "p"}], ")"}], TraditionalForm]]],
  " on an equidistant grid in ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "L"}], ",", "L"}], "]"}], "\[Times]", 
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "P"}], ",", "P"}], "]"}]}], TraditionalForm]]],
  ". To perform the numerical Fourier transform sufficiently accurate, we use \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", " ", "\[Lambda]"}], TraditionalForm]]],
  " points for the spatial discretization. With the notations ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["y", "r"], "=", 
          RowBox[{
            RowBox[{
              RowBox[{"-", "2"}], "L"}], "+", 
            RowBox[{"r", " ", 
              StyleBox[
                RowBox[{"\[CapitalDelta]", 
                  StyleBox["y",
                    "TI"]}]]}]}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["p", "s"], "=", 
          RowBox[{
            RowBox[{
              RowBox[{"-", "2"}], 
              SubscriptBox["P", "h"]}], "+", 
            RowBox[{"s", " ", 
              StyleBox[
                RowBox[{"\[CapitalDelta]", 
                  StyleBox["p",
                    FontSlant->"Italic"]}]]}]}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"r", "=", "1"}], ",", "\[Ellipsis]", ",", "n"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox[
            RowBox[{"\[CapitalDelta]", 
              StyleBox["y",
                "TI"]}]], 
          StyleBox["=",
            "TI"], 
          StyleBox[
            RowBox[{"4", 
              RowBox[{"L", "/", "n"}]}],
            "TI"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox[
            RowBox[{"\[CapitalDelta]", 
              StyleBox["p",
                "TI"]}]], 
          StyleBox["=",
            "TI"], 
          RowBox[{
            StyleBox["4",
              "TI"], 
            RowBox[{
              SubscriptBox[
                StyleBox["P",
                  "TI"], "h"], 
              StyleBox["/",
                "TI"], 
              StyleBox["n",
                "TI"]}]}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["P", "h"], "=", 
          RowBox[{"P", "/", "2"}]}], TraditionalForm]]],
  ", we have the following approximation of the Fourier transform through a \
discrete fractional Fourier transform ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          
          SubscriptBox["\[ScriptCapitalF]\[ScriptCapitalF]\[ScriptCapitalT]", 
            
            RowBox[{"{", 
              RowBox[{"\[Alpha]", ",", "\[Beta]"}], "}"}]], "[", 
          SubscriptBox[
            RowBox[{"{", 
              SubscriptBox["f", "r"], "}"}], 
            RowBox[{
              RowBox[{"r", "=", "1"}], ",", "\[Ellipsis]", ",", "n"}]], "]"}],
         TraditionalForm]]],
  "."
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{"F", "(", "p", ")"}], "=", 
        RowBox[{
          RowBox[{
            UnderoverscriptBox["\[Integral]", 
              RowBox[{"-", "\[Infinity]"}], "\[Infinity]"], 
            RowBox[{
              RowBox[{"exp", "(", 
                RowBox[{"i", 
                  FractionBox[
                    RowBox[{"p", " "}], "\[HBar]"], "y"}], ")"}], 
              RowBox[{"f", "(", "y", ")"}], "d", "\[InvisibleSpace]", "y"}]}],
           "\[TildeTilde]", 
          RowBox[{
            UnderoverscriptBox["\[Integral]", 
              RowBox[{
                RowBox[{"-", "2"}], "L"}], 
              RowBox[{"2", "L"}]], 
            RowBox[{
              RowBox[{"exp", "(", 
                RowBox[{"i", 
                  FractionBox[
                    RowBox[{"p", " "}], "\[HBar]"], "y"}], ")"}], 
              RowBox[{"f", "(", "y", ")"}], "d", "\[InvisibleSpace]", "y"}]}],
           "\[TildeTilde]", 
          RowBox[{
            StyleBox[
              RowBox[{"\[CapitalDelta]", 
                StyleBox["y",
                  "TI"]}]], 
            RowBox[{
              UnderoverscriptBox["\[Sum]", 
                RowBox[{"r", "=", "1"}], "n"], 
              RowBox[{
                RowBox[{"exp", "(", 
                  RowBox[{"i", 
                    FractionBox[
                      RowBox[{"p", " "}], "\[HBar]"], 
                    SubscriptBox["y", "r"]}], ")"}], 
                RowBox[{"f", "(", 
                  SubscriptBox["y", "r"], ")"}]}]}]}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{"F", "(", 
          SubscriptBox["p", "s"], ")"}], "=", 
        RowBox[{
          StyleBox[
            RowBox[{"\[CapitalDelta]", 
              StyleBox["y",
                "TI"]}]], " ", 
          SubscriptBox["A", "s"], 
          RowBox[{
            SubscriptBox[
              "\[ScriptCapitalF]\[ScriptCapitalF]\[ScriptCapitalT]", 
              RowBox[{"{", 
                RowBox[{"1", ",", 
                  FractionBox[
                    RowBox[{"4", " ", "L", " ", "P"}], 
                    RowBox[{"n", " ", "\[Pi]", " ", "\[HBar]"}]]}], "}"}]], 
            "[", 
            SubscriptBox[
              RowBox[{"{", 
                RowBox[{
                  SubscriptBox["B", "r"], 
                  RowBox[{"f", "(", 
                    SubscriptBox["y", "r"], ")"}]}], "}"}], 
              RowBox[{
                RowBox[{"r", "=", "1"}], ",", "\[Ellipsis]", ",", "n"}]], 
            "]"}]}]}], TraditionalForm]}], "DisplayFormula"],

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["A", "s"], "=", 
          RowBox[{"exp", "(", 
            RowBox[{"i", "/", 
              RowBox[{"\[HBar]", "(", " ", 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{"4", " ", "L", " ", 
                        SubscriptBox["P", "h"]}], "-", 
                      RowBox[{
                        StyleBox[
                          RowBox[{"\[CapitalDelta]", 
                            StyleBox["p",
                              FontSlant->"Italic"]}]], " ", 
                        StyleBox[
                          RowBox[{"\[CapitalDelta]", 
                            StyleBox["y",
                              "TI"]}]]}]}], ")"}], "-", " ", 
                  RowBox[{
                    StyleBox[
                      RowBox[{"\[CapitalDelta]", 
                        StyleBox["p",
                          FontSlant->"Italic"]}]], " ", 
                    RowBox[{"(", 
                      RowBox[{
                        RowBox[{"2", " ", "L"}], "-", 
                        StyleBox[
                          RowBox[{"\[CapitalDelta]", 
                            StyleBox["y",
                              "TI"]}]]}], ")"}], "s"}]}], ")"}]}], ")"}]}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["B", "r"], "=", 
          RowBox[{"exp", "(", 
            RowBox[{
              RowBox[{
                RowBox[{"-", "i"}], "/", "\[HBar]"}], " ", 
              RowBox[{"(", 
                RowBox[{
                  RowBox[{"2", " ", 
                    SubscriptBox["P", "h"]}], "-", 
                  StyleBox[
                    RowBox[{"\[CapitalDelta]", 
                      StyleBox["p",
                        FontSlant->"Italic"]}]]}], ")"}], " ", 
              StyleBox[
                RowBox[{"\[CapitalDelta]", 
                  StyleBox["y",
                    "TI"]}]], 
              StyleBox[" ",
                "TI"], "r"}], ")"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "Off[Fourier::fpopt2];\n\n\[CapitalPsi]ToW[\[CapitalPsi]_, {L_, P_}, \
\[HBar]_, d_, \[Lambda]_] :=\nModule[{\[ScriptD] = \[Lambda] d, Ph, \
\[CapitalDelta]y, \[CapitalDelta]p, b, As, Br, WMat, \[CapitalPsi]L, \
\[CapitalPsi]\[CapitalPsi]C, \n        tpa = Developer`ToPackedArray},\n ",
  StyleBox["(* fractional Fourier transform parameters *)\n ", 
    "CodeComment"],
  "Ph = P/2; \[CapitalDelta]y = 4L/\[ScriptD]; \[CapitalDelta]p = 4Ph/\
\[ScriptD]; b = 8. L Ph/(\[ScriptD] \[Pi] \[HBar]);\n Br = tpa[Table[Exp[-I/\
\[HBar] (2. Ph - \[CapitalDelta]p) \[CapitalDelta]y r], {r, \[ScriptD]}]];\n \
As = tpa[\[CapitalDelta]y Table[Exp[I/\[HBar] ((4. L Ph - \[CapitalDelta]p \
\[CapitalDelta]y) - \[CapitalDelta]p (2 L - \[CapitalDelta]y) s)], {s, \
\[ScriptD]}]];\n ",
  StyleBox["(* d\[Times]d matrix of Wigner function values *)", 
    "CodeComment"],
  "\n Table[",
  StyleBox["(* Fourier transform integrand *)", "CodeComment"],
  "\n       \[CapitalPsi]L = tpa[Table[\[CapitalPsi][N[x - y/2]], {y, -2L + \
4L/\[ScriptD], 2L, 4L/\[ScriptD]}]];\n       \[CapitalPsi]\[CapitalPsi]C = \
\[CapitalPsi]L Conjugate[Reverse[\[CapitalPsi]L]];\n       ",
  StyleBox["(* Wigner transform for fixed x *)", "CodeComment"],
  " \n       Wx = As Fourier[Br \[CapitalPsi]\[CapitalPsi]C, \
FourierParameters -> {1., b}];    \n       ",
  StyleBox["(* average over \[Lambda] p-values *)", "CodeComment"],
  "\n       1/(2.Pi \[HBar]) Plus @@@ Partition[Wx, \[Lambda]],             \n\
       {x, -L, L, 2L/(d - 1)}] // Transpose]"
}], "Input"],

Cell[TextData[{
  "To display the Wigner function, we use a density plot. The Wigner function \
is purely real, and we color positive parts in blue and negative parts in red \
",
  "[",
  
  CounterBox["BibliographyCounter", "Kenfack04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kenfack04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". The function ",
  StyleBox["rbColor", "MR"],
  " yields the color value for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "<", 
          StyleBox["xM",
            "TI"], "<", "x", "<", 
          StyleBox["xP",
            "TI"], ">", "0"}], TraditionalForm]]],
  ". For both the quantum and the classical distribution, we will use a \
rescaled version to obtain a better contrast."
}], "Text"],

Cell[TextData[{
  "rbColor[x_, {xM_, xP_}] := \nWith[{\[Xi] = x/Max[Abs[{xM, xP}]]},\n",
  StyleBox["(* negative values in red, positive values in blue; \n   scale \
with largest positive or negative value *)", "CodeComment"],
  "\nRGBColor[Min[If[x <= 0, 1, 1 - \[Xi]], 1], \n         Min[If[x <= 0, 1 - \
Abs[\[Xi]], 1 - Abs[\[Xi]]], 1], \n         Min[If[x >= 0, 1, -\[Xi] + 1], \
1]]]\n         \n",
  StyleBox["(* use a scaling to show details better *)", "CodeComment"],
  "\nscaleW[W_] := Sign[W] Abs[W]^(1/4);"
}], "Input"],

Cell[TextData[{
  "DuffingWignerGraphics[\[CapitalPsi]_, \[HBar]_, {L_, P_}, {d_, \[Alpha]_}, \
opts___] := \nModule[{WMat, xM, xP, WScaled},\n  ",
  StyleBox["(* form Wigner distribution from wave function *)", 
    "CodeComment"],
  "\n  WMat = \[CapitalPsi]ToW[\[CapitalPsi], {L, P}, \[HBar], d, \[Alpha]];\n\
  {xM, xP} = {Min[#], Max[#]}&[WScaled = scaleW[Re[WMat]]];\n  ",
  StyleBox["(*display colored scaled Wigner distribution *)", "CodeComment"],
  "\n  ListDensityPlot[WScaled, Mesh -> False, PlotRange -> All, \n           \
       MeshRange -> {{-L, L}, {-P, P}}, opts,\n                  \
ColorFunction -> (rbColor[#, {xM, xP}]&),\n                  \
ColorFunctionScaling -> False]]"
}], "Input"],

Cell[TextData[{
  "Later, we will show a side\[Hyphen]by\[Hyphen]side animation of the time\
\[Hyphen]evolution of the Wigner function and the classical distribution \
function. For now, we show a detailed plot of the Wigner function after three \
periods of the external force. The intermingled domains of red and blue show \
that the Wigner functions acquired a complicated inner structure already \
after thee periods of the driving force [",
  
  CounterBox["BibliographyCounter", "Berry79b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Berry79b",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Habib98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Habib98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Habib00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Habib00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Bhattacharya02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bhattacharya02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Zurek02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Monteoliva00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Monteoliva00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Monteoliva01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Monteoliva01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Cucchietti03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cucchietti03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Zurek03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Lu04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lu04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". The structures exist at a scale smaller than ",
  Cell[BoxData[
      FormBox["\[HBar]", TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Zurek01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Zurek03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Alonso03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Alonso03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Maitra00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Maitra00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Jordan01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Jordan01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Jacquod02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Jacquod02",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["\<\
\[CapitalPsi][x_] = If[Abs[x] > L, 0. + 0. I, Evaluate[dsNDSol[[1, \
1, 2]][x, 3 T]]];\
\>", "Input"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n",
  StyleBox["(* density and contour W == 0 graphics *)", "CodeComment"],
  "\n{#, ListContourPlot[",
  StyleBox["(* center part only *)", "CodeComment"],
  "\n                    Map[If[Abs[#] < 0.02, 0, #]&, #[[1]], {2}],\n        \
            Contours -> {0}, ContourShading -> False,\n                    \
FrameTicks -> None]}&[\n",
  StyleBox["(* the Wigner function density plot *)", "CodeComment"],
  "\nDuffingWignerGraphics[\[CapitalPsi], \[HBar], {8, 18}, {600, 8}, \
FrameTicks -> None]]]]]"
}], "Input"],

Cell["\<\
Now, we come to the classical counterpart. Here are the equations \
of motions for the Duffing oscillator.\
\>", "Text"],

Cell["\<\
NewtonDuffingEquations[{m_, \[Alpha]_, \[Beta]_, \[Gamma]_, \
\[Omega]_}, {x_, p_}, 
                       {x0s_, p0s_, t0_}] :=
  {x'[t] == p[t]/m, p'[t] == m (2 \[Beta] x[t] - 4 \[Alpha] x[t]^3 + \[Gamma] \
Cos[\[Omega] t]), 
   x[t0] == x0s, p[t0] == p0s}\
\>", "Input"],

Cell[TextData[{
  "The overall complexity of the motion of the Duffing oscillator becomes \
visible by following a set of particles with initial conditions on ellipses \
around the origin in phase space over only 1",
  Cell[BoxData[
      FormBox[
        FractionBox["1", "2"], TraditionalForm]]],
  " periods. The next graphic shows the resulting shapes of the initial \
ellipses ",
  "[",
  
  CounterBox["BibliographyCounter", "DeSerio03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"DeSerio03",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell[TextData[{
  "Module[{o = 24000, \[ScriptP] = ",
  StyleBox["(* 3/2 periods only *)", "CodeComment"],
  " 3/2, x0s, p0s, ndsol},\nShow[Graphics[\nTable[",
  StyleBox["(* solve equations of motion starting with \n         initial \
conditions on an ellipse around {x, p} = {0, 0} *)", "CodeComment"],
  "\n {x0s, p0s} = Transpose[Table[\[Mu] {3. Cos[\[CurlyPhi]], 6. m Sin[\
\[CurlyPhi]]}, \n                              {\[CurlyPhi], 0, 2Pi, \
2Pi/o}]];               \n ndsol = NDSolve[NewtonDuffingEquations[{m, \
\[Alpha], \[Beta], \[Gamma], \[Omega]}, \n                                    \
    {x, p}, {x0s, p0s, 0}] , \n                 {x, p}, {t, \[ScriptP] T, \
\[ScriptP] T}, \n                 PrecisionGoal -> 8, AccuracyGoal -> 8]; \n \
{Hue[0.78 (\[Mu] - 1/4)/(7/4 - 1/8)], \n  ",
  StyleBox["(* polygon bounding the evolved ellipse *)", "CodeComment"],
  "\n  Polygon[Transpose[{x[\[ScriptP] T], p[\[ScriptP] T]} /. ndsol[[1]]]]},\
\n{\[Mu], 7/4, 1/8, -1/8}]], AspectRatio -> 1]]"
}], "Input"],

Cell[TextData[{
  "We will use matrices of size ",
  Cell[BoxData[
      FormBox[
        RowBox[{"256", "\[Times]", "256"}], TraditionalForm]]],
  " for the classical and the quantum Wigner distribution. Larger ones are of \
course possible, but it will take longer to calculate their values. We will \
generate ten frames per period ",
  Cell[BoxData[
      FormBox["T", TraditionalForm]]],
  ", which allows for a reasonable smooth animation. Again, more frames are \
possible for the price of larger calculation timings."
}], "Text"],

Cell[TextData[{
  "As the classical analog of the Wigner function time\[Hyphen]evolution, we \
use ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "6"], TraditionalForm]]],
  " particles with initial positions and momenta according to the initial \
Wigner distribution. The function ",
  StyleBox["RandomArray", "MR"],
  " from the package ",
  StyleBox["Statistics`ContinuousDistributions`", "MR"],
  "generates arrays of normal distributed numbers quite quickly."
}], "Text"],

Cell["Needs[\"Statistics`ContinuousDistributions`\"];", "Input"],

Cell["\<\
{xDist, pDist} =  NormalDistribution @@@ {{x0, \[Sigma]x}, {p0, \
\[Sigma]p}};\
\>", "Input"],

Cell[TextData[{
  "To avoid the storage of the complete trajectory interpolants, we will \
solve the equations of motions over a time of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"T", "/", "8"}], TraditionalForm]]],
  " for 1000 particles at once, extract their final positions and momenta and \
keep a binned version of them in the matrices ",
  StyleBox["M[\[Tau]]", "MR"],
  " before continuing the solution of the differential equations over the \
next ",
  Cell[BoxData[
      FormBox[
        RowBox[{"T", "/", "8"}], TraditionalForm]]],
  " time interval. The function ",
  StyleBox["counterMatrix", "MR"],
  " generates a matrix of dimension ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["pp",
            "TI"], "\[Times]", 
          StyleBox["pp",
            "TI"]}], TraditionalForm]]],
  " of the binned position\[Hyphen]momentum values of a list of values ",
  StyleBox["xpList", "TI"],
  " within the square ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "L"}], ",", "L"}], "]"}], "\[Times]", 
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "P"}], ",", "P"}], "]"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "counterMatrix[xpList_, L_, P_, pp_] := \nModule[{xpDiscrete = Ceiling[pp \
((# + {L, P})/{2L, 2P}& /@ xpList)],\n        M0 = Table[0, {pp}, {pp}], i, \
j}, \n        Do[If[Min[xpDiscrete[[k]]] >= 1 && Max[xpDiscrete[[k]]] <= pp,\n\
              ",
  StyleBox["(* bin numbers *)", "CodeComment"],
  " {j, i} = xpDiscrete[[k]]];\n           M0[[i, j]] = M0[[i, j]] + 1, {k, \
Length[xpDiscrete]}]; M0]"
}], "Input"],

Cell["\<\
Following now one million trajectories over 8 periods of the \
driving force takes about 4 hours on a 2GHz computer. We will follow 1000 \
trajectories in parallel. This avoid the overhead of repeatedly processing \
the equations but does not use too much memory at one time.\
\>", "Text"],

Cell[TextData[{
  "Module[{o = 1000, \[Mu] = 1000, q = 100, x0s, p0s, xpList,\n        M0 = \
Developer`ToPackedArray[Table[0, {pp}, {pp}]]},\nDo[",
  StyleBox["(* initialize array for time \[Tau] *) ", "CodeComment"],
  "M[\[Tau]] = M0, {\[Tau], 0, tMax, \[CapitalDelta]t}];\n",
  StyleBox["(* bag for {x, p}-points *)", "CodeComment"],
  "\nxpBag = Table[{}, {j, \[Mu]}, {\[Tau], 0, tMax, \[CapitalDelta]t}];  \n\
Do[",
  StyleBox["(* list of initial {x, p}-points *)", "CodeComment"],
  "\n   xpList = Transpose[RandomArray[#, {o}]& /@ {xDist, pDist}];           \
         \n   ",
  StyleBox["(* add values for j-th batch *) ", "CodeComment"],
  "\n   M[0] = M[0] + counterMatrix[xpList, L, P, pp];   \n   xpBag[[j, 1]] = \
Take[xpList, q];         \n   ",
  StyleBox["(* solve ode for t-interval {0, tMax} in steps of \
T/framesPerPeriod *)", "CodeComment"],
  "\n   Do[{x0s, p0s} = Transpose[xpList];\n      ndsol = \
NDSolve[NewtonDuffingEquations[{m, \[Alpha], \[Beta], \[Gamma], \[Omega]}, \
{x, p}, \n                      {x0s, p0s, \[Tau] - \[CapitalDelta]t}], {x, \
p}, {t, \[Tau], \[Tau]},\n                      PrecisionGoal -> 8, \
AccuracyGoal -> 8];\n      ",
  StyleBox["(* update matrices *)", "CodeComment"],
  "\n      xpList = Transpose[{x[\[Tau]], p[\[Tau]]} /. ndsol[[1]]];\n      \
M[\[Tau]] = M[\[Tau]] + counterMatrix[xpList, L, P, pp];\n      ",
  StyleBox["(* collect unbinned *)", "CodeComment"],
  "\n      xpBag[[j, \[Tau]/\[CapitalDelta]t + 1]] = Take[xpList, q], \
{\[Tau], \[CapitalDelta]t, tMax, \[CapitalDelta]t}], \n   {j, \[Mu]}]]; // \
Timing"
}], "Input"],

Cell[TextData[{
  "Here are the first 50 particles of each run shown in one graphic. To color \
indicates the time, ranging from red (",
  Cell[BoxData[
      FormBox[
        RowBox[{"t", "=", "0"}], TraditionalForm]]],
  ") to violet (",
  Cell[BoxData[
      FormBox[
        RowBox[{"t", "=", 
          RowBox[{
            SubscriptBox["t", "max"], "=", 
            RowBox[{"8", "T"}]}]}], TraditionalForm]]],
  "). The originally localized cloud of particles follows an extremely \
complicated dynamics with positive Lyapunov coefficient. After a few periods, \
the resulting distribution has a complicated, repeatedly folded\[Hyphen]over \
structure."
}], "Text"],

Cell["\<\
Show[Graphics[Reverse @
  Table[{PointSize[0.002], Hue[0.78 \[Tau]/tMax], 
               Map[Point, Transpose[xpBag][[\[Tau]/\[CapitalDelta]t + 1]], \
{-2}]},
        {\[Tau], \[CapitalDelta]t, tMax, \[CapitalDelta]t}]]]\
\>", "Input"],

Cell[TextData[{
  "Now, we have all data together to display the animation of the time\
\[Hyphen]development of the classical and quantum distribution in parallel. \
The function ",
  StyleBox["classicQuantumDistributionsGraphicsArray", "MR"],
  " generates and displays a graphics array of the two distribution functions \
for a given ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "classicQuantumDistributionsGraphicsArray[\[Tau]_] := \nModule[{L = 8, P = \
20, \[Lambda] = 12, \[CapitalPsi]},\nShow[GraphicsArray[\n\
Block[{$DisplayFunction = Identity},\n {",
  StyleBox["(* classical  phase space distribution *)", "CodeComment"],
  "\n  ListDensityPlot[",
  StyleBox["(* scale *)", "CodeComment"],
  " M[\[Tau]]^(1/4), Mesh -> False, PlotRange -> All,\n                  \
MeshRange -> {{-L, L}, {-P, P}},  FrameTicks -> None,\n                  ",
  StyleBox["(* density proportional \"blueness\" *)", "CodeComment"],
  "\n                  ColorFunction -> (RGBColor[1 - #, 1 - #, 1]&)],\n ",
  StyleBox["(* Wigner distribution *)", "CodeComment"],
  "    \n ",
  StyleBox["(* re-interpolate for fixed \[Tau] for faster value access *)", 
    "CodeComment"],
  "   \n \[CapitalPsi]T = FunctionInterpolation[Evaluate[If[Abs[x] > L, 0. + \
0. I, \n                                       Evaluate[dsNDSol[[1, 1, 2]][x, \
\[Tau]]]]], \n                            {x, -2L, 2L}, \
InterpolationPrecision -> 8,\n                            InterpolationPoints \
-> 8192, \n                            InterpolationOrder -> 6];\n (\
\[ScriptCapitalM][\[Tau]] = (Sign[#] #^4)&[#[[1]]]; #)& @\n \
DuffingWignerGraphics[\[CapitalPsi]T, \[HBar], {L, P}, {pp, \[Lambda]}, \
FrameTicks -> None]}]]]]           "
}], "Input"],

Cell[TextData[{
  "Using now the ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  "\[Hyphen]values for which previously a snapshot of the classical \
distribution had been calculated, we arrive at the following animation. "
}], "Text"],

Cell[TextData[{
  "Do[If[",
  StyleBox["(* show only every tenth step *)", "CodeComment"],
  " IntegerQ[\[Tau]/\[CapitalDelta]t/10], \n      \
classicQuantumDistributionsGraphicsArray[\[Tau]],\n      \
Block[{$DisplayFunction = Identity}, \n            \
classicQuantumDistributionsGraphicsArray[\[Tau]]]], \n   {\[Tau], 0, tMax, \
\[CapitalDelta]t}];"
}], "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          
          FrontEnd`FileName[ {"Animations"}, 
            "WSA_QuantumClassicalDuffingOscillator.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Do[classicQuantumDistributionsGraphicsArray[\[Tau]], {\[Tau], 0, \
tMax, \[CapitalDelta]t}];\
\>", "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "The animation shows how increasingly complicated structures form in the \
Wigner distribution. As mentioned above, the resulting structures appear at a \
scale much smaller than ",
  Cell[BoxData[
      FormBox["\[HBar]", TraditionalForm]]],
  ". While the phase space distributions look quite different after already a \
few periods, the corresponding marginal distributions for ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["p", TraditionalForm]]],
  " are much more similar to each other. The following two graphic pairs show \
the marginal distributions for the position and the momentum for the \
classical and the quantum case."
}], "Text"],

Cell["\<\
Function[M\[ScriptCapitalM], Show[GraphicsArray[
ListPlot3D[Table[Plus @@ #1[M\[ScriptCapitalM][\[Tau]]], {\[Tau], 0, tMax, \
\[CapitalDelta]t}], 
           Mesh -> False, PlotRange -> All, Axes -> False,
           PlotLabel -> #2, DisplayFunction -> Identity]& @@@
           {{Identity, \"x\"}, {Transpose, \"p\"}}]]] /@ {M, \
\[ScriptCapitalM]}\
\>", "Input"],

Cell[TextData[{
  "And the averages of the positions and momentums do agree even better with \
each other. Only for times larger than the calculated ones will they start to \
deviate substantially. This means that the larger times displayed are in the \
order of the Ehrenfest time of the system [",
  
  CounterBox["BibliographyCounter", "Habib00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Habib00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Karkuszewski00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Karkuszewski00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Silvestrov03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Silvestrov03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Casati96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Casati96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Cuccietti02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cuccietti02",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Cametti02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cametti02",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
With[{T = Range[256]},
Show[GraphicsArray[ Function[{f, l},
Graphics[{{Hue[#1], Line[MapIndexed[{#2[[1]], #1}&, #/#[[1]]&[
                          Table[T.(Plus @@ f[#2[\[Tau]]]), {\[Tau], 0, tMax, \
\[CapitalDelta]t}]]]]}& @@@
                                {{0.78, M}, {0.00, \[ScriptCapitalM]}}}, 
         Frame -> True, FrameTicks -> None, PlotLabel -> l]] @@@ 
         {{Identity, \"x\"}, {Transpose, \"p\"}}]]]\
\>", "Input"],

Cell[TextData[{
  "We could now continue and analyze the value distribution of the Wigner \
function ",
  "[",
  
  CounterBox["BibliographyCounter", "Horvat03b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Horvat03b",
    ButtonStyle->"Hyperlink"],
  "], but we end here."
}], "Text"],

Cell[TextData[{
  "If we would add a decoherence term to Wigner evolution, the classical and \
the quantum distributions would be much more similar [",
  
  CounterBox["BibliographyCounter", "Zurek03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zurek03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Ota03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ota03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Breuer02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Breuer02",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "O'Connell03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"O'Connell03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Pattanyak03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Pattanyak03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Menski03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Menski03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Angelo03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Angelo03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Helmkamp94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Helmkamp94",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Silvestrov02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Silvestrov02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Chun03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chun03",
    ButtonStyle->"Hyperlink"],
  "]. "
}], "Text"],

Cell[TextData[{
  "For other visualizations of time\[Hyphen]dependent Wigner functions, see \
[",
  
  CounterBox["BibliographyCounter", "Toscana01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Toscana01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Horvat03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Horvat03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lopez03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lopez03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Jacoboni04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Jacoboni04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Carvalho04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Carvalho04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Gardiner00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gardiner00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Czirjak00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Czirjak00",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Belloni03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Belloni03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Foeldi03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Foeldi03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Galleani02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Galleani02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Wong02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wong02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Prosen00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Prosen00",
    ButtonStyle->"Hyperlink"],
  "], and [",
  
  CounterBox["BibliographyCounter", "Cucchietti03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cucchietti03",
    ButtonStyle->"Hyperlink"],
  "]. For the use of the Wigner function in the time\[Dash]frequency space \
for the classical trajectories, see [",
  
  CounterBox["BibliographyCounter", "Galleani02b"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Galleani02b",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Cohen95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cohen95",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  9.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Circular Aperture Diffraction Integral"
}], "ExerciseHeading"],

Cell[TextData[{
  "The diffraction integral for a circular aperture is [",
  
  CounterBox["BibliographyCounter", "Nye03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Nye03",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        "=", 
        RowBox[{
          FractionBox["1", 
            RowBox[{"2", "\[Pi]"}]], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "0", 
              RowBox[{"2", "\[Pi]"}]], 
            RowBox[{
              UnderoverscriptBox["\[Integral]", "0", "a"], 
              RowBox[{"\[Rho]", " ", 
                RowBox[{"exp", "(", 
                  RowBox[{"i", "(", 
                    RowBox[{
                      RowBox[{
                        SuperscriptBox["\[Rho]", "3"], 
                        RowBox[{"cos", "(", 
                          RowBox[{"3", "\[Alpha]"}], ")"}]}], "-", 
                      RowBox[{"z", " ", 
                        SuperscriptBox["\[Rho]", "2"]}], "-", 
                      RowBox[{"x", " ", "\[Rho]", " ", 
                        RowBox[{"cos", "(", "\[Alpha]", ")"}]}], "-", 
                      RowBox[{"y", " ", "\[Rho]", " ", 
                        RowBox[{"sin", "(", "\[Alpha]", ")"}]}]}], ")"}], 
                  ")"}], "d", "\[InvisibleSpace]", "\[Rho]", " ", "d", 
                "\[InvisibleSpace]", "\[CurlyPhi]"}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Make an animation of the curves ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"Im", "(", 
            RowBox[{"\[ScriptCapitalE]", "(", 
              RowBox[{
                RowBox[{"{", 
                  RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}],
             ")"}], "=", "0"}], TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " for a small ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["x", "2"], "+", 
            SuperscriptBox["y", "2"]}], "\[LessTilde]", "10"}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell["\<\
Although a direct numerical integration of the double integral is \
possible, it is relatively time\[Hyphen]consuming.\
\>", "SolutionSubgroup"],

Cell["\<\
\[ScriptCapitalI]N[{x_, y_, z_}, a_] := 
NIntegrate[\[Rho] Exp[I (\[Rho]^3 Cos[3 \[Alpha]] - z \[Rho]^2 - x \[Rho] \
Cos[\[Alpha]] - y \[Rho] Sin[\[Alpha]])],
           {\[Alpha], 0, Pi, 2Pi}, {\[Rho], 0, a}]\
\>", "Input"],

Cell["\[ScriptCapitalI]N[{1, 2, 1}, 2] // Timing", "Input"],

Cell[TextData[{
  "Because we are interested in the values of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  ", we use ",
  StyleBox["NDSolve", "MR"],
  " with respect to ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " instead. This gives as values of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        TraditionalForm]]],
  " for all values of ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " at once and we only have to carry out a 1D numerical integration. We \
calculate the values of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        TraditionalForm]]],
  " on a ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]grid in a polar coordinate system and store interpolating \
functions ",
  StyleBox["ipo", "MR"],
  ". We make use of the rotational symmetry of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        TraditionalForm]]],
  " to calculate the values of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalE]", "(", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}], 
        TraditionalForm]]],
  " only in a sector."
}], "Text"],

Cell[TextData[{
  "Off[NIntegrate::\"ploss\"];\n",
  StyleBox["(* 1D integrand *)", "CodeComment"],
  "\n\[ScriptI]\[ScriptN]\[ScriptT][{x_, y_, z_}, \[Rho]_?NumberQ] := \n\
NIntegrate[\[Rho] Exp[I (\[Rho]^3 Cos[3 \[Alpha]] - z \[Rho]^2 - x \[Rho] \
Cos[\[Alpha]] - y \[Rho] Sin[\[Alpha]])],\n           {\[Alpha], 0, 2Pi}, \
PrecisionGoal -> 7,\n           ",
  StyleBox["(* periodic integrand *)", "CodeComment"],
  " Method -> Trapezoidal]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* parameters *)", "CodeComment"],
  "\nR = 12; z = 1/10; pp\[CurlyPhi] = 16; ppr = 48; \n\n",
  StyleBox["(* use polar coordinates to easily make use of rotational \
symmetry;\n   x == r Cos[\[CurlyPhi]], y == r Sin[\[CurlyPhi]] *)", 
    "CodeComment"],
  "\nDo[Do[ipo[{r, \[CurlyPhi], z}] = ",
  StyleBox["(* solve ODE with respect to a == \[Rho] *)", "CodeComment"],
  "\n      NDSolve[{\[ScriptCapitalE]'[\[Rho]] == \[ScriptI]\[ScriptN]\
\[ScriptT][{r Cos[\[CurlyPhi]], r Sin[\[CurlyPhi]], z}, \[Rho]], \
\[ScriptCapitalE][0] == 0},\n              \[ScriptCapitalE], {\[Rho], 0, 2}, \
PrecisionGoal -> 4][[1, 1, 2]],\n      {\[CurlyPhi], 0, Pi/3, Pi/3/pp\
\[CurlyPhi]}], \n   {r, 0, R, R/ppr}]"
}], "Input"],

Cell[TextData[{
  "For a given value of ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  ", the function ",
  StyleBox["imZeroLinesPlot", "MR"],
  " generates a plot of the lines ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"Im", "(", 
            RowBox[{"\[ScriptCapitalE]", "(", 
              RowBox[{
                RowBox[{"{", 
                  RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}],
             ")"}], "=", "0"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "imZeroLinesPlot[a_] :=\nModule[{data, lcp, zeroImLines, ",
  StyleBox["(* rotation matrix *)", "CodeComment"],
  "\n        \[ScriptCapitalR] = {{-1, Sqrt[3]}, {-Sqrt[3], -1}}/2.}, \n ",
  StyleBox["(* data in polar coordinates *)", "CodeComment"],
  "\n data = Table[ipo[{r, \[CurlyPhi], z}][a],\n              {\[CurlyPhi], \
0, Pi/3, 2Pi/3/pp\[CurlyPhi]}, {r, 0, R, R/ppr}];\n ",
  StyleBox["(* contour plot of vanishing imaginary part *)", "CodeComment"],
  "\n lcp = ListContourPlot[Im[data], PlotRange -> All,\n           Axes -> \
True, ContourShading -> False,\n           DisplayFunction -> Identity,  \
Contours -> {0},\n           MeshRange -> {{0, R}, {0, Pi/3}}];\n ",
  StyleBox["(* the actual contour lines *)", "CodeComment"],
  "\n zeroImLines = Cases[Graphics[lcp], _Line, Infinity];\n If[zeroImLines \
=!= {}, \n    ",
  StyleBox["(* final graphic *)", "CodeComment"],
  "\n    Graphics[{{Thickness[0.002], Hue[0.78 a/2],\n     ",
  StyleBox["(* generate the five equivalent parts *)", "CodeComment"],
  "\n     {Map[\[ScriptCapitalR].\[ScriptCapitalR].#&, #, {-2}], Map[\
\[ScriptCapitalR].#&, #, {-2}], #}&[\n     {Map[{1, -1} #&, #, {-2}], #}&[\n  \
    Apply[Function[{r, \[CurlyPhi]}, {r Cos[\[CurlyPhi]], r \
Sin[\[CurlyPhi]]}], \n            zeroImLines, {-2}]]]},\n    ",
  StyleBox["(* outer circle *)", "CodeComment"],
  "\n    {Thickness[0.01], GrayLevel[0.5], Circle[{0, 0}, R]}},\n    Frame -> \
True, PlotRange -> All, AspectRatio -> Automatic], \n     {}]]"
}], "Input"],

Cell[TextData[{
  "Here are the curves ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"Im", "(", 
            RowBox[{"\[ScriptCapitalE]", "(", 
              RowBox[{
                RowBox[{"{", 
                  RowBox[{"x", ",", "y", ",", "z"}], "}"}], ";", "a"}], ")"}],
             ")"}], "=", "0"}], TraditionalForm]]],
  " for various ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " shown in different colors."
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n{",
  StyleBox["(* 2D graphic *)", "CodeComment"],
  "\n Show[Table[imZeroLinesPlot[a], {a, 2, 0, -2/12}]],\n ",
  StyleBox["(* 3D graphic *)", "CodeComment"],
  "\n Show[Graphics3D[\n Table[If[# === {}, {}, #[[1, 1]] /. {t_, Hue[x_], \
lines__} :>\n           {t, Hue[x], Map[Append[#, 2x/0.78]&, {lines}, \
{-2}]}]&[\n      imZeroLinesPlot[a]], \n      {a, 2, 0, -2/18}]], BoxRatios \
-> {1, 1, 3/2}, Axes -> True,\n     AxesLabel -> {\"x\", \"y\", \"a\"}, \
ViewPoint -> {-1, -2, -3/4}]}]]]"
}], "Input"],

Cell[TextData[{
  "And here is the corresponding animation. For an interpretation of the \
changing curve shape, see [",
  
  CounterBox["BibliographyCounter", "Nye03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Nye03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_ApertureDiffraction.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Do[If[# =!= {}, Show[#, Frame -> False]]&[imZeroLinesPlot[a]],
   {a, 0, 2, 2/48}]\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "10.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Cauchy\[Dash]Born Hypothesis Failure"
}], "ExerciseHeading"],

Cell[TextData[{
  "In its simplest form, the Cauchy\[Dash]Born hypothesis states that the \
positions of the lattice points (atoms) of a linearly deformed elastic body \
is given by the linear interpolations corresponding to the bodies faces [",
  
  CounterBox["BibliographyCounter", "Zanzatto96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zanzatto96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Friesecke02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Friesecke02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Friesecke03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Friesecke03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Ericksen84"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ericksen84",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Stakgold50"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Stakgold50",
    ButtonStyle->"Hyperlink"],
  "]",
  ". For the simplest example of a rectangular piece of a square lattice, \
carry out numerical tests of the Cauchy\[Dash]Born hypothesis. To model the \
2D elastic body, assume linear springs between all nearest and second nearest \
neighbors."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by defining some functions to be used in the following. Given a \
rectangular elastic body, the function ",
  StyleBox["shear", "MR"],
  " will carry out a linear deformation on its coordinates ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
shear[{x_, y_}, {{\[Alpha]x_, \[Beta]x_}, {\[Alpha]y_, \[Beta]y_}}] \
:= {\[Alpha]x x + \[Beta]x y, \[Alpha]y x + \[Beta]y y}\
\>", "Input"],

Cell[TextData[{
  "Given a discretized elastic 2D body in the form of a matrix (the elements \
being the positions of the atoms), the function ",
  StyleBox["energy", "MR"],
  " calculates the potential energy of the underlying spring system with \
lattice constants ",
  StyleBox["ax", "TI"],
  ", ",
  StyleBox["ay", "TI"],
  " and spring constants ",
  StyleBox["k1", "TI"],
  ", ",
  StyleBox["k2", "TI"],
  ". We assume that the potential energy of each spring is of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"k", "/", "2"}], " ", 
          SuperscriptBox[
            StyleBox[
              RowBox[{"\[CapitalDelta]", 
                StyleBox["l",
                  FontSlant->"Italic"]}]], "2"]}], TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"\[CapitalDelta]", 
            StyleBox["l",
              FontSlant->"Italic"]}]], TraditionalForm]]],
  " is the length change of the spring from its equilibrium length."
}], "Text"],

Cell[TextData[{
  StyleBox["(* potential energy of a lattice with spring constants \
\[ScriptK]1, \[ScriptK]2\n   and lattice constant \[ScriptA]x_, \[ScriptA]y \
*)", "CodeComment"],
  "\nenergy[\[ScriptCapitalL]_, {ax_, ay_}, {k1_, k2_}] :=\nWith[{nx = \
Length[\[ScriptCapitalL][[1]]], ny = Length[\[ScriptCapitalL]]}, \n",
  StyleBox[" (* horizontal and vertical springs *)", "CodeComment"],
  "\n Sum[k1/2 (\[ScriptD][\[ScriptE][\[ScriptCapitalL], {ix, jy}] - \
\[ScriptE][\[ScriptCapitalL], {ix + 1, jy}]] - ax)^2, \n     {jy, 0, ny - 1}, \
{ix, 0, nx - 2}] +\n Sum[k1/2 (\[ScriptD][\[ScriptE][\[ScriptCapitalL], {ix, \
jy}] - \[ScriptE][\[ScriptCapitalL], {ix, jy + 1}]] - ay)^2, \n     {ix, 0, \
nx - 1}, {jy, 0, ny - 2}] +\n",
  StyleBox["(* diagonal springs connecting second nearest neighbors *)", 
    "CodeComment"],
  "\n Sum[k2/2 (\[ScriptD][\[ScriptE][\[ScriptCapitalL], {ix, jy}] - \
\[ScriptE][\[ScriptCapitalL], {ix + 1, jy + 1}]] - \[ScriptD][{ax, ay}])^2, \n\
     {ix, 0, nx - 2}, {jy, 0, ny - 2}] +\n Sum[k2/2 (\[ScriptD][\[ScriptE][\
\[ScriptCapitalL], {ix, jy}] - \[ScriptE][\[ScriptCapitalL], {ix - 1, jy + \
1}]] - \[ScriptD][{ax, ay}])^2, \n     {ix, 1, nx - 1}, {jy, 0, ny - 2}]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* some supporting functions *) \n\n(* distance between two \
lattice points *)", "CodeComment"],
  "\n\[ScriptD][{x_, y_}] := Sqrt[x^2 + y^2];\n\n",
  StyleBox["(* extract element from the lattice *)", "CodeComment"],
  "\n\[ScriptE][\[ScriptCapitalL]_, {ix_, jy_}] := \[ScriptCapitalL][[jy + 1, \
ix + 1]];\n\n",
  StyleBox["(* visualize a spring lattice *) ", "CodeComment"],
  "\nlatticeLines[points_] := {Line /@ points, Line /@ Transpose[points],\n   \
                       Map[Point, points, {2}]}"
}], "Input"],

Cell[TextData[{
  "To test the Cauchy\[Dash]Born hypothesis, we will do the following: For a \
given deformed spring lattice, we calculate the positions of the nonboundary \
atoms by linear interpolation. Then, we disturb these positions slightly and \
use these perturbed positions as the starting points for an energy \
minimization carried out by ",
  StyleBox["FindRoot", "MR"],
  ". Because the total potential energy is just the sum of the potential \
energy of all springs, the potential energy is a sum of squares and we will \
use the especially\[Hyphen]suited\[Hyphen]to\[Hyphen]this\[Hyphen]case ",
  StyleBox["\"LevenbergMarquardt\"", "MR"],
  " method option setting. The function ",
  StyleBox["relaxedStretchedLatticeGraphics", "MR"],
  " carries out these steps. It returns a list containing the potential \
energy of the linearly interpolated atom positions, the potential energy \
found by explicit minimization, and a graphics showing the two lattice \
configurations. (Because we will reuse some of the variables used inside ",
  StyleBox["relaxedStretched2DLatticeGraphics", "MR"],
  " later, we do not declare all of the variables as local to this \
function)."
}], "Text"],

Cell[TextData[{
  "relaxedStretched2DLatticeGraphics[\n {{\[Alpha]x_, \[Beta]x_}, \
{\[Alpha]y_, \[Beta]y_}}, {{nx_, ny_}, {ax_, ay_}, {k1_, k2_}}] := \n\
Module[{pRule = P[xy_] :> {x[xy], y[xy]}, \n        startLattice, \
distortedLattice, selectVertices,\n        innerVerticesRules, fm, \
relaxedLattice},\n",
  StyleBox["(* general square lattice *)", "CodeComment"],
  "\ntopologicalLattice = Table[P[{x, y}], {y, 0, ny - 1}, {x, 0, nx - 1}];\n\
",
  StyleBox["(* square lattice with concrete lattice constants *)", 
    "CodeComment"],
  "\nstartLattice = Map[#[[1]] {ax, ay}&,  topologicalLattice, {2}];\n",
  StyleBox["(* stretched square lattice *)", "CodeComment"],
  "\ndistortedLattice = Map[shear[#, {{\[Alpha]x, \[Beta]x}, {\[Alpha]y, \
\[Beta]y}}]&, \n                       startLattice, {2}];\n",
  StyleBox["(* select outer and inner vertices *)\n", "CodeComment"],
  "selectVertices[cdc_] := Rule @@@ cdc[Flatten[\n      MapThread[List, \
{topologicalLattice, distortedLattice}, 2], 1],\n         {P[{0 | nx - 1, \
_}], _} | {P[{_, 0 | ny - 1}], _}];\n",
  StyleBox["(* rules for fixed boundary vertices *)", "CodeComment"],
  "\nboundaryVerticesRules = selectVertices[Cases];\n",
  StyleBox["(* rules for movable inner vertices *)", "CodeComment"],
  "\ninnerVerticesRules = selectVertices[DeleteCases];        \n",
  StyleBox["(* potential energy *)", "CodeComment"],
  "\n\[ScriptCapitalE] = energy[topologicalLattice /. boundaryVerticesRules \
/. pRule,\n           {ax, ay}, {k1, k2}];\n",
  StyleBox["(* initial Cauchy-Born positions *)", "CodeComment"],
  "\ninits = Flatten[Transpose /@ Flatten[Take[#, {2, -2}]& /@\n \
Take[MapThread[List, {topologicalLattice, distortedLattice}, 2] /. \n         \
                                  pRule, {2, -2}], 1], 1];\n",
  StyleBox["(* minimize potential energy *)", "CodeComment"],
  "\nfm = FindMinimum[Evaluate[\[ScriptCapitalE]], Evaluate[Sequence @@ \n    \
      ({#1, (1 + Random[Real, 10^-0 {-1, 1}]) #2}& @@@ inits)],\n          \
Method -> \"LevenbergMarquardt\", MaxIterations -> 1000];\n",
  StyleBox["(* the relaxed lattice *)", "CodeComment"],
  "\nrelaxedLattice = topologicalLattice /. pRule /. fm[[2]] /.\n             \
    (boundaryVerticesRules /. pRule);   \n",
  StyleBox["(* return Cauchy\[Dash]Born energy, minimized energy and graphic \
*)   ", "CodeComment"],
  "       \n{{\[ScriptCapitalE] /. (Rule @@@ inits), fm[[1]]},\nGraphics[",
  StyleBox["(* Cauchy\[Dash]Born lattice in gray *)", "CodeComment"],
  "\n   {{PointSize[0.022], Thickness[0.015], GrayLevel[0.8],\n     \
latticeLines[distortedLattice]},\n         ",
  StyleBox["(* energy-minimized lattice in blue *)", "CodeComment"],
  "\n    {PointSize[0.001], Thickness[0.002], RGBColor[0, 0, 1],\n     \
latticeLines[relaxedLattice]},\n         ",
  StyleBox["(* lattice point distortions in red *)", "CodeComment"],
  "\n    {Thickness[0.002], Hue[0], MapThread[Line[{#1, #2}]&, \n     \
{distortedLattice, relaxedLattice}, 2]}}, \n    AspectRatio -> Automatic, \
Frame -> True]}]"
}], "Input"],

Cell[TextData[{
  "Using the result returned from ",
  StyleBox["relaxedStretched2DLatticeGraphics", "MR"],
  ", the function ",
  StyleBox["showResult", "MR"],
  " prints the two energy values and displays a graphics showing the two \
lattices."
}], "Text"],

Cell["\<\
showResult[args__] := 
(Print[\"Cauchy\[Dash]Born: \" <> ToString[InputForm[#1[[1]]]] <> \"\\n\" <>
       \"FindMinimum: \", ToString[InputForm[#1[[2]]]]];    
   Show[#2])& @@ relaxedStretched2DLatticeGraphics[args]\
\>", "Input"],

Cell[TextData[{
  "Here is a first example. We use a ",
  Cell[BoxData[
      FormBox[
        RowBox[{"6", "\[Times]", "6"}], TraditionalForm]]],
  " lattice. The deformation is relatively small. The linearly interpolated \
lattice (gray lines) and the lattice found by explicit energy minimization \
(in blue) are identical. "
}], "Text"],

Cell["\<\
showResult[{{1.1, 0.1}, {-0.1, 0.9}}, 
           {{6, 6}, {1, 1}, {1, 1}}]\
\>", "Input"],

Cell["Here is a larger deformation. The two lattices again agree.", "Text"],

Cell["\<\
showResult[{{1.6, 0.3}, {0.5, 1.5}}, {{6, 6}, {1.5, 1}, {2.5, \
2}}]\
\>", "Input"],

Cell[TextData[{
  "But it is not difficult to find a counter example to the Cauchy\[Dash]Born \
hypothesis. In the next example, we use again a ",
  Cell[BoxData[
      FormBox[
        RowBox[{"6", "\[Times]", "6"}], TraditionalForm]]],
  " lattice. This time the linearly interpolated lattice (gray lines) has a \
considerably higher potential energy. The red lines indicate the deviations \
of the energy\[Hyphen]minimized lattices positions from the linearly \
interpolated ones."
}], "Text"],

Cell["\<\
SeedRandom[3];
showResult[{{0.62, 0.44}, {-0.34, 1.06}}, 
           {{6, 6}, {1.98, 0.56}, {2.24, 2.34}}]\
\>", "Input"],

Cell[TextData[{
  "Using ",
  StyleBox["NMinimize", "MR"],
  " we can further minimize the energy of the lattice. (",
  StyleBox["FindMinimum", "MR"],
  " found one local potential energy minimum, lower minima might exist \
elsewhere.)"
}], "Text"],

Cell["\<\
NMinimize[Evaluate[\[ScriptCapitalE]], First /@ inits][[1]]\
\>", \
"Input"],

Cell[TextData[{
  "We can watch the approach to the minimum by adding damping to the spring \
system and letting it relax into its equilibrium state. The function ",
  StyleBox["solveSpringSystemODEs", "MR"],
  " creates the corresponding coupled differential equations for the lattice \
point coordinates and solves them."
}], "Text"],

Cell[TextData[{
  "solveSpringSystemODEs[T_, \[Gamma]_, \[Delta]_] :=\nModule[{vars, indices, \
odes}, \n ",
  StyleBox["(* ODE variables *", "CodeComment"],
  ")\n vars = Cases[\[ScriptCapitalE], _x | _y, Infinity] // Union;\n indices \
= Union[First /@ vars];\n ",
  StyleBox["(* equations of motion; with damping terms *)", "CodeComment"],
  "\n odes = (#''[t] == - \[Gamma] #'[t] + (-D[\[ScriptCapitalE], #] /. \n    \
                     xy:(_x | _y) :> xy[t]))& /@ vars;\n NDSolve[Join[odes, \
",
  StyleBox["(* randomized initial conditions *)", "CodeComment"],
  "\n              (#1[0] == (1 + \[Delta] Random[Real, {-1, 1}]) #2)& @@@ \
inits, \n              (#'[0] == 0)& /@ vars], vars, {t, 0, T}]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* the time\[Hyphen]dependent relaxing lattices *)", 
    "CodeComment"],
  "\nrelaxingLattice[\[Tau]_, ndsol_] :=  topologicalLattice /. \n   \
boundaryVerticesRules /. P[xy_] :> {x[xy], y[xy]} /.\n   xy:(_x | _y) :> xy[\
\[Tau]] /. ndsol[[1]]"
}], "Input"],

Cell["\<\
For four different random initial conditions, we let the last \
spring system now relax into the equilibrium shape. Starting from different \
initial conditions, we see different final configurations with different \
final energies. The second graphic shows the time\[Hyphen]dependence of the \
potential energy.\
\>", "Text"],

Cell[TextData[{
  "Module[{T = 20, frames = 4, o = 4, \[Gamma] = 1, \[Delta] = 0.2, ndsol,\n  \
      ax = 1.98, ay = 0.56, k1 = 2.24, k2 = 2.34,\n        \
\[ScriptCapitalE]CB = 27.485, min\[ScriptCapitalE] = 18.386},\n  \
Show[GraphicsArray[#]]& /@ Transpose[Table[\n  ",
  StyleBox["(* relax four times *)", "CodeComment"],
  "\n  Table[ndsol[j] = solveSpringSystemODEs[T, \[Gamma], \[Delta]];\n       \
(* snapshots of the relaxation process *)\n        \
Graphics[latticeLines[relaxingLattice[\[Tau], ndsol[j]]],\n                 \
Frame -> False], {\[Tau], 0, T, T/frames}], {j, o}]];\n  ",
  StyleBox["(* time\[Hyphen]dependent potential energy *)", "CodeComment"],
  "\n  Show[Graphics[\n  {{Thickness[0.006], GrayLevel[0.5], Line[{{0, min\
\[ScriptCapitalE]}, {T, min\[ScriptCapitalE]}}]},\n   {Thickness[0.006], \
GrayLevel[0.0], Line[{{0, \[ScriptCapitalE]CB}, {T, \[ScriptCapitalE]CB}}]},\n\
   Table[{",
  StyleBox["(* color each run differently *)", "CodeComment"],
  " Hue[0.78 (j - 1)/(o - 1)], \n         Line[Table[{\[Tau], \
energy[relaxingLattice[\[Tau], ndsol[j]],  \n                               \
{ax, ay}, {k1, k2}]},\n                    {\[Tau], 0, T, T/25}]]}, {j, o}]},\
\n                    Frame -> True,\n        PlotRange -> {1/2 min\
\[ScriptCapitalE], 2 min\[ScriptCapitalE]}]]]"
}], "Input"],

Cell[TextData[{
  "We end with some graphics showing violations of the Cauchy\[Dash]Born \
hypothesis for some larger lattices. (For a detailed analysis of the local \
shape of the deformations, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Friesecke02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Friesecke02",
    ButtonStyle->"Hyperlink"],
  "]",
  ".)"
}], "Text"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity}, showResult @@@
 {{{{0.63383, -0.10383}, {-0.422062, 1.36884}},
   {{16, 16}, {0.85177, 0.71945}, {1.24497, 1.48163}}},
  {{{1.11238, -0.25194}, {-0.023546, 0.519724}},
   {{16, 16}, {0.84189, 1.81386}, {0.43108, 0.99715}}},
  {{{0.89331, -0.03642}, { 0.0533719, 0.751591}},
   {{16, 16}, {0.69912, 0.68504}, {2.03383, 2.53343}}}}]]]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "11.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Schwarz\[Dash]Christoffel Map"
}], "ExerciseHeading"],

Cell[TextData[{
  "The Schwarz\[Dash]Christoffel map from the unit disk to a nonintersecting \
simple polygon ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalP]", TraditionalForm]]],
  " with vertices ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["w", "k"], TraditionalForm]]],
  " is given by [",
  
  CounterBox["BibliographyCounter", "Koppenfels59"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Koppenfels59",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Driscoll02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll02",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"f", " ", 
          RowBox[{"(", "z", ")"}]}], "=", 
        RowBox[{"\[Alpha]", "+", 
          RowBox[{"\[Beta]", 
            RowBox[{
              UnderoverscriptBox[
                StyleBox["\[Integral]",
                  SpanMinSize->5,
                  SpanMaxSize->Infinity], "0", "z"], 
              RowBox[{
                UnderoverscriptBox["\[Product]", 
                  RowBox[{"k", "=", "1"}], "n"], 
                RowBox[{
                  SuperscriptBox[
                    RowBox[{"(", 
                      RowBox[{"1", "-", 
                        FractionBox["\[Zeta]", 
                          SubscriptBox["z", "k"]]}], ")"}], 
                    RowBox[{
                      SubscriptBox["\[Alpha]", "k"], "-", "1"}]], "d", 
                  "\[InvisibleSpace]", "\[Zeta]"}]}]}]}]}]}], 
      TraditionalForm]], "Input",
  Evaluatable->False,
  FontWeight->"Plain"],

Cell[TextData[{
  "where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"f", "(", "z", ")"}], "\[Element]", "\[ScriptCapitalP]"}], 
        TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", "z", "\[RightBracketingBar]"}], 
          "\[LessEqual]", "1"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"f", "(", 
            SubscriptBox["z", "k"], ")"}], "=", 
          SubscriptBox["w", "k"]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Alpha]", "k"], " ", "\[Pi]"}], TraditionalForm]]],
  " are the counterclockwise\[Hyphen]oriented interior angles of the polygon. \
Calculate a numerical approximation to a Schwarz\[Dash]Christoffel map for an \
L\[Hyphen]shaped polygonal domain with vertices ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0", ",", "2", ",", 
            RowBox[{"2", "+", "i"}], ",", 
            RowBox[{"1", "+", "i"}], ",", 
            RowBox[{"1", "+", 
              RowBox[{"2", "i"}]}], ",", 
            RowBox[{"2", "i"}]}], "}"}], TraditionalForm]]],
  ". Visualize the resulting conformal map."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  StyleBox["wList", "MR"],
  " and  ",
  StyleBox["\[Alpha]List", "MR"],
  " are the polygon vertices and the interior angles. We use the point ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"(", 
            RowBox[{"1", "+", "i"}], ")"}], "/", "2"}], TraditionalForm]]],
  " as the origin."
}], "SolutionSubgroup"],

Cell["\<\
wList = {0, 2, 2 + I, 1 + I, 1 + 2 I, 2 I} - (1 + I)/2;

\[Alpha]List = {Pi/2, Pi/2, Pi/2, 3Pi/2, Pi/2, Pi/2}/Pi;\
\>", "Input"],

Cell["\<\
Show[Graphics[
  {Thickness[0.02], Line[{Re[#], Im[#]}& /@ Append[wList, First[wList]]],
   {Hue[0], PointSize[0.04], Point[{0, 0}]}},
    PlotRange -> All, AspectRatio -> Automatic, Frame -> True]]\
\>", "Input"],

Cell[TextData[{
  "Calculating the Schwarz\[Dash]Christoffel map boils down to determining \
the preimages ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", "k"], TraditionalForm]]],
  " of the vertices and the two constants ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[Beta]", TraditionalForm]]],
  ". The last two constants can be determined by prescribing the position of \
two vertices. We will use the two vertices on the symmetry axis ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"Re", "(", "z", ")"}], "=", 
          RowBox[{"Im", "(", "z", ")"}]}], TraditionalForm]]],
  " (the first and the fourth vertex). And taking the symmetry of the L\
\[Hyphen]shaped domain into account, the only two unknowns are the points ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", "3"], TraditionalForm]]],
  ". Because the boundary of the unit disk gets mapped to the boundary of the \
polygon, we write ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["z", "k"], "=", 
          RowBox[{"exp", "(", 
            RowBox[{"i", " ", 
              SubscriptBox["\[CurlyPhi]", "k"]}], ")"}]}], 
        TraditionalForm]]],
  " and we are left with determining the two values ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "3"], TraditionalForm]]],
  ". For given values of  ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "3"], TraditionalForm]]],
  ", the function ",
  StyleBox["makeSymmetriczList", "MR"],
  " gives the list of all six vertices of the L\[Hyphen]shaped polygon."
}], "Text"],

Cell["\<\
makeSymmetriczList[{\[CurlyPhi]2_, \[CurlyPhi]3_}] = 
{Exp[I 5Pi/4], Exp[I \[CurlyPhi]2], Exp[I \[CurlyPhi]3], Exp[I Pi/4],
 Exp[I Pi/4] Conjugate[Exp[-I Pi/4] Exp[I \[CurlyPhi]3]],
 Exp[I Pi/4] Conjugate[Exp[-I Pi/4] Exp[I \[CurlyPhi]2]]};\
\>", "Input"],

Cell[TextData[{
  "Using numerical integration, the function ",
  StyleBox["wValues", "MR"],
  " calculates the positions of the six vertices for given values ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "3"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "wValues[{\[CurlyPhi]2_, \[CurlyPhi]3_}] :=\nModule[{zs, ws, \
\[Alpha]\[Beta]Sol},\n zs = makeSymmetriczList[{\[CurlyPhi]2, \[CurlyPhi]3}];\
\n ws = Table[NIntegrate[Evaluate @ (Times @@ ((1 - \[Zeta]/zs)^(\[Alpha]List \
- 1))), \n                       {\[Zeta], 0, zs[[j]]}], {j, 6}];\n ",
  StyleBox["(* position first and fourth vertex through \[Alpha] and \[Beta] \
*)", "CodeComment"],
  "\n \[Alpha]\[Beta]Sol = Solve[{wList[[1]] == \[Alpha] + \[Beta] ws[[1]], \n\
                wList[[4]] == \[Alpha] + \[Beta] ws[[4]]}, {\[Alpha], \
\[Beta]}][[1]];\n ",
  StyleBox["(* return linear map and mapped points *)", "CodeComment"],
  "\n {\[Alpha]\[Beta]Sol, \[Alpha] + \[Beta] ws /. \[Alpha]\[Beta]Sol}]"
}], "Input"],

Cell[TextData[{
  "Minimizing now the sum of squares of the distances of the mapped preimages \
of the vertices should yield a minimum with value 0 and the values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "3"], TraditionalForm]]],
  " for the Schwarz\[Dash]Christoffel map."
}], "Text"],

Cell["\<\
g[{\[CurlyPhi]2_?NumberQ, \[CurlyPhi]3_?NumberQ}] := Plus @@ \
(Abs[wList - wValues[{\[CurlyPhi]2, \[CurlyPhi]3}][[2]]]^2)

fm = FindMinimum[g[{\[CurlyPhi]2, \[CurlyPhi]3}], {\[CurlyPhi]2, -1, -1.1},  \
{\[CurlyPhi]3, 0.5, 0.4}]\
\>", "Input"],

Cell["\<\
So, we obtain the following parameters and integrand for the map.\
\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* constants \[Alpha] and \[Beta] for the final map *)", 
    "CodeComment"],
  "\n{\[Alpha]F, \[Beta]F} = {\[Alpha], \[Beta]} /. wValues[{\[CurlyPhi]2, \
\[CurlyPhi]3} /. fm[[2]]][[1]];\n\n",
  StyleBox["(* the final z_k values *)", "CodeComment"],
  "\nfinalZs = makeSymmetriczList[{\[CurlyPhi]2, \[CurlyPhi]3} /. fm[[2]]];\n\
\n",
  StyleBox["(* the final integrand *)", "CodeComment"],
  "\nscM[\[Zeta]_] = N[(Times @@ ((1 - \[Zeta]/finalZs)^(\[Alpha]List - \
1)))]"
}], "Input"],

Cell[TextData[{
  "To visualize the map we will not use ",
  StyleBox["NIntegrate", "MR"],
  ", but rather ",
  StyleBox["NDSolve", "MR"],
  ". For a given direction ",
  Cell[BoxData[
      FormBox["\[ScriptD]", TraditionalForm]]],
  ", we solve the differential equation corresponding to the integral in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "z", ")"}], TraditionalForm]]],
  " radially outward."
}], "Text"],

Cell["\<\
solveODERadial[\[ScriptD]_] := NDSolve[{w'[t] == \[ScriptD] scM[\
\[ScriptD] t], w[0] == 0}, w, 
                              {t, 0, 1 - 10^-10}]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* radial distances for equi-lines *)", "CodeComment"],
  "\npp = 24;\ntPoints = Join[Table[t, {t, 0, 1 - 1/pp, 1/pp}], {0.986, \
0.9999}];"
}], "Input"],

Cell["\<\
data = Table[ndsol = solveODERadial[Exp[I \[CurlyPhi]]];
             ((\[Alpha]F + \[Beta]F w[#])& /@ tPoints) /. ndsol[[1]], 
             {\[CurlyPhi], 0, 2Pi, 2Pi/360}];\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* the mapped points *)", "CodeComment"],
  "\n\[CurlyEpsilon] = 10^-6;\ndata = Table[ndsol = solveODERadial[Exp[I \
\[CurlyPhi]]];\n             ((\[Alpha]F + \[Beta]F w[#])& /@ tPoints) /. \
ndsol[[1]], \n             {\[CurlyPhi], Pi/4 + \[CurlyEpsilon], 9/4 Pi - \
\[CurlyEpsilon], (2Pi - 2 \[CurlyEpsilon])/360}];"
}], "Input"],

Cell[TextData[{
  "Show[Graphics[\n{",
  StyleBox["(* the L-shaped dpolygon *)", "CodeComment"],
  "\n {Hue[0], Thickness[0.006], Line[{Re[#], Im[#]}& /@ \n  Append[wList, \
First[wList]]]},\n ",
  StyleBox["(* equi-lines and perpendicular curves *)", "CodeComment"],
  "\n {GrayLevel[0.5], MapIndexed[If[IntegerQ[#2[[1]]], \n                    \
            Line[{Re[#], Im[#]}& /@ #], {}]&, data]},\n {GrayLevel[0], \
Line[{Re[#], Im[#]}& /@ #]& /@ Transpose[data]}}], \n      PlotRange -> All, \
Frame -> True, AspectRatio -> Automatic]"
}], "Input"],

Cell[TextData[{
  "The last graphic shows the effect of crowding: near the left lower corner, \
the curves perpendicular to the equi\[Hyphen]lines cluster and in the arms \
the become relatively widely spaced. To get a more homogeneously spaced equi\
\[Hyphen]line graphic, we will now solve the differential equation \
azimuthally and use ",
  StyleBox["ParametricPlot", "MR"],
  " to get adaptively refined smooth equi\[Hyphen]curves."
}], "Text"],

Cell["\<\
solveODEAzimuthal[\[Rho]_, {\[CurlyPhi]1_, \[CurlyPhi]2_}] := 
With[{w0 = \[Alpha]F + \[Beta]F NIntegrate[scM[\[Zeta]], {\[Zeta], 0, \[Rho] \
Exp[I \[CurlyPhi]1]}]}, 
     NDSolve[{w'[\[CurlyPhi]] == \[Beta]F \[Rho] I Exp[I \[CurlyPhi]] scM[\
\[Rho] Exp[I \[CurlyPhi]]], w[\[CurlyPhi]1] == w0}, w, 
             {\[CurlyPhi], \[CurlyPhi]1, \[CurlyPhi]2}]]\
\>", "Input"],

Cell["\<\
contract[{a_, b_}] := With[{mp = (a + b)/2, lh = (b - a)/2, \
\[Delta] = 1 - 10^-10},
                           {mp - \[Delta] lh, mp + \[Delta] lh}]\
\>", "Input"],

Cell["\<\
\[CurlyPhi]Ranges = contract /@ 
           Partition[Append[#, 2Pi + First[#]]&[Arg[finalZs // N]], 2, \
1];\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["SmoothPlotAzimuthal", "MR"],
  " generates the plots from the list of  ",
  StyleBox["InterpolatingFunction", "MR"],
  " returned by ",
  StyleBox["NDSolve", "MR"],
  "."
}], "Text"],

Cell["\<\
makeSmoothPlotAzimuthal[\[Rho]_, ipo_InterpolatingFunction] := 
ParametricPlot[{Re[ipo[\[CurlyPhi]]], Im[ipo[\[CurlyPhi]]]}, \
Evaluate[Flatten[{\[CurlyPhi], ipo[[1, 1]]}]],
               PlotPoints -> 120, DisplayFunction -> Identity]\
\>", "Input"],

Cell["\<\
makeSmoothPlotAzimuthal[\[Rho]_, l_List] := 
    Show[makeSmoothPlotAzimuthal[\[Rho], #]& /@ 
                   Cases[l, _InterpolatingFunction, Infinity]]\
\>", "Input"],

Cell["\<\
We also display some of the perpendicular curves, namely the ones \
ending at the vertices of the L\[Hyphen]shaped polygon and at the midpoints \
of its edges.\
\>", "Text"],

Cell["\<\
makeSmoothPlotRadial[\[ScriptD]_, ipo_InterpolatingFunction] := 
ParametricPlot[{Re[\[Alpha]F + \[Beta]F ipo[t]], Im[\[Alpha]F + \[Beta]F \
ipo[t]]}, 
               Evaluate[Flatten[{t, ipo[[1, 1]]}]],
               PlotPoints -> 120, DisplayFunction -> Identity,
               PlotStyle -> {{GrayLevel[0.5], Thickness[0.003]}}]\
\>", \
"Input"],

Cell["\<\
makeSmoothPlotRadial[\[ScriptD]_, l_List] := \
Show[makeSmoothPlotRadial[\[ScriptD], #]& /@ 
                             Cases[l, _InterpolatingFunction, \
Infinity]]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* calculate the mapped point position *)", "CodeComment"],
  "\nof[\[CurlyPhi]_?NumberQ] := Module[{res},\n                         \
Off[NIntegrate::ncvb];\n                         res = \[Alpha]F + \[Beta]F \
NIntegrate[scM[\[Zeta]], {\[Zeta], 0, Exp[I \[CurlyPhi]]}];\n                 \
        On[NIntegrate::ncvb]; res];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* calculate z-values corresponding to the midpoints of the L \
edges *)", "CodeComment"],
  "\nedgeMidpointZs = \n(Exp[I Re[\[CurlyPhi]]] /. FindRoot[of[\[CurlyPhi]] - \
#1, {\[CurlyPhi], #2[[1]], #2[[2]]},\n                          PrecisionGoal \
-> 8])& @@@ \nTranspose[{(Plus @@@ Partition[Append[wList, First[wList]], 2, \
1]/2.),\n           Partition[Append[#, 2Pi + First[#]]&[Arg[finalZs // N]], \
2, 1]}]"
}], "Input"],

Cell["\<\
Along the curve to the midpoint of the second polygon edge, we \
calculate equi\[Hyphen]line radii that are approximately homogeneously \
spaced.\
\>", "Text"],

Cell["\<\
\[ScriptF][t_] = \[Alpha]F + \[Beta]F (w /. \
solveODERadial[edgeMidpointZs[[2]]][[1]])[t];

i\[ScriptF] = Interpolation[Table[{Re[\[ScriptF][t]], t}, {t, 0, 1, 1/12}]];

\[Rho]s = Table[i\[ScriptF][t], {t, Re[\[ScriptF][0]], Re[\[ScriptF][1]], \
(Re[\[ScriptF][1]] - Re[\[ScriptF][0]])/15}]\
\>", "Input"],

Cell["\<\
Now we obtain smooth, approximately homogeneously spaced equicurves \
up to near the polygon boundary.\
\>", "Text"],

Cell[TextData[{
  "Show[{Graphics[{Hue[0], Thickness[0.01], Line[{Re[#], Im[#]}& /@ \n        \
        Append[wList, First[wList]]]}], \n      ",
  StyleBox["(* radial orthogonal curves *)", "CodeComment"],
  "\n      Function[\[ScriptD], makeSmoothPlotRadial[\[ScriptD], \
solveODERadial[\[ScriptD]]]] /@ \n                                   \
Join[finalZs, edgeMidpointZs],\n      ",
  StyleBox["(* smooth equi-cuves *)", "CodeComment"],
  "\n      Function[\[Rho], makeSmoothPlotAzimuthal[\[Rho], \n                \
  solveODEAzimuthal[\[Rho], #]& /@ \[CurlyPhi]Ranges]] /@ \n                  \
",
  StyleBox["(* radii for homogeneously spaced equi-lines *)  ", 
    "CodeComment"],
  "         \n                                         Append[Most[\[Rho]s], \
0.998]},\n          PlotRange -> All, AspectRatio -> Automatic,\n          \
DisplayFunction -> $DisplayFunction];"
}], "Input"],

Cell["\<\
We end with a visualization of the Schwarz\[Dash]Christoffel map of \
a more complicated polygon.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* vertices of a polygon in the complex plane *)", 
    "CodeComment"],
  "\nwList = With[{s = Sqrt[3]}, {1 + I s, 2 + 2 I s, 1 + 3 I s, -3 + 3 I s, \
\n               -2 + 2 I s, 2 I s, -2, -4, -5 - I s, -3 - 3 I s, -2 - 2 I s, \
\n               -3 - I s, 1 - I s, 2 - 2 I s, 4 - 2 I s, 6, 4, 3 - I s}/2];"
}], "Input"],

Cell[TextData[{
  "equiAndFieldCurves[equiValues_List] := \nModule[{\[Alpha]List, \
\[CurlyPhi]s, \[CurlyPhi]Es, \[CurlyPhi]L, \[Beta], zs, w0, eqs, \[Rho], \
\[Phi]1, \[Phi]2, ndsol, pp, \n        curve, \[ScriptCapitalR], \[Omega], \
opts, R = 1 - 10^-12},\n ",
  StyleBox["(* angles in units of \[Pi] of the polygon *)", "CodeComment"],
  "\n \[Alpha]List =  1/3 {4, 2, 2, 1, 2, 5, 4, 2, 2, 1, 2, 5, 4, 2, 2, 1, 2, \
5};       \n ",
  StyleBox["(* parameters for the Schwarz-Christoffel map *)", 
    "CodeComment"],
  "\n \[CurlyPhi]s = {1.880275011280091, 2.074403517501587, \
2.084559146579438, \n       2.087831881871811, 2.087952818861801, \
2.094395102393195};\n ",
  StyleBox["(* parameters for edge midpoints *)", "CodeComment"],
  "\n \[CurlyPhi]Es = {2.056709598824023, 2.0812111099343658, \
2.0875447164599064,\n        2.087856604171078, 2.0882552129179253, \
2.5163592862103163};\n \[Beta] = 0.813037054574698 - 0.56337234858643208 I;\n \
",
  StyleBox["(* rotation matrices *)", "CodeComment"],
  "\n Do[\[ScriptCapitalR][k] = N[{{Cos[k 2Pi/3], Sin[k 2Pi/3]}, {-Sin[k \
2Pi/3], Cos[k 2Pi/3]}}], \n    {k, 0, 2}];\n ",
  StyleBox["(* graphics options; allow unlimited subdivision *)", 
    "CodeComment"],
  "\n optsG = Sequence[PlotPoints -> 100, PlotDivision -> Infinity, \n        \
             MaxBend -> 3, DisplayFunction -> Identity];\n ",
  StyleBox["(* NDSolve options *)", "CodeComment"],
  "\n optsD = Sequence[PrecisionGoal -> 12, AccuracyGoal -> 12, \n            \
      WorkingPrecision -> 25];                    \n ",
  StyleBox["(* all preimages of the 18 vertices *)", "CodeComment"],
  "\n zs = Join[Exp[I \[CurlyPhi]s], Exp[2Pi I/3] Exp[I \[CurlyPhi]s], \
Exp[4Pi I/3] Exp[I \[CurlyPhi]s]];\n ",
  StyleBox["(* equi- and filed lines *)", "CodeComment"],
  "\n {",
  StyleBox["(* equilines *)", "CodeComment"],
  "\n  Table[\[Rho] = equiValues[[j]]; \[Phi]1 = \[CurlyPhi]s[[1]]; \[Phi]2 = \
\[Phi]1 + 2/3 Pi;\n  ",
  StyleBox["(* starting value for differential equations *)", "CodeComment"],
  "\n  w0 = \[Beta] NIntegrate[Evaluate @ SetPrecision[(Times @@ ((1 - \
\[Zeta]/zs)^(\[Alpha]List - 1))), 30], \n                    Evaluate @ {\
\[Zeta], 0, SetPrecision[\[Rho] zs[[1]], 30]},\n                    \
MaxRecursion -> 20, PrecisionGoal -> 14, WorkingPrecision -> 30];\n  ",
  StyleBox["(* solve differential equation azimuthally *)", "CodeComment"],
  "\n  eqs = {1/(I \[Rho] Exp[I \[CurlyPhi]]) Y'[\[CurlyPhi]] == \[Beta] \
(Times @@ ((1 - \[Rho] Exp[I \[CurlyPhi]]/zs)^(\[Alpha]List - 1))),\n         \
Y[\[Phi]1] == w0};\n  ndsol = NDSolve[SetPrecision[eqs, 30], Y, {\[CurlyPhi], \
\[Phi]1, \[Phi]2}, optsD];\n  ",
  StyleBox["(* make plot of curve *)", "CodeComment"],
  "\n  pp = ParametricPlot[Evaluate[{Re[Y[\[CurlyPhi]]], Im[Y[\[CurlyPhi]]]} \
/. ndsol[[1]]], \n                     {\[CurlyPhi], \[Phi]1, \[Phi]2}, \
Evaluate[optsG]];\n  ",
  StyleBox["(* rotate curve in other positions *)", "CodeComment"],
  "\n  curve = Cases[pp, _Line, Infinity];\n  \
Table[Map[\[ScriptCapitalR][k].#&, curve, {-2}], {k, 0, 2}], {j, \
Length[equiValues]}],\n ",
  StyleBox["(* field lines from the origin to the 18 polygon vertices *)", 
    "CodeComment"],
  " \n \[CurlyPhi]L = Join[\[CurlyPhi]s, \[CurlyPhi]Es];\n Table[\[Omega] = \
\[CurlyPhi]L[[j]]; Clear[\[Rho]];\n eqs = {1/(Exp[I \[Omega]]) Y'[\[Rho]] == \
\[Beta] (Times @@ ((1 - \[Rho] Exp[I \[Omega]]/zs)^(\[Alpha]List - 1))),\n    \
    Y[0] == 0};\n  ",
  StyleBox["(* solve differential equation radially *)", "CodeComment"],
  "\n  ndsol = NDSolve[SetPrecision[eqs, 30], Y, {\[Rho], 0, R}, optsD];\n  \
",
  StyleBox["(* make plot of curve *)", "CodeComment"],
  "\n  pp = ParametricPlot[Evaluate[{Re[Y[\[Rho]]], Im[Y[\[Rho]]]} /. \
ndsol[[1]]], \n                     {\[Rho], 0, R}, Evaluate[optsG]];\n  \
curve = Cases[pp, _Line, Infinity];\n  ",
  StyleBox["(* rotate curve in other positions *)", "CodeComment"],
  "\n  Table[Map[\[ScriptCapitalR][k].#&, curve, {-2}], {k, 0, 2}], {j, \
12}]}]"
}], "Input"],

Cell[TextData[{
  "Module[{",
  StyleBox["(* equi-values to be used *)", "CodeComment"],
  "\n        equiList = {0.1, 0.3, 0.5, 0.7, 0.88, 0.96, 0.99, 0.997, \n      \
              0.999, 0.9996, 0.99992, 0.99997, 0.9999988}, \[Lambda], \n      \
              equiCurves, fieldCurves},\n       \[Lambda] = Length[equiList];\
\n       ",
  StyleBox["(* equi- and field curves *)", "CodeComment"],
  "\n       {equiCurves, fieldCurves} = equiAndFieldCurves[equiList];\n       \
",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\n       Show[Graphics[\n        {",
  StyleBox["(* polygon in thick gray *)", "CodeComment"],
  "\n         {Thickness[0.008], GrayLevel[1/2], \n          Line[{Re[#], \
Im[#]}& /@ Append[wList, First[wList]]]}, \n         ",
  StyleBox["(* field curves in black *)", "CodeComment"],
  "\n         {Thickness[0.002], GrayLevel[0], fieldCurves},\n         ",
  StyleBox["(* colored equi-curves *)", "CodeComment"],
  "\n         {Thickness[0.002], MapIndexed[{Hue[0.78 (#2[[1]] - \
1)/(\[Lambda] - 1)], #}&, \n                                        \
equiCurves]}}], \n             AspectRatio -> Automatic, PlotRange -> All]]; \
"
}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "12.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " EU Voting"
}], "ExerciseHeading"],

Cell[TextData[{
  "The Banzhaf index of a voting system is defined in the following way [",
  
  CounterBox["BibliographyCounter", "Felsenthal98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Felsenthal98",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Dubey79"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Dubey79",
    ButtonStyle->"Hyperlink"],
  "]",
  ": Given ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " parties ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "k"], TraditionalForm]]],
  ", each having a (nonnegative) voting weight ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["v", "k"], TraditionalForm]]],
  " (not necessary integer), ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["2", "n"], "-", "1"}], TraditionalForm]]],
  " possible coalitions can be formed through all subsets of the ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " parties. A coalition is winning, if its combined voting weight is larger \
than a given quota ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " (typically 50% or 66.67% of the sums of all weights ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Nu]", "k"], TraditionalForm]]],
  "). Let ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " be the total number of winning coalitions that can be formed, and let ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Omega]", "k"], TraditionalForm]]],
  " be the number of coaltions that contains the party ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "k"], TraditionalForm]]],
  ". Then the Banzhaf index ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Eta]", "k"], TraditionalForm]]],
  " of the party ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "k"], TraditionalForm]]],
  " is defined as ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Eta]", "k"], "=", 
          RowBox[{
            RowBox[{"2", 
              SubscriptBox["\[Omega]", "k"]}], "-", "\[Omega]"}]}], 
        TraditionalForm]]],
  ". The normalized Banzhaf index ",
  Cell[BoxData[
      FormBox[
        SubscriptBox[
          OverscriptBox["\[Eta]", "~"], "k"], TraditionalForm]]],
  " is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            OverscriptBox["\[Eta]", "~"], "k"], "=", 
          RowBox[{
            SubscriptBox[
              OverscriptBox["\[Eta]", "~"], "k"], "/", 
            SuperscriptBox["2", 
              RowBox[{"n", "-", "1"}]]}]}], TraditionalForm]]],
  ". Implement a function that calculates the normalized Banzhaf indices for \
given party weights and quotas. "
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "The voting weights of the current 25 EU nations are:  {9.09, 7.72, 7.69, \
7.55, 6.38, 6.18, 4.02, 3.32, 3.23, 3.22, 3.19, 3.19, 2.99, 2.84, 2.32, 2.32, \
2.28, 1.99, 1.86, 1.53, 1.41, 1.17, 0.89, 0.67, 0.63} (following Penrose\
\[CloseCurlyQuote]s square root law, these numbers are approximately the \
square root of the populations measured in millions of people) [",
  
  CounterBox["BibliographyCounter", "Zyczkowski04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zyczkowski04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Lane95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lane95",
    ButtonStyle->"Hyperlink"],
  "]",
  ". For which quota does the voting weights of the EU countries \
approximately best agree with their normalized Banzhaf indices [",
  
  CounterBox["BibliographyCounter", "Zyczkowski04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zyczkowski04",
    ButtonStyle->"Hyperlink"],
  "]?"
}], "SolutionSubgroup"],

Cell[TextData[{
  "We start with implementing a functions that counts the winning coalitions \
in general and for each party. Because we want later apply our function to a \
list of 25 parties (meaning we will have to analyze 33554432 coalitions), we \
use the function ",
  StyleBox["Compile", "MR"],
  ", for speed reasons. To avoid excessive memory use, we do not create a \
list of all possible coalitions and keep it, but rather generate and analyze \
the possible coalitions sequentially. Each possible coalitions corresponds \
naturally to the base 2 representation of an integer between 1 and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["2", "n"], "-", "1"}], TraditionalForm]]],
  " (if the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th digits is a one, the party ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "k"], TraditionalForm]]],
  " is part of the coalition, otherwise not). For each quota, we compare the \
combined coalition power with the quotas and increment the counters for the \
winning coalitions. Because ",
  StyleBox["Compile", "MR"],
  " cannot return ragged arrays, we define the subsidiary function ",
  StyleBox["winningCoalitionDataC", "MR"],
  " that forms the nested lists of total winning coalitions and winning \
coalitions that the individual parties are members of."
}], "Text"],

Cell[TextData[{
  "winningCoalitionDataC[partyPowers_List, quotas_List] :=\nModule[{resC = \
winningCoalitionDataMainC[partyPowers, quotas]},\n ",
  StyleBox["(* separate total number of winning coalitions from party \
counters *)", "CodeComment"],
  "\n Transpose[{Take[resC, Length[quotas]], \n            \
Partition[Drop[resC, Length[quotas]], Length[partyPowers]]}]]"
}], "Input"],

Cell[TextData[{
  "winningCoalitionDataMainC =\nCompile[{{partyPowers, _Real, 1}, {quotas, \
_Real, 1}},\nModule[{o = Length[partyPowers], n = Length[quotas], L, l, \
weight, \n        winningCoalitionCounters, \
winningParticipatingCoalitionCounters}, \n        l = Array[1&, {o}]; L = \
Array[1&, {o}];\n        ",
  StyleBox["(* winning coalition counters *)", "CodeComment"],
  "\n        winningCoalitionCounters = Array[0&, {n}];\n        \
winningParticipatingCoalitionCounters = Table[Array[0&, {o}], {n}];\n ",
  StyleBox["(* loop of all possible (2^n - 1) coalitions *)", "CodeComment"],
  "\n Do[",
  StyleBox["(* coalition weight *)", "CodeComment"],
  "\n    l = IntegerDigits[k, 2, o]; weight = l.partyPowers;\n    ",
  StyleBox["(* compare colation weight with all quotas *)", "CodeComment"],
  "\n    Do[If[weight > quotas[[j]], \n          ",
  StyleBox["(* increase coalition counters *)", "CodeComment"],
  "\n          winningCoalitionCounters[[j]] =  winningCoalitionCounters[[j]] \
+ 1;\n          winningParticipatingCoalitionCounters[[j]] = \n               \
  winningParticipatingCoalitionCounters[[j]] + l],\n       {j, n}],\n    {k, \
2^o}];\n  ",
  StyleBox["(* form one list because Compile must return a tensor *)", 
    "CodeComment"],
  "\n  Join[winningCoalitionCounters, \n       \
Flatten[winningParticipatingCoalitionCounters]]],\n                           \
               {{_IntegerDigits, _Integer, 1}}];"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["winningCoalitionDataMainC", "MR"],
  " compiled flawlessly."
}], "Text"],

Cell["Union[Head /@ Flatten[winningCoalitionDataMainC[[4]]]]", "Input"],

Cell["\<\
Here is a simple example for five parties. Seven winning coalitions \
can be formed to reach a 2/3 majority.\
\>", "Text"],

Cell["winningCoalitionDataC[{5, 4, 3, 2, 1}, {10}]", "Input"],

Cell["Plus @@ {5, 4, 3, 2, 1}", "Input"],

Cell["Here is the list of EU country weights.", "Text"],

Cell[TextData[{
  "weightsEU = ",
  StyleBox["(* appriximate square root of population \n               \
measured in million people *)", "CodeComment"],
  "\n            {9.09 ",
  StyleBox["(* Germany *)", "CodeComment"],
  ", 7.72 ",
  StyleBox["(* France *)", "CodeComment"],
  ", 7.69 ",
  StyleBox["(* U.K. *)", "CodeComment"],
  ", \n             7.55 ",
  StyleBox["(* Italy *)", "CodeComment"],
  ", 6.38 ",
  StyleBox["(* Spain *)", "CodeComment"],
  ", 6.18 ",
  StyleBox["(* Poland *)", "CodeComment"],
  ", \n             4.02 ",
  StyleBox["(* Netherlands *)", "CodeComment"],
  ", 3.32 ",
  StyleBox["(* Greece *)", "CodeComment"],
  ", 3.23 ",
  StyleBox["(* Portugal *)", "CodeComment"],
  ", \n             3.22 ",
  StyleBox["(* Belgium *)", "CodeComment"],
  ", 3.19 ",
  StyleBox["(* Czech Republic *)", "CodeComment"],
  ", 3.19 ",
  StyleBox["(* Hungary *), \n             ", "CodeComment"],
  "2.99 ",
  StyleBox["(* Sweden *)", "CodeComment"],
  ", 2.84 ",
  StyleBox["(* Austria *)", "CodeComment"],
  ", 2.32 ",
  StyleBox["(* Denmark *)", "CodeComment"],
  ", \n             2.32 ",
  StyleBox["(* Slovakia *)", "CodeComment"],
  ", 2.28 ",
  StyleBox["(* Finland *)", "CodeComment"],
  ", 1.99 ",
  StyleBox["(* Ireland *)", "CodeComment"],
  ", \n             1.86 ",
  StyleBox["(* Lithuania *)", "CodeComment"],
  ", 1.53 ",
  StyleBox["(* Latvia *)", "CodeComment"],
  ", 1.41 ",
  StyleBox["(* Slovenia *)", "CodeComment"],
  ", \n             1.17 ",
  StyleBox["(* Estonia *)", "CodeComment"],
  ", 0.89 ",
  StyleBox["(* Cyprus *)", "CodeComment"],
  ", 0.67 ",
  StyleBox["(* Luxembourg *)", "CodeComment"],
  ", \n             0.63 ",
  StyleBox["(* Malta *)", "CodeComment"],
  "};"
}], "Input"],

Cell["\<\
To obtain a 51% majority vote, approximately 15 million winning \
coalitions can be formed. Analyzing all possible 33 million coalitions takes \
only minutes.\
\>", "Text"],

Cell["\<\
winningCoalitionDataC[weightsEU, {0.51 (Plus @@ weightsEU)}] // \
Timing\
\>", "Input"],

Cell["\<\
Given the counts of the winning coalitions, it is straightforward \
to define the Banzhaf indices.\
\>", "Text"],

Cell["\<\
BanzhafIndices[partyPowers_, quotas_] := 
  ((2 #2 - #1)/2^(Length[partyPowers] - 1))& @@@ 
             winningCoalitionDataC[partyPowers, quotas]\
\>", "Input"],

Cell["\<\
BanzhafIndicesNormalized[partyPowers_, quotas_] := 
  #/(Plus @@ #)& /@ BanzhafIndices[partyPowers, quotas]\
\>", "Input"],

Cell["\<\
For a 51% majority vote, the Banzhaf indices deviate substantially \
from the country weights. The larger countries have too much weight, and the \
smaller to little.\
\>", "Text"],

Cell["\<\
BanzhafIndicesNormalized[weightsEU, {0.51 (Plus @@ weightsEU)}] // \
N\
\>", "Input"],

Cell[TextData[{
  "To obtain a quota such that the country weights agree approximately with \
their Banzhaf indices, we will minimize the sum of the squares of the \
differences between the country weights and their Banzhaf indices. The \
function ",
  StyleBox["votingResiduals", "MR"],
  " defines the square root of these sum of squares."
}], "Text"],

Cell["\<\
votingResiduals[partyPowers_, quotas_] :=
Module[{bhN = BanzhafIndicesNormalized[partyPowers, quotas], 
        sqL = #/(Plus @@ #)&[partyPowers]},
       Sqrt[Plus @@ ((# - sqL)^2)]& /@ bhN]\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["votingResidualsTable", "MR"],
  " generates a list of the just\[Hyphen]defined sums of squares for ",
  StyleBox["pp", "TI"],
  " quotas from the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{
            StyleBox["quota0",
              "TI"], ",", 
            StyleBox["quota1",
              "TI"]}], "]"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
votingResidualsTable[partyPowers_, {quota0_, quota1_}, pp_] :=
Module[{relQuotas = Table[q, {q, quota0, quota1, (quota1 - quota0)/pp}], 
        weightSum = Plus @@ partyPowers},
 Transpose[{relQuotas, votingResiduals[partyPowers, relQuotas weightSum]}]]\
\
\>", "Input"],

Cell["\<\
For comparison, we 10 times choose randomly 18 party weights that \
are uniformly, exponentially, and normally distributed. Approximate equality \
between the given voting power and the Banzhaf indices happens for quotas \
around 60% \[Ellipsis] 65%.\
\>", "Text"],

Cell[TextData[{
  "SeedRandom[1]\n\nModule[{partyPowers, parties = 18, elections = 10, quotas \
= 50}, \nShow[GraphicsArray[\n Function[\[ScriptP], Graphics[\n  \
Table[partyPowers = Table[\[ScriptP][Random[]], {parties}];\n        ",
  StyleBox["(* random color for each party-weight list *)", "CodeComment"],
  "\n        {Hue[Random[]], PointSize[0.006], Point /@ \n               \
votingResidualsTable[partyPowers, {0.5, 0.75}, quotas]}, \n        \
{elections}], \n       PlotRange -> All, Frame -> True, Axes -> False, Frame \
-> True]] /@\n       ",
  StyleBox["(* uniform, exponential, and normal distribution *)", 
    "CodeComment"],
  "\n       {Identity, -Log[1 - #]&, Abs[2 + InverseErf[2 # - 1]]&}]]];"
}], "Input"],

Cell["\<\
For the current EU weights, we obtain approximate equality between \
the given voting power and the Banzhaf indices for a quota of 62%. Zooming \
into the minima (right graphic) shows that 62% is an excellent approximation \
for the optimal quota.\
\>", "Text"],

Cell["\<\
(res = votingResidualsTable[weightsEU, {0.5, 0.75}, 50]); // Timing
resD = votingResidualsTable[weightsEU, {0.615, 0.625}, 25];
Show[GraphicsArray[
      ListPlot[#, PlotRange -> All, Frame -> True, Axes -> False,
               DisplayFunction -> Identity]& /@ {res, resD}]]\
\>", "Input"],

Cell[TextData[{
  "Because the voting weights all have two decimal digits, not a single point\
\[Hyphen]minimum for the sum of squares can be found. The next graphic shows \
a close\[Hyphen]up around the minimum. The optimal quota is the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0.6201", ",", " ", "0.6202"}], "]"}], TraditionalForm]]],
  " and the square root of the differences becomes about 0.000309\.13. Also, \
at this resolution, the sum of squares is no longer a monotonic function to \
the left and right of the optimal quota."
}], "Text"],

Cell["\<\
resD = votingResidualsTable[weightsEU, {0.619, 0.621}, 100];
Show[GraphicsArray[
      ListPlot[#, PlotRange -> All, Frame -> True, Axes -> False,
               DisplayFunction -> Identity]& /@ {resD}]]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "13.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Wave Propagation on a Torus"
}], "ExerciseHeading"],

Cell["\<\
Make an animation showing how an initially localized perturbation \
evolves on a torus under the wave equation\
\>", "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        FractionBox[
          RowBox[{
            SuperscriptBox["\[PartialD]", "2"], 
            RowBox[{"\[Psi]", "(", 
              RowBox[{
                RowBox[{"t", ";", 
                  SubscriptBox["\[CurlyPhi]", "1"]}], ",", 
                SubscriptBox["\[CurlyPhi]", "2"]}], ")"}]}], 
          RowBox[{"\[PartialD]", 
            SuperscriptBox["t", "2"]}]], "=", 
        RowBox[{"\[CapitalDelta]", " ", 
          RowBox[{"\[Psi]", "(", 
            RowBox[{
              RowBox[{"t", ";", 
                SubscriptBox["\[CurlyPhi]", "1"]}], ",", 
              SubscriptBox["\[CurlyPhi]", "2"]}], ")"}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{"\[CapitalDelta]", "=", 
        RowBox[{
          FractionBox["1", 
            SqrtBox[
              RowBox[{"g", "(", 
                RowBox[{
                  SubscriptBox["\[CurlyPhi]", "1"], ",", 
                  SubscriptBox["\[CurlyPhi]", "2"]}], ")"}]]], 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"i", ",", 
                RowBox[{"j", "=", "1"}]}], "2"], 
            RowBox[{
              FractionBox["\[PartialD]", 
                RowBox[{"\[PartialD]", 
                  SubscriptBox["\[CurlyPhi]", "i"]}]], 
              RowBox[{
                RowBox[{"(", 
                  RowBox[{
                    SqrtBox[
                      RowBox[{"g", "(", 
                        RowBox[{
                          SubscriptBox["\[CurlyPhi]", "1"], ",", 
                          SubscriptBox["\[CurlyPhi]", "2"]}], ")"}]], 
                    RowBox[{
                      SuperscriptBox["g", 
                        RowBox[{"i", " ", "j"}]], "(", 
                      RowBox[{
                        SubscriptBox["\[CurlyPhi]", "1"], ",", 
                        SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], 
                    FractionBox["\[PartialD]", 
                      RowBox[{"\[PartialD]", 
                        SubscriptBox["\[CurlyPhi]", "j"]}]]}], ")"}], 
                "."}]}]}]}]}], TraditionalForm]}], "DisplayFormula"],

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["g", 
            RowBox[{"i", " ", "j"}]], "(", 
          RowBox[{
            SubscriptBox["\[CurlyPhi]", "1"], ",", 
            SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], TraditionalForm]]],
  " is the metric tensor and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"g", "(", 
          RowBox[{
            SubscriptBox["\[CurlyPhi]", "1"], ",", 
            SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], TraditionalForm]]],
  " its determinant."
}], "Text"],

Cell[TextData[{
  "Use the torus parametrization ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                SubscriptBox["r", "1"], "+", 
                RowBox[{
                  SubscriptBox["r", "2"], 
                  RowBox[{"cos", "(", 
                    SubscriptBox["\[CurlyPhi]", "2"], ")"}]}]}], ")"}], 
            RowBox[{"cos", "(", 
              SubscriptBox["\[CurlyPhi]", "1"], ")"}]}]}], 
        TraditionalForm]]],
  ",  ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                SubscriptBox["r", "1"], "+", 
                RowBox[{
                  SubscriptBox["r", "2"], 
                  RowBox[{"cos", "(", 
                    SubscriptBox["\[CurlyPhi]", "2"], ")"}]}]}], ")"}], 
            RowBox[{"sin", "(", 
              SubscriptBox["\[CurlyPhi]", "1"], ")"}]}]}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          FormBox[
            RowBox[{"z", "=", 
              RowBox[{
                SubscriptBox["r", "2"], 
                RowBox[{"sin", "(", 
                  SubscriptBox["\[CurlyPhi]", "2"], ")"}]}]}],
            "TraditionalForm"]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by deriving the explicit form of the Laplace operator in ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  "\[Hyphen]coordinates. This is the metric tensor ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["g", 
            RowBox[{"i", " ", "j"}]], "(", 
          RowBox[{
            SubscriptBox["\[CurlyPhi]", "1"], ",", 
            SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], TraditionalForm]]],
  " ."
}], "SolutionSubgroup"],

Cell[TextData[{
  StyleBox["(* calculate g_ij *)", "CodeComment"],
  "\n\[ScriptX]\[ScriptY]\[ScriptZ] = {(r1 + r2 Cos[\[CurlyPhi][2]]) Cos[\
\[CurlyPhi][1]], (r1 + r2 Cos[\[CurlyPhi][2]]) Sin[\[CurlyPhi][1]], r2 Sin[\
\[CurlyPhi][2]]};\n{\[ScriptX]\[ScriptY]\[ScriptZ]\[CurlyPhi]1, \[ScriptX]\
\[ScriptY]\[ScriptZ]\[CurlyPhi]2} = D[\[ScriptX]\[ScriptY]\[ScriptZ], #]& /@ \
{\[CurlyPhi][1], \[CurlyPhi][2]};\ngll = {{\[ScriptX]\[ScriptY]\[ScriptZ]\
\[CurlyPhi]1.\[ScriptX]\[ScriptY]\[ScriptZ]\[CurlyPhi]1, \[ScriptX]\[ScriptY]\
\[ScriptZ]\[CurlyPhi]1.\[ScriptX]\[ScriptY]\[ScriptZ]\[CurlyPhi]2}, {\
\[ScriptX]\[ScriptY]\[ScriptZ]\[CurlyPhi]1.\[ScriptX]\[ScriptY]\[ScriptZ]\
\[CurlyPhi]2, \[ScriptX]\[ScriptY]\[ScriptZ]\[CurlyPhi]2.\[ScriptX]\[ScriptY]\
\[ScriptZ]\[CurlyPhi]2}}"
}], "Input"],

Cell["The line element has a very simple form.", "Text"],

Cell["g = Det[gll] // Simplify", "Input"],

Cell[TextData[{
  "And here is the Laplace operator in ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  "\[Hyphen]coordinates [",
  
  CounterBox["BibliographyCounter", "Encinosa03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Encinosa03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Encinosa04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Encinosa04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". "
}], "Text"],

Cell[TextData[{
  StyleBox["(* calculate g^ij *)", "CodeComment"],
  "\nguu = Factor //@ Together //@ Inverse[gll];\nSum[1/Sqrt[g] D[Sqrt[g] \
guu[[i, j]] D[\[CapitalPsi][\[CurlyPhi][1], \[CurlyPhi][2]], \[CurlyPhi][i]], \
\[CurlyPhi][j]], \n    {i, 2}, {j, 2}] // FullSimplify"
}], "Input"],

Cell[TextData[{
  "We will, of course, solve the wave equation numerically for the torus. In \
the following, we choose the parameters ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["r", "1"], "=", "2"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["r", "2"], "=", "1"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["r1 = 1; r2 = 1/2;", "Input"],

Cell[TextData[{
  "For an animation, we have to calculate many frames. To carry out the \
numerical PDE solution in an memory\[Hyphen]efficient manner, we will use the \
functions ",
  StyleBox["NDSolve`ProcessEquations", "MR"],
  " and ",
  StyleBox["NDSolve`Iterate", "MR"],
  ". The following input sets up the problem. We use an initially localized, \
smooth perturbation. Because of the periodic boundary conditions in ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyPhi]", "2"], TraditionalForm]]],
  ", we use the ",
  StyleBox["\"Pseudospectral\"", "MR"],
  " method setting for the method of lines."
}], "Text"],

Cell[TextData[{
  "{state} = \nNDSolve`ProcessEquations[{D[u[t, \[CurlyPhi]1, \[CurlyPhi]2], \
t, t] == \n   1/r2^2 D[u[t, \[CurlyPhi]1, \[CurlyPhi]2], \[CurlyPhi]2, \
\[CurlyPhi]2] - \n   Sin[\[CurlyPhi]2]/(r1 + r2 Cos[\[CurlyPhi]2]) D[u[t, \
\[CurlyPhi]1, \[CurlyPhi]2], \[CurlyPhi]2] +\n   1/(r1 + r2 \
Cos[\[CurlyPhi]2])^2 D[u[t, \[CurlyPhi]1, \[CurlyPhi]2], \[CurlyPhi]1, \
\[CurlyPhi]1],\n  ",
  StyleBox["(* periodic boundary conditions in \[CurlyPhi]1, \[CurlyPhi]2 *)",
     "CodeComment"],
  "\n  u[t, -Pi, \[CurlyPhi]2] == u[t, +Pi, \[CurlyPhi]2],\n  Derivative[0, \
1, 0][u][t, -Pi, \[CurlyPhi]2] == Derivative[0, 1, 0][u][t, +Pi, \
\[CurlyPhi]2],\n  u[t, \[CurlyPhi]1, -Pi] == u[t, \[CurlyPhi]1, +Pi],\n  \
Derivative[0, 0, 1][u][t, \[CurlyPhi]1, -Pi] == Derivative[0, 0, 1][u][t, \
\[CurlyPhi]1, +Pi],\n  ",
  StyleBox["(* initial perturbation *)", "CodeComment"],
  "\n  u[0, \[CurlyPhi]1, \[CurlyPhi]2] == If[Sqrt[\[CurlyPhi]1^2 + \
\[CurlyPhi]2^2] < 1/3 Pi, \n                 (Sign[#] #^2)&[Cos[3/2 Pi Sqrt[\
\[CurlyPhi]1^2 + \[CurlyPhi]2^2]/(1/3 Pi)]], 0], \n  Derivative[1, 0, \
0][u][0, \[CurlyPhi]1, \[CurlyPhi]2] == 0},\n  {}, t, {\[CurlyPhi]1, -Pi, \
Pi}, {\[CurlyPhi]2, -Pi, Pi},\n  ",
  StyleBox["(* option settings for the numerical solution *)", 
    "CodeComment"],
  "\n  MaxSteps -> 10^5, PrecisionGoal -> 2, AccuracyGoal -> 2, \n  Method -> \
{\"MethodOfLines\", \"SpatialDiscretization\" -> \n              \
{\"TensorProductGrid\", \"DifferenceOrder\" -> \"Pseudospectral\", \n         \
      \"MaxPoints\" -> {120, 60}, \"MinPoints\" -> {120, 60}}}]"
}], "Input"],

Cell[TextData[{
  "To visualize the propagation of the perturbation on the torus surface, we \
implement a function ",
  StyleBox["coloredTorusPlot3D", "MR"],
  ". Unperturbed regions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", 
            RowBox[{
              SubscriptBox["\[CurlyPhi]", "1"], ",", 
              SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], "\[TildeTilde]", 
          "0"}], TraditionalForm]]],
  " are shown in green, positive perturbations ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", 
            RowBox[{
              SubscriptBox["\[CurlyPhi]", "1"], ",", 
              SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], ">", "0"}], 
        TraditionalForm]]],
  " in red, and negative perturbations ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", 
            RowBox[{
              SubscriptBox["\[CurlyPhi]", "1"], ",", 
              SubscriptBox["\[CurlyPhi]", "2"]}], ")"}], "<", "0"}], 
        TraditionalForm]]],
  " in blue. In addition, we represent the size of the perturbations as \
deformations of the torus in its local normal direction."
}], "Text"],

Cell[TextData[{
  "coloredTorusPlot3D[sols_, {pp\[CurlyPhi]1_, pp\[CurlyPhi]2_}, opts___] := \
\nModule[{\[Alpha] = 1/4, torusPoint, torusNormal, data, points, toColor, \
polys},\n ",
  StyleBox["(* point and normal on the torus *)", "CodeComment"],
  "\n torusPoint[{\[CurlyPhi]1_, \[CurlyPhi]2_}, r1_, r2_] = {r1 Cos[\
\[CurlyPhi]1] + r2 Cos[\[CurlyPhi]1] Cos[\[CurlyPhi]2],\n                     \
   r1 Sin[\[CurlyPhi]1] + r2 Sin[\[CurlyPhi]1] Cos[\[CurlyPhi]2], r2 Sin[\
\[CurlyPhi]2]};\n torusNormal[{\[CurlyPhi]1_, \[CurlyPhi]2_}, r1_, r2_] =  \n \
            {Cos[\[CurlyPhi]1] Cos[\[CurlyPhi]2], Cos[\[CurlyPhi]2] Sin[\
\[CurlyPhi]1], Sin[\[CurlyPhi]2]};\n ",
  StyleBox["(* scaled perturbations *)", "CodeComment"],
  "\n data = Table[Evaluate[{{\[CurlyPhi]1, \[CurlyPhi]2}, ArcTan[25 sols[[1, \
2]]]/(Pi/2)}], \n              {\[CurlyPhi]1, -Pi, Pi, 2Pi/pp\[CurlyPhi]1}, {\
\[CurlyPhi]2, -Pi, Pi, 2Pi/pp\[CurlyPhi]2}]; \n ",
  StyleBox["(* add perturbations in normal direction *)", "CodeComment"],
  "\n points = Apply[(torusPoint[#1, r1, r2] + \n                \[Alpha] r2 \
#2 torusNormal[#1, r1, r2])&, data, {2}];\n ",
  StyleBox["(* color according to perturbations *)", "CodeComment"],
  "\n toColor[x_] := SurfaceColor[#, #, 2.2]&[\n                \
RGBColor[UnitStep[x] x, 1 - Abs[x], -UnitStep[-x] x]];\n ",
  StyleBox["(* polygons *)", "CodeComment"],
  "\n polys = Table[{toColor[(data[[i, j, 2]] + data[[i + 1, j, 2]] + \n      \
                   data[[i + 1, j + 1, 2]] + data[[i, j + 1, 2]])/4], \n      \
          Polygon[{points[[i, j]], points[[i + 1, j]], \n                     \
    points[[i + 1,j + 1]], points[[i, j + 1]]}]}, \n               {i, \
Length[data] - 1}, {j, Length[data[[1]]] - 1}];\n ",
  StyleBox["(* graphics of the torus with perturbations *)", "CodeComment"],
  "\n Graphics3D[{EdgeForm[], polys}, opts, Boxed -> False, Axes -> False,\n  \
          PlotRange -> {{-2, 2}, {-2, 2}, {-3/4, 3/4}},\n            ",
  StyleBox["(* view toward initial perturbation *)", "CodeComment"],
  " \n            ViewPoint -> {3, 0, 2.4}]]"
}], "Input"],

Cell[TextData[{
  "Now, it is straightforward to propagate the solution forward in time and \
to visualize the resulting wave propagation. The function ",
  StyleBox["waveEquationTorusAnimation", "MR"],
  " generates the actual animation."
}], "Text"],

Cell[TextData[{
  "waveEquationTorusAnimation[\[CapitalDelta]T_, frames_, DoTable_, showIt_, \
{pp\[CurlyPhi]1_, pp\[CurlyPhi]2_}] := \nModule[{uCurrent},\nDoTable[",
  StyleBox["(* visualize solution *)", "CodeComment"],
  " \n        ",
  StyleBox["(* solve wave equation in time steps *)", "CodeComment"],
  "\n        NDSolve`Iterate[state, j \[CapitalDelta]T];\n        ",
  StyleBox["(* form current solution *)", "CodeComment"],
  "\n        uCurrent = NDSolve`ProcessSolutions[state, \"Forward\"];\n       \
 showIt @ coloredTorusPlot3D[uCurrent, {pp\[CurlyPhi]1, pp\[CurlyPhi]2}],\n   \
     {j, 0, frames}]]"
}], "Input"],

Cell[TextData[{
  "And here is the resulting animation. Due to the superposition of the wave \
contributions along different rays, we see complicated time\[Hyphen]dependent \
patterns emerge. Interestingly, in the beginning the initial pulse splits \
into four single pulse, two traveling along the \[OpenCurlyDoubleQuote]small\
\[CloseCurlyDoubleQuote] circumference and two traveling along the \
\[OpenCurlyDoubleQuote]large\[CloseCurlyDoubleQuote] circumference. From the \
2D nature of the torus surface one might expect a approximately radial \
propagation of the initial disturbance. So, in some sense, the wave \
propagation on this torus is more in ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[DoubleStruckCapitalR]", "1"], "\[Times]", 
          SuperscriptBox["\[DoubleStruckCapitalR]", "1"]}], 
        TraditionalForm]]],
  " than in ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[DoubleStruckCapitalR]", "2"], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ 
     Partition[waveEquationTorusAnimation[2/3, 8, Table, Identity, {240, \
120}], 3]\
\>", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "4_1_WaveOnTorus.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["waveEquationTorusAnimation[1/10, 90, Do, Show, {240, 120}]", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Numerics Volume, Chapter 2", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Infinite ",
  Cell[BoxData[
      FormBox["cos", TraditionalForm]]],
  " Product Integral"
}], "ExerciseHeading"],

Cell[TextData[{
  "Show through numeric integration that the following integral [",
  
  CounterBox["BibliographyCounter", "Borwein03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Borwein03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Borwein04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Borwein04",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        UnderoverscriptBox["\[Integral]", "0", "\[Infinity]"], 
        RowBox[{
          RowBox[{"cos", "(", 
            RowBox[{"2", "z"}], ")"}], 
          RowBox[{"(", 
            RowBox[{
              UnderoverscriptBox["\[Product]", 
                RowBox[{"k", "=", "1"}], "\[Infinity]"], 
              RowBox[{"cos", "(", 
                FractionBox["z", "k"], ")"}]}], ")"}], "d", 
          "\[InvisibleSpace]", "z"}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "equals ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "8"}], TraditionalForm]]],
  " to 42 digits. For the numerical calculation of the infinite product, make \
use of the expansion "
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"ln", "(", 
          RowBox[{"cos", "(", "z", ")"}], ")"}], "=", 
        RowBox[{
          UnderoverscriptBox["\[Sum]", 
            RowBox[{"j", "=", "1"}], "\[Infinity]"], 
          RowBox[{
            FractionBox[
              RowBox[{
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{"-", "1"}], ")"}], "j"], " ", 
                SuperscriptBox["2", 
                  RowBox[{
                    RowBox[{"2", " ", "j"}], "-", "1"}]], " ", 
                RowBox[{"(", 
                  RowBox[{
                    SuperscriptBox["4", "j"], "-", "1"}], ")"}], " "}], 
              RowBox[{"j", " ", 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{"2", " ", "j"}], ")"}], "!"}]}]], 
            SubscriptBox["B", 
              RowBox[{"2", "j"}]], 
            SuperscriptBox["z", 
              RowBox[{"2", "j"}]]}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "valid for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", "z", "\[RightBracketingBar]"}], "<",
           
          RowBox[{"\[Pi]", "/", "2"}]}], TraditionalForm]]],
  ". Here the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox[
          TagBox["B",
            BernoulliB], "k"], TraditionalForm]]],
  " are the Bernoulli numbers."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with the high\[Hyphen]precision calculation of the infinite \
product. To show that the integral agrees to 41 digits with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "8"}], TraditionalForm]]],
  ", we need the product correct to about 50 digits. A direct calculation of \
the product shows a very slow convergence. "
}], "SolutionSubgroup"],

Cell["\<\
Module[{z = 1, cosT}, 
       cosT = Table[Cos[N[z, 22]/k], {k, 1000}];
       ListPlot[Log[10, Abs[1 - cosT]]]];\
\>", "Input"],

Cell["\<\
To speed up the calculation of the infinite product, we split it \
into two parts:\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Product]", 
            RowBox[{"k", "=", "1"}], "\[Infinity]"], 
          RowBox[{"cos", "(", 
            FractionBox["z", "k"], ")"}]}], "=", 
        RowBox[{
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                UnderoverscriptBox["\[Product]", 
                  RowBox[{"k", "=", "1"}], 
                  SubscriptBox["k", "0"]], 
                RowBox[{"cos", "(", 
                  FractionBox["z", "k"], ")"}]}], ")"}], 
            RowBox[{"(", 
              RowBox[{
                UnderoverscriptBox["\[Product]", 
                  RowBox[{"k", "=", 
                    RowBox[{
                      SubscriptBox["k", "0"], "+", "1"}]}], "\[Infinity]"], 
                RowBox[{"cos", "(", 
                  FractionBox["z", "k"], ")"}]}], ")"}]}], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                UnderoverscriptBox["\[Product]", 
                  RowBox[{"k", "=", "1"}], 
                  SubscriptBox["k", "0"]], 
                RowBox[{"cos", "(", 
                  FractionBox["z", "k"], ")"}]}], ")"}], 
            RowBox[{"exp", "(", 
              RowBox[{
                UnderoverscriptBox["\[Sum]", 
                  RowBox[{"k", "=", 
                    RowBox[{
                      SubscriptBox["k", "0"], "+", "1"}]}], "\[Infinity]"], 
                RowBox[{"ln", "(", 
                  RowBox[{"cos", "(", 
                    FractionBox["z", "k"], ")"}], ")"}]}], ")"}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["k", "0"], TraditionalForm]]],
  " has to be chosen in such a way that ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"z", "/", 
            RowBox[{"(", 
              RowBox[{
                SubscriptBox["k", "0"], "+", "1"}], ")"}]}], "<", 
          RowBox[{"\[Pi]", "/", "2"}]}], TraditionalForm]]],
  " and the above expansion applies. The first product we calculate directly \
by carrying out the multiplications. For the tail part, we use the above \
expansion of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"ln", "(", 
          RowBox[{"cos", "(", "x", ")"}], ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Sum]", 
            RowBox[{"k", "=", 
              RowBox[{
                SubscriptBox["k", "0"], "+", "1"}]}], "\[Infinity]"], 
          RowBox[{"ln", "(", 
            RowBox[{"cos", "(", 
              FractionBox["z", "k"], ")"}], ")"}]}], "=", 
        RowBox[{
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", 
                RowBox[{
                  SubscriptBox["k", "0"], "+", "1"}]}], "\[Infinity]"], 
            RowBox[{
              UnderoverscriptBox["\[Sum]", 
                RowBox[{"j", "=", "1"}], "\[Infinity]"], 
              RowBox[{
                FractionBox[
                  RowBox[{
                    SuperscriptBox[
                      RowBox[{"(", 
                        RowBox[{"-", "1"}], ")"}], "j"], " ", 
                    SuperscriptBox["2", 
                      RowBox[{
                        RowBox[{"2", " ", "j"}], "-", "1"}]], " ", 
                    RowBox[{"(", 
                      RowBox[{
                        SuperscriptBox["4", "j"], "-", "1"}], ")"}], " "}], 
                  RowBox[{"j", " ", 
                    RowBox[{
                      RowBox[{"(", 
                        RowBox[{"2", " ", "j"}], ")"}], "!"}]}]], 
                SubscriptBox["B", 
                  RowBox[{"2", "j"}]], " ", 
                SuperscriptBox[
                  RowBox[{"(", 
                    FractionBox["z", "k"], ")"}], 
                  RowBox[{"2", "j"}]]}]}]}], "\[IndentingNewLine]", "=", 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"j", "=", "1"}], "\[Infinity]"], 
            RowBox[{
              FractionBox[
                RowBox[{
                  SuperscriptBox[
                    RowBox[{"(", 
                      RowBox[{"-", "1"}], ")"}], "j"], " ", 
                  SuperscriptBox["2", 
                    RowBox[{
                      RowBox[{"2", " ", "j"}], "-", "1"}]], " ", 
                  RowBox[{"(", 
                    RowBox[{
                      SuperscriptBox["4", "j"], "-", "1"}], ")"}], " "}], 
                RowBox[{"j", " ", 
                  RowBox[{
                    RowBox[{"(", 
                      RowBox[{"2", " ", "j"}], ")"}], "!"}]}]], 
              SubscriptBox["B", 
                RowBox[{"2", "j"}]], " ", 
              RowBox[{"\[Zeta]", "(", 
                RowBox[{
                  RowBox[{"2", "j"}], ",", 
                  RowBox[{
                    SubscriptBox["k", "0"], "+", "1"}]}], ")"}], 
              SuperscriptBox["z", 
                RowBox[{"2", "j"}]]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Zeta]", "(", 
            RowBox[{"s", ",", "a"}], ")"}], "=", 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", "a"}], "\[Infinity]"], 
            SuperscriptBox["k", 
              RowBox[{"-", "s"}]]}]}], TraditionalForm]]],
  ". This definition yields immediately the recursion ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Zeta]", "(", 
            RowBox[{"s", ",", 
              RowBox[{"a", "+", "1"}]}], ")"}], "=", 
          RowBox[{
            RowBox[{"\[Zeta]", "(", 
              RowBox[{"s", ",", "a"}], ")"}], "-", 
            SuperscriptBox["a", 
              RowBox[{"-", "s"}]]}]}], TraditionalForm]]],
  " starting with ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Zeta]", "(", 
            RowBox[{
              RowBox[{"2", "j"}], ",", "1"}], ")"}], "=", 
          RowBox[{"\[LeftBracketingBar]", " ", 
            RowBox[{
              SuperscriptBox["2", 
                RowBox[{
                  RowBox[{"2", " ", "j"}], "-", "1"}]], " ", 
              SuperscriptBox["\[Pi]", 
                RowBox[{"2", " ", "j"}]], " ", 
              RowBox[{
                SubscriptBox[
                  TagBox["B",
                    BernoulliB], 
                  RowBox[{"2", " ", "j"}]], "/", 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{"2", " ", "j"}], ")"}], "!"}]}]}], 
            "\[RightBracketingBar]"}]}], TraditionalForm]]],
  ". "
}], "Text"],

Cell[TextData[{
  "To calculate the last sum efficiently for many values of ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ", we write the terms of the sums a s a product of three terms: a ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["k", "0"], TraditionalForm]]],
  "\[Hyphen] and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]independent one, one that contains the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["k", "0"], TraditionalForm]]],
  "\[Hyphen]dependent term and the one that contains the ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]dependent one. Only the last has to be calculated for each value \
of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". The ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["k", "0"], TraditionalForm]]],
  "\[Hyphen]dependent terms we calculate recursively once. This yields the \
following implementation of a function ",
  StyleBox["makeListDefinitions", "MR"],
  " that calculates ",
  StyleBox["kMax", "TI"],
  " globally visible lists ",
  StyleBox["L2[", "MR"],
  StyleBox["k0", "TI"],
  StyleBox["]", "MR"],
  " and the globally visible list ",
  StyleBox["L1", "MR"],
  " to precision prec."
}], "Text"],

Cell[TextData[{
  "$MaxExtraPrecision = 10000;\n\nmakeListDefinitions[o_, kMax_, prec_] :=\n \
(Clear[L1, L2, L2E];\n  ",
  StyleBox["(* k0-independent terms *)", "CodeComment"],
  "\n  L1 = Table[((-1)^j 2^(2j - 1) (4^j - 1) BernoulliB[2j])/(j (2j)!), \n  \
           {j, o}] // N[#, prec]&; \n ",
  StyleBox[" (* calculate k0-dependent terms recursively *)", "CodeComment"],
  "\n  L2E[1] = Table[(-1)^(j - 1) 2^(2j - 1) Pi^(2j) BernoulliB[2j]/(2j)!, \
{j, o}];      \n  L2E[a_] := L2E[a] =  With[{temp = L2E[a - 1] - Table[(a - \
1)^(-2j), {j, o}]}, \n                            ",
  StyleBox["(* save memory *)", "CodeComment"],
  " L2E[a - 1] =.; temp];  \n  L2[k0_] := L2[k0] = L2E[k0 + 1] // N[#, \
prec]&;\n   ",
  StyleBox["(* make all L2's in order *)", "CodeComment"],
  "\n  Do[L2[k0], {k0, kMax}];)"
}], "Input"],

Cell[TextData[{
  "Using the lists ",
  StyleBox["L1", "MR"],
  " and ",
  StyleBox["L2", "MR"],
  " calculated through a call to ",
  StyleBox["makeListDefinitions", "MR"],
  " allows to calculate the infinite product through the function ",
  StyleBox["cos\[Infinity]Product", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "cos\[Infinity]Product[z_?NumberQ, z0_:1] := \nModule[{k0 = \
Ceiling[Abs[z/z0]], p1, p2, z2 = z^2}, \n       If[z == 0, 1, \n          ",
  StyleBox["(* direct product of first cosines *)", "CodeComment"],
  "\n          p1 = Product[Cos[z/k], {k, k0}]; \n          ",
  StyleBox["(* infinite tail approximation *)", "CodeComment"],
  "\n          L3 = NestList[(# z2)&, z2, Length[L1] - 1]; \n          p2 = \
Exp[(L1 L2[k0]).L3]; \n          ",
  StyleBox["(* product of initial and tail terms *)", "CodeComment"],
  " p1 p2]]"
}], "Input"],

Cell[TextData[{
  "Using 50 terms in the tail sum, we can reliably calculate the product for \
a visualization. The left graphic shows the product, and the right graphic \
shows the base 10 logarithm of its absolute value. We see an exponential \
decay for increasing ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
makeListDefinitions[50, 50, 50]

Show[GraphicsArray[
Block[{$DisplayFunction = Identity},
       {Plot[cos\[Infinity]Product[z], {z, 0, 2Pi}, PlotRange -> All],
        Plot[Log[10, Abs[cos\[Infinity]Product[z]]], {z, 0, 20 Pi}, 
             PlotRange -> All, PlotPoints -> 100]}]]]\
\>", "Input"],

Cell["\<\
Here is a view on the real part and the argument of the product \
over the complex plane.\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{$DisplayFunction = Identity},\n {",
  StyleBox["(* 3D plot of the real part *)", "CodeComment"],
  "            \n  Plot3D[Re[cos\[Infinity]Product[x + I y]], {x, -2Pi, 2Pi}, \
{y, -1, 1}, \n         PlotRange -> All, Mesh -> False, PlotPoints -> 200],\n \
 ",
  StyleBox["(* contour plot of the argument *)", "CodeComment"],
  "\n  ContourPlot[Arg[cos\[Infinity]Product[x + I y]], {x, -2Pi, 2Pi}, \n    \
          {y, -3/2, 3/2}, PlotRange -> All,\n              PlotPoints -> 200, \
ColorFunction -> (Hue[0.78 #]&)]}]]]"
}], "Input"],

Cell["\<\
To quantify the decay of the product along the real axis we fit a \
straight line to the successive local maxima.\
\>", "Text"],

Cell["\<\
Fit[Reverse[Rest[FoldList[{#2[[1]], Max[#2[[2]], #1[[2]]]}&, 
                    {-Infinity, -Infinity}, Rest[Reverse[
       Table[{z, Log[10, Abs[cos\[Infinity]Product[N[z, 50]]]]},  
             {z, 0, 20 Pi, 20 Pi/111}]]]]]], {z}, z] // N\
\>", "Input"],

Cell[TextData[{
  "We see that ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[CapitalPi]", "(", "x", ")"}], "\[Proportional]", 
          SuperscriptBox["10", 
            RowBox[{
              RowBox[{"-", "2"}], 
              RowBox[{"x", "/", "3"}]}]]}], TraditionalForm]]],
  ". Using this result, we define a function ",
  StyleBox["zMax", "MR"],
  " that for a given precision goal ",
  StyleBox["pg", "TI"],
  " for the integral under consideration, gives an upper integration limit so \
that the precision goal is met."
}], "Text"],

Cell[TextData[{
  "zMax[pg_] := Ceiling[3/2 pg] + ",
  StyleBox["(* to be save *)", "CodeComment"],
  " 10"
}], "Input"],

Cell[TextData[{
  "Now, we must determine how many terms ",
  StyleBox["kMax", "TI"],
  " to take into account in the ",
  StyleBox["L1", "MR"],
  ", ",
  StyleBox["L2", "MR"],
  " lists. When calculating the actual values of the product, we must make \
sure to calculate each function values with a sufficient precision. The sum \
in the exponent becomes less precise for increasing ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". "
}], "Text"],

Cell["\<\
With[{\[Zeta] = 50}, ListPlot[Log[10, N @ Abs[L1 L2[\[Zeta]] Table[\
\[Zeta]^(2 k), {k, 50}]]]]];\
\>", "Input"],

Cell[TextData[{
  "Approximately, we have ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[Sigma]", "k"], "(", "z", ")"}], "\[Proportional]",
           
          SuperscriptBox["10", 
            RowBox[{
              RowBox[{"-", "2"}], 
              RowBox[{"k", "/", "5"}]}]]}], TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Sigma]", "k"], "(", "z", ")"}], TraditionalForm]]],
  " is the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th term in the sum."
}], "Text"],

Cell["\<\
Fit[Log[10, N @ Abs[L1 L2[50] Table[50^(2 k), {k, 50}]]], {k}, k]\
\
\>", "Input"],

Cell["\<\
makeListDefinitions[75, 75, 100];
Fit[Log[10, N @ Abs[L1 L2[75] Table[75^(2 k), {k, 75}]]], {z}, z]\
\>", \
"Input"],

Cell[TextData[{
  "Given the upper integration limit ",
  StyleBox["zMax", "MR"],
  ", we define a function ",
  StyleBox["kMax", "MR"],
  " that yields the number of needed terms ",
  StyleBox["kMax", "TI"],
  "."
}], "Text"],

Cell[TextData[{
  "kMax[zMax_] := Ceiling[5/2 zMax] + ",
  StyleBox["(* to be save *)", "CodeComment"],
  " 10"
}], "Input"],

Cell[TextData[{
  "Now, we have all ingredients together to define the function ",
  StyleBox["integrateCosProduct", "MR"],
  " that carries out the numerical integration and yields a ",
  StyleBox["pg", "TI"],
  "\[Hyphen]digits approximation of the integral. We use the ",
  StyleBox["GaussKronrod", "MR"],
  " method and split the integration interval into subintervals of length ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"\[Delta]", 
            StyleBox["Z",
              FontSlant->"Italic"]}]], TraditionalForm]]],
  ". "
}], "Text"],

Cell[TextData[{
  "integrateCosProduct[pg_, wPrec_:Automatic, \n                    \
\[Delta]Z_:2Pi, showFunctionEvaluations_:True] := \nModule[{Z, \[ScriptK], H, \
g2, sum = 0}, \n If[wPrec === Automatic, wp = 3 pg, wp = wPrec];\n ",
  StyleBox["(* calculate needed z-range and number of terms *)", 
    "CodeComment"],
  " \n Z = zMax[pg]; \[ScriptK] = kMax[Z]; H = Ceiling[Z/\[Delta]Z]; \n ",
  StyleBox["(* prepare fast numerical evaluation of the product *)", 
    "CodeComment"],
  " \n makeListDefinitions[\[ScriptK], Ceiling[H \[Delta]Z], wp];\n ",
  StyleBox["(* define function to integrate *)", "CodeComment"],
  "\n g2[z_?NumberQ] := Cos[2 z] cos\[Infinity]Product[z];\n ",
  StyleBox["(* integrate g2 in intervals *)", "CodeComment"],
  " \n Do[int = NIntegrate[g2[z], {z, j \[Delta]Z, (j + 1) \[Delta]Z}, \n     \
                 WorkingPrecision -> wp, Method -> GaussKronrod, \n           \
           PrecisionGoal -> pg, AccuracyGoal -> pg,\n                      \
MaxRecursion -> 8];\n    sum = sum + int, {j, 0, H - 1}];\n",
  StyleBox["(* return integral *)", "CodeComment"],
  " N[sum, pg]]"
}], "Input"],

Cell["integrateCosProduct[50]", "Input"],

Cell[TextData[{
  "Interestingly, the difference to ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "8"}], TraditionalForm]]],
  " is only ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"7.4", 
            SuperscriptBox["\[Ellipsis]10", 
              RowBox[{"-", "43"}]]}],
          ZeroWidthTimes->True], TraditionalForm]]],
  "."
}], "Text"],

Cell["N[Pi/8, 50]", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " \[Pi]\[Hyphen]Related Sequence"
}], "ExerciseHeading"],

Cell[TextData[{
  "Find integers ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["a", "k"], "\[Element]", 
          RowBox[{"{", 
            RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}]}], 
        TraditionalForm]]],
  ", such that the following identity holds within 100 digits of precision."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["a", "0"], "+", 
          FractionBox["1", 
            StyleBox[
              RowBox[{
                FractionBox[
                  SubscriptBox["a", "1"], "\[Pi]"], "+", 
                FractionBox["1", 
                  StyleBox[
                    RowBox[{
                      FractionBox[
                        SubscriptBox["a", "2"], "\[Pi]"], "+", 
                      FractionBox["1", 
                        StyleBox[
                          RowBox[{
                            FractionBox[
                              SubscriptBox["a", "3"], "\[Pi]"], "+", 
                            FractionBox["1", "\[Ellipsis]"]}],
                          ScriptLevel->0]]}],
                    ScriptLevel->0]]}],
              ScriptLevel->0]]}], "=", 
        RowBox[{
          SubscriptBox["a", "0"], "+", 
          FractionBox[
            SubscriptBox["a", "1"], "\[Pi]"], "+", 
          FractionBox[
            SubscriptBox["a", "2"], 
            SuperscriptBox["\[Pi]", "2"]], "+", 
          FractionBox[
            SubscriptBox["a", "3"], 
            SuperscriptBox["\[Pi]", "3"]], "+", "\[Ellipsis]"}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[CellGroupData[{

Cell[TextData[{
  "Because the difference of the right\[Hyphen]hand side and the \
left\[Hyphen]hand side will be a nonmonotonic function of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["a", "k"], TraditionalForm]]],
  ", we cannot use a greedy algorithm to find the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["a", "k"], TraditionalForm]]],
  ". So we will \[OpenCurlyDoubleQuote]look ahead\[CloseCurlyDoubleQuote] and \
select from all possible sequence continuations the best one, then drop the \
last few terms and continue recursively. The function ",
  StyleBox["nextBestApproximation", "MR"],
  " finds the best approximation to the difference between the continued \
fraction and the power series of the constant ",
  Cell[BoxData[
      FormBox["\[ScriptC]", TraditionalForm]]],
  " using digits from the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"1", ",", "o"}], "]"}], TraditionalForm]]],
  ", and \[OpenCurlyDoubleQuote]look ahead\[CloseCurlyDoubleQuote] ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " terms. We start with the already calculated sequence terms ",
  StyleBox["cA", "TI"],
  "."
}], "SolutionSubgroup"],

Cell[TextData[{
  "nextBestApproximation[cA_, \[ScriptC]_, n_, o_] :=\nModule[{\[Lambda] = \
Length[cA](*, min\[Delta], prec, cASeriesPart, \[ScriptC]NList, cfF, \n       \
 newTerms, L, aux, bS*)},\n ",
  StyleBox["(* difference between continued fraction and power series *)", 
    "CodeComment"],
  "\n min\[Delta] = Infinity; \n ",
  StyleBox["(* precision needed for a reliable calculation *)", 
    "CodeComment"],
  "\n prec = Ceiling[Abs[Log[10, N[\[ScriptC]^(\[Lambda] + n)]]]] + 20; \
\[ScriptC]N = N[\[ScriptC], prec]; \n ",
  StyleBox["(* existing power series part--avoid multiple evaluation *)", 
    "CodeComment"],
  "\n cASeriesPart = cA.(\[ScriptC]N^Range[0, \[Lambda] - 1]); \n ",
  StyleBox["(* powers of the constant *)", "CodeComment"],
  "\n \[ScriptC]NList = \[ScriptC]N^Range[Length[cA], \[Lambda] + n - 1];\n \
",
  StyleBox["(* factors of the continued fraction *)", "CodeComment"],
  "\n cfF = Table[If[j == 0, 1, \[ScriptC]N], {j, 0, \[Lambda] + n - 1}];\n \
",
  StyleBox["(* new series terms *)", "CodeComment"],
  "\n newTerms = Table[t[k], {k, n}];\n ",
  StyleBox["(* find best possible of the o^n possible continuations *)", 
    "CodeComment"],
  "\n Do[L = Join[cA, newTerms];\n    ",
  StyleBox["(* difference between continued fraction and power series *)", 
    "CodeComment"],
  "\n    aux = Abs[FromContinuedFraction[cfF L] - cASeriesPart - newTerms.\
\[ScriptC]NList];\n    If[aux < min\[Delta], min\[Delta] = aux; bS = L],\n    \
",
  StyleBox["(* generate iterators *)", "CodeComment"],
  "\n    Evaluate[Sequence @@ ({#, o}& /@ newTerms)]]; \n ",
  StyleBox["(* return best sequence continuation and difference *)", 
    "CodeComment"],
  "\n   {bS, N @ min\[Delta]}]"
}], "Input"],

Cell["\<\
If we do not take enough \[OpenCurlyDoubleQuote]look ahead\
\[CloseCurlyDoubleQuote] terms, the process of finding the next series terms \
gets stuck.\
\>", "Text"],

Cell["\<\
NestList[nextBestApproximation[Drop[#[[1]], 
             If[Length[#[[1]]] < 2, 0, -2]], 1/Pi, 3, 4]&, 
         {{}, Infinity}, 20]\
\>", "Input"],

Cell[TextData[{
  "Next, we use six \[OpenCurlyDoubleQuote]look ahead\[CloseCurlyDoubleQuote] \
terms and discard five of them after each call to ",
  StyleBox["nextBestApproximation", "MR"],
  ". This time, we do not get stuck so early."
}], "Text"],

Cell["\<\
NestList[nextBestApproximation[Drop[#[[1]], 
             If[Length[#[[1]]] < 5, 0, -5]], 1/Pi, 6, 4]&, 
        {{}, Infinity}, 20]\
\>", "Input"],

Cell["\<\
Running now the following input for several hours, we get the \
sequence we are looking for.\
\>", "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "   "
}], "ProgramLabel"],

Cell[TextData[{
  "NestList[(",
  StyleBox["(* see progress *)", "CodeComment"],
  " Print[#]; \n          nextBestApproximation[Drop[#[[1]], \n               \
   Max[0, Length[#[[1]] - 7]]], 1/Pi, 8, 4])&, \n         {{}, Infinity}, \
12]"
}], "Program"],

Cell["", "ProgramBottom"],

Cell["\<\
\[Pi]CFPSSequence = {1, 2, 1, 1, 4, 1, 3, 1, 3, 3, 3, 4, 2, 3, 3, \
2, 3, 4, 3, 2, 3, 
  4, 4, 3, 2, 3, 3, 1, 2, 3, 4, 2, 4, 2, 1, 4, 1, 2, 1, 2, 2, 2, 1, 4, 1, 2, \
3, 
  3, 1, 3, 3, 3, 4, 4, 1, 2, 4, 3, 4, 3, 4, 4, 3, 4, 4, 4, 1, 4, 1, 3, 4, 4, \
1, 
  4, 4, 4, 3, 4, 1, 2, 3, 1, 2, 1, 3, 3, 4, 1, 2, 3, 4, 3, 3, 3, 3, 2, 2, 4, \
3, 
  4, 2, 4, 3, 4, 4, 1, 3, 4, 4, 2, 1, 4, 4, 3, 4, 1, 1, 2, 2, 3, 3, 1, 1, 2, \
4, 
  1, 4, 1, 3, 1, 1, 3, 3, 4, 2, 3, 4, 3, 3, 2, 1, 1, 4, 1, 1, 4, 1, 3, 1, 2, \
3, 
  1, 2, 1, 4, 4, 2, 4, 3, 2, 4, 1, 2, 3, 3, 2, 1, 3, 3, 2, 3, 1, 3, 2, 3, 4, \
2, 
  3, 1, 3, 3, 2, 1, 1, 1, 4, 3, 3, 4, 4, 1, 4, 1, 3, 4, 4, 1, 4, 2, 1, 4, 3, \
1, 
  2, 1, 2, 4, 2, 4, 4, 2, 1, 2, 2, 1, 2, 1, 3, 4, 1, 3, 2, 2, 3, 4, 1, 3, 3, \
4, 
  2, 3, 1, 2, 2, 3, 3, 1, 4, 1, 4, 1, 1, 3, 1, 4, 2, 4, 3, 1, 1, 1, 4, 2, 4, \
1, 
  4, 4, 3, 3, 2, 3, 3, 2, 3, 3, 1, 1, 1, 4, 1, 1, 2, 2, 2, 4, 2, 1, 1, 2, 2, \
4,
  1, 3, 4, 4, 1, 2, 1, 1, 4, 1, 2, 2, 2, 3, 3, 3, 2, 4, 3, 1, 4, 3, 3, 2, 4, \
1, 
  2, 3, 3, 4, 4, 3, 1, 1, 1, 3, 3, 2, 3, 1, 2, 4, 3, 4, 3, 2, 2, 1, 1, 2, 1, \
3, 
  1, 3, 3, 3, 2, 4, 2, 2, 2, 3, 4, 3, 3, 2, 2};\
\>", "Input"],

Cell["The sequence has about 350 terms.", "Text"],

Cell[" Length[\[Pi]CFPSSequence]", "Input"],

Cell[TextData[{
  "The difference between the continued fraction and the power series is less \
than ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", 
          RowBox[{"-", "100"}]], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* value of the continued fraction *)", "CodeComment"],
  "\ncfL = MapIndexed[If[#2[[1]] === 1, 1, 1/Pi]#1&, \[Pi]CFPSSequence];\n\n\
",
  StyleBox["(* value of the power series *)", "CodeComment"],
  "\ncfS = MapIndexed[#1 (1/Pi)^(#2[[1]] - 1)&, \[Pi]CFPSSequence];\n\n",
  StyleBox["(* difference *)", "CodeComment"],
  "\n(FromContinuedFraction[N[cfL, 300]] - Total[cfS]) // N"
}], "Input"],

Cell["FromContinuedFraction[N[cfL, 300]] // N[#, 30]&", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ",
  Cell[BoxData[
      FormBox[
        RowBox[{"Arg", "(", 
          RowBox[{
            SubscriptBox["C", "k"], "(", "z", ")"}], ")"}], 
        TraditionalForm]]],
  " 3D Graphics"
}], "ExerciseHeading"],

Cell[TextData[{
  "Make 3D visualizations of the argument of the cyclotomic polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{"Arg", "(", 
          RowBox[{
            SubscriptBox["C", "k"], "(", "z", ")"}], ")"}], 
        TraditionalForm]]],
  " over the complex ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]plane."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "A first na\[IDoubleDot]ve try using ",
  StyleBox["Plot3D", "MR"],
  " and/or ",
  StyleBox["ParametricPlot3D", "MR"],
  " shows the problem with such an approach: The curves where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["C", "k"], "(", "z", ")"}], TraditionalForm]]],
  " is purely negative result in discontinuities."
}], "SolutionSubgroup"],

Cell["\<\
Show[GraphicsArray[ 
Block[{k = 5, $DisplayFunction = Identity}, 
  {Plot3D[Evaluate[Arg @ Cyclotomic[8, x + I y]], 
                   {x, -2, 2},{y, -2, 2}, PlotPoints -> 60],
   ParametricPlot3D[{r Cos[\[CurlyPhi]], r Sin[\[CurlyPhi]], \
Arg[Cyclotomic[5, r Exp[I \[CurlyPhi]]]]}, 
                 {r, 0, 2.5}, {\[CurlyPhi], 0, 2Pi}, PlotPoints -> 60, 
                 BoxRatios -> {1, 1, 0.6}]}]]]         \
\>", "Input"],

Cell[TextData[{
  "The next function ",
  StyleBox["CyclotomicBranchCutLines", "MR"],
  " calculates the curves along which the above discontinuities occur."
}], "Text"],

Cell[TextData[{
  "CyclotomicBranchCutLines[o_] :=\nModule[{L = 2.5, \[CurlyEpsilon]\[Pi] = \
Pi 10^-8, \[CurlyEpsilon]e = E 10^-8, cls, \n        lines, branchCutLines}, \
\n",
  StyleBox[" (* contour plot of the curves Im[Cyclotomic[o, z]] == 0 *)", 
    "CodeComment"],
  "\n cls = ContourPlot[Evaluate[Im @ Cyclotomic[o, x + I y]], \n             \
      {x, -L + \[CurlyEpsilon]\[Pi], L}, {y, -L + \[CurlyEpsilon]e, L}, \
PlotPoints -> 60, \n                   Contours -> {0}, ContourShading -> \
False,\n                   DisplayFunction -> Identity];\n ",
  StyleBox["(* extract curves *)", "CodeComment"],
  "\n lines = Flatten[Partition[#[[1]], 2, 1]& /@ \n                  \
Cases[Graphics[cls], _Line, Infinity], 1];    \n",
  StyleBox[" (* select curve segments where Cyclotomic[o, x + I y] < 0 *)", 
    "CodeComment"],
  "\n branchCutLines = Line /@ Select[lines, (#.#&[Plus @@ #/2] > 1 &&\n      \
                    Re[Cyclotomic[o, (Plus @@ #/2).{1, I}]] < 0)&]]  "
}], "Input"],

Cell[TextData[{
  "Here are the curves of discontinuity of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"Arg", "(", 
          RowBox[{
            SubscriptBox["C", "k"], "(", "z", ")"}], ")"}], 
        TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"k", "=", "1"}], ",", "\[Ellipsis]", ",", "36"}], 
        TraditionalForm]]],
  " shown. All curves originate from the unit circle, which contains the \
zeros of the cyclotomic polynomials."
}], "Text"],

Cell["\<\
Module[{oMax = 36},
Show[Graphics[{{GrayLevel[0.5], Thickness[0.02], Circle[{0, 0}, 1]}, 
              {Thickness[0.004],
               Table[{Hue[0.8o/oMax], CyclotomicBranchCutLines[o]}, 
                     {o, 1, oMax}]}}], PlotRange -> All, 
                     AspectRatio -> Automatic, Frame -> True]]\
\>", "Input"],

Cell[TextData[{
  "To avoid the steep vertical walls in the 3D graphics above, we will now \
partition the complex ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]plane into wedges bound by the lines of discontinuity. In \
general, these lines will be described by complicated polynomial roots. For a \
visualization, it is enough to obtain the curves numerically. We do this by \
solving the corresponding differential equation radially outwards. The \
function ",
  StyleBox["cyclotomicArgPlot3D", "MR"],
  " does this, then partitions the wedges into quadrilaterals, and finally \
constructs the corresponding 3D polygons."
}], "Text"],

Cell[TextData[{
  "cyclotomicArgPlot3D[o_, R_, {ppr_, pp\[CurlyPhi]_}] :=\nModule[{\
\[CurlyEpsilon] = 10^-8, im, zeroArgs, ode, ndsols}, \n ",
  StyleBox["(* imaginary part of the cyclotomic polynomial *)", 
    "CodeComment"],
  "\n im = ComplexExpand[Im[Cyclotomic[o, x + I y]]];\n ",
  StyleBox["(* position of zeros on the unit circle *)", "CodeComment"],
  "\n zeroArgs = Sort[N[Arg[z /. Solve[Cyclotomic[o, z] == 0, z]], 30]];\n ",
  StyleBox["(* solve ODE for Im[Cyclotomic[o, z]] == 0 radially outwards *)", 
    "CodeComment"],
  "\n ode = D[im /. {x -> r Cos[\[CurlyPhi][r]], y -> r Sin[\[CurlyPhi][r]]}, \
r];\n ndsols = NDSolve[{ode == 0, \[CurlyPhi][1] == #}, \[CurlyPhi], {r, 1, \
R},\n                  PrecisionGoal -> 12, WorkingPrecision -> 20]& /@ \
zeroArgs;\n ",
  StyleBox["(* make wedges without discontinuities *)", "CodeComment"],
  "\n rs = Table[r, {r, 1, R, (R - 1)/ppr}];\n \[CurlyPhi]Tab = Flatten[\
\[CurlyPhi][#] /. ndsols]& /@ rs;\n \[CurlyPhi]Ranges = Transpose[({#1 + \
\[CurlyEpsilon], #2 - \[CurlyEpsilon]}& @@@ \n                     \
Partition[Append[#, First[#] + 2Pi], 2, 1])& /@ \[CurlyPhi]Tab];\n ",
  StyleBox["(* points in the wedges *)", "CodeComment"],
  "\n zs = Table[Table[rs[[k]] Exp[I \[CurlyPhi]], \n            \
{\[CurlyPhi], \[CurlyPhi]Ranges[[j, k, 1]], \[CurlyPhi]Ranges[[j, k, 2]],\n   \
          (\[CurlyPhi]Ranges[[j, k, 2]] - \[CurlyPhi]Ranges[[j, k, 1]])/pp\
\[CurlyPhi]}],\n           {j, Length[\[CurlyPhi]Ranges]}, {k, Length[rs]}];  \
    \n ",
  StyleBox["(* points in the wedges *)", "CodeComment"],
  "\n points = Map[{Re[#], Im[#], Arg[Cyclotomic[o, #]]}&, #, {2}]& /@ zs;\n \
",
  StyleBox["(* polygons in for the 3D plot *)", "CodeComment"],
  "\n patches = Table[Polygon[{#[[i, j]], #[[i, j + 1]],  \n                  \
        #[[i + 1, j + 1]], #[[i + 1, j]]}],\n                 {i, Length[#] - \
1}, {j, Length[#[[1]]] - 1}]& /@ points;\n ",
  StyleBox["(* polygons inside the unit circle;\n    use azimuthal wedge \
subdivision for smooth transition *)", "CodeComment"],
  "\n pprI = Ceiling[(R - 1)/R ppr];\n zsI = Table[Table[k/pprI Exp[I \
\[CurlyPhi]], \n             {\[CurlyPhi], \[CurlyPhi]Ranges[[j, 1, 1]], \
\[CurlyPhi]Ranges[[j, 1, 2]],\n              (\[CurlyPhi]Ranges[[j, 1, 2]] - \
\[CurlyPhi]Ranges[[j, 1, 1]])/pp\[CurlyPhi]}],\n             {j, Length[\
\[CurlyPhi]Ranges]}, {k, 0, pprI}];                      \n pointsI = \
Map[{Re[#], Im[#], Arg[Cyclotomic[o, #]]}&, #, {2}]& /@ zsI;\n patchesI = \
Table[Polygon[{#[[i, j]], #[[i, j + 1]],  \n                           #[[i + \
1, j + 1]], #[[i + 1, j]]}],\n                 {i, Length[#] - 1}, {j, \
Length[#[[1]]] - 1}]& /@ pointsI;                \n ",
  StyleBox["(* color polygon according to argument of cyclotomic polynomial \
*)", "CodeComment"],
  "\n coloredPolygons = Join[patches, patchesI] /.\n        p_Polygon :> \
{SurfaceColor[#, #, 2.2]&[\n          Hue[0.78 ((Plus @@ (Last /@ \
N[p[[1]]])/4) + Pi)/(2 Pi)]], p};                \n ",
  StyleBox["(* show graphic *)", "CodeComment"],
  "\n Show[Graphics3D[{EdgeForm[], coloredPolygons}, BoxRatios -> {1, 1, \
0.4},\n       Axes -> False, Boxed -> False]]]"
}], "Input"],

Cell[TextData[{
  "Here are the 3D graphics of ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          FormBox[
            RowBox[{"Arg", "(", 
              RowBox[{
                SubscriptBox["C", "2"], "(", "z", ")"}], ")"}],
            "TraditionalForm"]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          FormBox[
            RowBox[{"Arg", "(", 
              RowBox[{
                SubscriptBox["C", "3"], "(", "z", ")"}], ")"}],
            "TraditionalForm"]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          FormBox[
            RowBox[{"Arg", "(", 
              RowBox[{
                SubscriptBox["C", "4"], "(", "z", ")"}], ")"}],
            "TraditionalForm"]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[cyclotomicArgPlot3D[#, 2.5, {36, 36}]& /@ {2, 3, \
5}]];\
\>", "Input"],

Cell[TextData[{
  "And here is the corresponding graphic for ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          RowBox[{
            SubscriptBox["C", "11"], "(", "z", ")"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["cArg = cyclotomicArgPlot3D[11, 2.5, {36, 36}] ", "Input"],

Cell["\<\
The last graphic tempts one to do an animation showing a rotating \
version of the last graphic.\
\>", "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_CyclotomicPlot3Ds.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel",
  GeneratedCell->False],

Cell["\<\
frames = 60;
Do[\[ScriptCapitalR] = {{Cos[\[CurlyPhi]], Sin[\[CurlyPhi]], 0}, {-Sin[\
\[CurlyPhi]], Cos[\[CurlyPhi]], 0}, {0, 0, 1}} // N;
   Show[cArg /. Polygon[l_] :> Polygon[\[ScriptCapitalR].#& /@ l]],
   {\[CurlyPhi], 0, 2Pi (1 - 1/frames), 2Pi/frames}]\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Symbolics Volume, Chapter 1", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Bose Gas Virial Series Convergence Radius"
}], "ExerciseHeading"],

Cell[TextData[{
  "The virial series of the dD ideal Bose gas ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"p", "(", "\[Rho]", ")"}], "=", 
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "\[Infinity]"], 
            RowBox[{
              SubsuperscriptBox["c", "k", 
                RowBox[{"(", "d", ")"}]], 
              SuperscriptBox["\[Rho]", "k"]}]}]}], TraditionalForm]]],
  " is defined implicitly through the two series ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"p", "(", "z", ")"}], "=", 
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "\[Infinity]"], 
            RowBox[{
              SubsuperscriptBox["\[Alpha]", "k", 
                RowBox[{"(", "d", ")"}]], 
              SuperscriptBox["z", "k"]}]}]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Rho]", "(", "z", ")"}], "=", 
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "\[Infinity]"], 
            RowBox[{"k", " ", 
              SubsuperscriptBox["\[Alpha]", "k", 
                RowBox[{"(", "d", ")"}]], 
              SuperscriptBox["z", "k"]}]}]}], TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Alpha]", "k", 
            RowBox[{"(", "d", ")"}]], "=", 
          SuperscriptBox["k", 
            RowBox[{
              RowBox[{
                RowBox[{"-", "d"}], "/", "2"}], "-", "1"}]]}], 
        TraditionalForm]]],
  "(here ",
  Cell[BoxData[
      FormBox["p", TraditionalForm]]],
  " is the pressure, ",
  Cell[BoxData[
      FormBox["\[Rho]", TraditionalForm]]],
  " the density, and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " the fugacity) [",
  
  CounterBox["BibliographyCounter", "Lee95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lee95",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lee96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lee96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lee97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lee97",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lee02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lee02",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Nieto70"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Nieto70",
    ButtonStyle->"Hyperlink"],
  "]",
  ". For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", "=", "4"}], TraditionalForm]]],
  ", the series ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "\[Rho]", ")"}], TraditionalForm]]],
  " is conjectured to have the convergence radius ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[Pi]", "2"], "/", "6"}], TraditionalForm]]],
  " (",
  Cell[BoxData[
      FormBox[
        RowBox[{"=", 
          RowBox[{"\[Zeta]", "(", 
            RowBox[{"d", "=", "4"}], ")"}]}], TraditionalForm]]],
  ") [",
  
  CounterBox["BibliographyCounter", "Ziff80"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ziff80",
    ButtonStyle->"Hyperlink"],
  "]. Calculate a truncated form of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "\[Rho]", ")"}], TraditionalForm]]],
  " and its associated diagonal Pad\[EAcute] approximation. The smallest root \
of the denominator of the Pad\[EAcute] rational function approximates the \
convergence radius [",
  
  CounterBox["BibliographyCounter", "Baker96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Baker96",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Takahashi86"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Takahashi86",
    ButtonStyle->"Hyperlink"],
  "]. Confirm to three digits that the convergence radius is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[Pi]", "2"], "/", "6"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "To obtain the series ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "\[Rho]", ")"}], TraditionalForm]]],
  ", we invert the series for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Rho]", "(", "z", ")"}], TraditionalForm]]],
  " and substitute the result into the series for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "z", ")"}], TraditionalForm]]],
  ". The following function ",
  StyleBox["makepOf\[Rho]Series", "MR"],
  " implements this. It calculates ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  " terms for dimension ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  " using the working precision ",
  Cell[BoxData[
      FormBox[
        StyleBox["prec",
          "TI"], TraditionalForm]]],
  ". The main work is the inversion of the series through ",
  StyleBox["InverseSeries", "MR"],
  "."
}], "SolutionSubgroup"],

Cell["\<\
makepOf\[Rho]Series[o_, d_, prec_] := 
Module[{b, zOf\[Rho]Series},
 b[k_] := k^(-d/2 - 1);
 zOf\[Rho]Series = InverseSeries[N[Sum[k b[k] z^k, {k, o}], prec] + 
                            O[z]^(o + 1), \[Rho]];
 Normal[Sum[b[k] zOf\[Rho]Series^k, {k, o}]]];\
\>", "Input"],

Cell["\<\
While we can in principle get an exact result for the first terms, \
they grow quickly in size and no obvious pattern for a closed\[Hyphen]form of \
the coefficients comes to mind.\
\>", "Text"],

Cell["\<\
Factor /@ makepOf\[Rho]Series[6, d, Infinity]\
\>", "Input"],

Cell["\<\
For even dimensions, the coefficients become rational \
numbers.\
\>", "Text"],

Cell["\<\
makepOf\[Rho]Series[12, 4, Infinity]\
\>", "Input"],

Cell[TextData[{
  "For explicit numeric coefficients, the series coefficients do not grow in \
size and we can easily calculate, say, 250 terms of the series for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "\[Rho]", ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "pOf\[Rho]Series = makepOf\[Rho]Series[250, 4, 200];\n",
  StyleBox["(* do last terms have verified digits? *)", "CodeComment"],
  " Precision[pOf\[Rho]Series]"
}], "Input"],

Cell[TextData[{
  "Applying the root test to the so\[Hyphen]calculated series coefficients \
shows that the convergence radius is a number near ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["\[Pi]", "2"], "/", "6"}], "\[TildeTilde]", 
          StyleBox[
            RowBox[{"1.64493", "\[Ellipsis]"}],
            ZeroWidthTimes->True]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
kRoots = MapIndexed[If[#1 != 0, {#2[[1]], Abs[#1]^(-1/#2[[1]])}, 
                     Sequence @@ {}]&, CoefficientList[pOf\[Rho]Series, \
\[Rho]]];
ListPlot[kRoots]                       \
\>", "Input"],

Cell["SequenceLimit[Drop[Last /@ kRoots, 50], WynnDegree -> 10]", "Input"],

Cell[TextData[{
  "Assuming a singularity of the form ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{"(", 
            RowBox[{"\[Rho]", "-", 
              SuperscriptBox["\[Rho]", "*"]}], ")"}], "\[Alpha]"], 
        TraditionalForm]]],
  ", we can use the Domb\[Dash]Sykes interpolation [",
  
  CounterBox["BibliographyCounter", "Hinch91"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hinch91",
    ButtonStyle->"Hyperlink"],
  "] to approximate the singularity ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[Rho]", "*"], TraditionalForm]]],
  ". Taking the last 20 series terms into account, this results again in a \
value for ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[Rho]", "*"], TraditionalForm]]],
  " that is different from ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[Pi]", "2"], "/", "6"}], TraditionalForm]]],
  " by only 0.02%."
}], "Text"],

Cell[TextData[{
  "cl\[Rho] = CoefficientList[pOf\[Rho]Series, \[Rho]];\npairs = \
Partition[Take[MapIndexed[{#2[[1]], #1}&, \n                                  \
Rest[cl\[Rho]]], All], 2, 1];\nratios = {1/#[[2, 1]], #[[2, 2]]/#[[1, 2]]}& \
/@ pairs;\n",
  StyleBox["(* interpolate term[n]/term[n - 1] as a function of 1/n *)", 
    "CodeComment"],
  "\n1/Coefficient[Fit[ratios, {1, x}, x], x, 0] - Pi^2/6 // N"
}], "Input"],

Cell[TextData[{
  "Now, we form the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"100", "/", "100"}], "]"}], TraditionalForm]]],
  " diagonal Pad\[EAcute] approximation from the series ",
  StyleBox["pOf\[Rho]Series", "MR"],
  " and extract its denominator",
  "."
}], "Text"],

Cell["Needs[\"Calculus`Pade`\"]", "Input"],

Cell["\<\
pOf\[Rho]ApproxDen[\[Rho]_] = Pade[pOf\[Rho]Series /. c_ \[Rho]^k_ \
:> SetPrecision[c, 400] \[Rho]^k, 
                         {\[Rho], 0, 100, 100}] // Denominator;\
\>", "Input"],

Cell[TextData[{
  "Calculating the smallest root gives an approximation for the convergence \
radius that deviates from ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[Pi]", "2"], "/", "6"}], TraditionalForm]]],
  " by only 0.04%."
}], "Text"],

Cell["\<\
roots = Roots[SetPrecision[N[pOf\[Rho]ApproxDen[\[Rho]], 120], \
Infinity] == 0, \[Rho]];\
\>", "Input"],

Cell["Min[Abs[Cases[N[roots, 40], _?NumberQ, Infinity]]] - Pi^2/6 ", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Midpoint Quadrature Formula"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the following approximate quadrature formula [",
  
  CounterBox["BibliographyCounter", "Ujevic03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ujevic03",
    ButtonStyle->"Hyperlink"],
  "]:"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["\[Integral]", "a", "b"], 
          RowBox[{
            RowBox[{"f", "(", "x", ")"}], "d", "\[InvisibleSpace]", "x"}]}], 
        "\[TildeTilde]", 
        RowBox[{
          UnderoverscriptBox["\[Sum]", 
            RowBox[{"k", "=", "0"}], "o"], 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubsuperscriptBox["\[Alpha]", "k", 
                    RowBox[{"(", "o", ")"}]], 
                  FractionBox[
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], 
                      RowBox[{"f", "(", "x", ")"}]}], 
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], "x"}]]}], 
                SubscriptBox["|", 
                  RowBox[{"x", "=", "a"}]], 
                RowBox[{
                  RowBox[{"+", 
                    SubsuperscriptBox["\[Beta]", "k", 
                      RowBox[{"(", "o", ")"}]]}], 
                  FractionBox[
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], 
                      RowBox[{"f", "(", "x", ")"}]}], 
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], "x"}]]}], 
                SubscriptBox["|", 
                  RowBox[{"x", "=", 
                    FractionBox[
                      RowBox[{"a", "+", "b"}], "2"]}]], 
                RowBox[{
                  RowBox[{"+", 
                    SubsuperscriptBox["\[Gamma]", "k", 
                      RowBox[{"(", "o", ")"}]]}], 
                  FractionBox[
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], 
                      RowBox[{"f", "(", "x", ")"}]}], 
                    RowBox[{
                      SuperscriptBox["\[PartialD]", "k"], "x"}]]}], 
                SubscriptBox["|", 
                  RowBox[{"x", "=", "b"}]]}], ")"}], "."}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Calculate the ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Alpha]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Beta]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Gamma]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "\[LessEqual]", "o", "\[LessEqual]", "10"}], 
        TraditionalForm]]],
  " by requiring exactness of the above approximation for polynomials of the \
largest possible degree. What are the errors of the resulting formulas for \
the integral ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", 
            RowBox[{"\[Pi]", "/", "2"}]], 
          RowBox[{
            RowBox[{"sin", "(", "x", ")"}], "d", "\[InvisibleSpace]", "x"}]}],
         TraditionalForm]]],
  "?"
}], "Text"],

Cell[TextData[{
  "Before trying to calculate the coefficients, we observe two obvious \
simplifications. From the symmetry of the integral follows ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Alpha]", "k", 
            RowBox[{"(", "o", ")"}]], "=", 
          RowBox[{
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{"-", "1"}], ")"}], "k"], 
            SubsuperscriptBox["\[Gamma]", "k", 
              RowBox[{"(", "o", ")"}]]}]}], TraditionalForm]]],
  ", and from inserting units of length follows that the ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Alpha]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Beta]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Gamma]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  " are proportional ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{"(", 
            RowBox[{"b", "-", "a"}], ")"}], 
          RowBox[{"k", "+", "1"}]], TraditionalForm]]],
  ". The last observation is crucial in avoiding large calculations using \
nonnumerical quantities and reduces all calculations to solving a linear \
system of equations with rational coefficients."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "By requiring the quadrature formulas to be exact for polynomials, we can \
derive a linear system for the ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Alpha]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["\[Gamma]", "k", 
          RowBox[{"(", "o", ")"}]], TraditionalForm]]],
  ". The following implementation for the function ",
  StyleBox["makeQuadratureFormula", "MR"],
  " starts with linear polynomials and increases the degree until the linear \
system has no solution anymore."
}], "SolutionSubgroup"],

Cell[TextData[{
  "makeQuadratureFormula[o_, ",
  StyleBox["(* initial degree *)", "CodeComment"],
  " d0_:1, \[ScriptF]_:F] := \nModule[{d = d0, f, lhs, rhs, eqs, sol, solO},\n\
While[",
  StyleBox["(* quadrature formula is exact for polynomials *)", 
    "CodeComment"],
  "\n f[x_] := Sum[c[j] x^j, {j, 0, d}];\n lhs = Integrate[f[x], {x, a, b}];\n\
 ",
  StyleBox["(* the right-hand side of the quadrature formula *)", 
    "CodeComment"],
  "\n rhs = Sum[(b - a)^(k + 1) (\[Alpha][k] Derivative[k][\[ScriptF]][a] + \n\
                            \[Beta][k] Derivative[k][\[ScriptF]][(a + b)/2] +\
\n                            (-1)^k \[Alpha][k] \
Derivative[k][\[ScriptF]][b]), {k, 0, o}];\n ",
  StyleBox["(* solve linear system *)", "CodeComment"],
  "\n vars = Flatten[Table[{\[Alpha][j], \[Beta][j]}, {j, 0, o}]];\n eqs = \
Flatten[CoefficientList[#, {a, b}]& /@ \n               \
DeleteCases[Flatten[CoefficientList[lhs - (rhs /. F -> f), \n                 \
                  Table[c[k], {k, 0, o}]]], 0]];\n sol = Factor //@ Together \
//@ Solve[eqs == 0, vars]; \n sol =!= {}, ",
  StyleBox["(* increase polynomial degree *)", "CodeComment"],
  " solO = sol; d++]; \n ",
  StyleBox["(* format result *)", "CodeComment"],
  " Factor /@ (rhs /. solO[[1]])]"
}], "Input"],

Cell["\<\
SetOptions[RowReduce, Method -> OneStepRowReduction]; 
Off[Solve::svars];\
\>", "Input"],

Cell[TextData[{
  "Some experimentation with ",
  StyleBox["makeQuadratureFormula", "MR"],
  " shows that the maximal polynomial degree is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"3", " ", 
            RowBox[{"(", 
              RowBox[{"o", "+", "1"}], ")"}]}], "-", 
          InterpretationBox[
            RowBox[{"o", " ", "mod", " ", "2"}],
            Mod[ o, 2]]}], TraditionalForm]]],
  ". Taking this into account allows avoiding the looping over the polynomial \
degree. ",
  StyleBox["makeQuadratureFormula1", "MR"],
  " is the resulting function."
}], "Text"],

Cell["\<\
makeQuadratureFormula1[o_, \[ScriptF]_:F] := 
makeQuadratureFormula[o, 3 (o + 1) - Mod[o, 2], \[ScriptF]]\
\>", "Input"],

Cell["Here are the first three resulting quadrature formulas.", "Text"],

Cell["makeQuadratureFormula1[0]", "Input"],

Cell["makeQuadratureFormula1[1]", "Input"],

Cell["makeQuadratureFormula1[2]", "Input"],

Cell[TextData[{
  "Here is the resulting quadrature formula for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"o", "=", "10"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["makeQuadratureFormula1[10]", "Input"],

Cell[TextData[{
  "For the integral ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", 
            RowBox[{"\[Pi]", "/", "2"}]], 
          RowBox[{
            RowBox[{"sin", "(", "x", ")"}], "d", "\[InvisibleSpace]", "x"}]}],
         TraditionalForm]]],
  ", the error of the resulting formulas is approximately ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", 
          RowBox[{
            RowBox[{"-", "4.5"}], "o"}]], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Table[{o, 1`50 - makeQuadratureFormula1[o] /. 
          {a -> 0, b -> Pi/2, F -> Sin}}, {o, 0, 10}] // N\
\>", "Input"],

Cell[TextData[{
  "For generalizations of quadrature rules that contain derivatives, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Kim03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kim03",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " MacMahon Master Theorem"
}], "ExerciseHeading"],

Cell[TextData[{
  "The MacMahon master theorem states that, for an arbitrary matrix ",
  Cell[BoxData[
      FormBox[
        SubscriptBox[
          RowBox[{"(", 
            SubscriptBox["a", 
              RowBox[{"i", "\[InvisibleSpace]", "j"}]], ")"}], 
          RowBox[{
            RowBox[{"1", "\[LessEqual]", "i"}], ",", 
            RowBox[{"j", "\[LessEqual]", "d"}]}]], TraditionalForm]]],
  " and indeterminates ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "k"], TraditionalForm]]],
  ", the coefficients of the following expressions are identical ",
  "[",
  
  CounterBox["BibliographyCounter", "MacMahon78"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"MacMahon78",
    ButtonStyle->"Hyperlink"],
  "]:"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              SubsuperscriptBox["x", "1", 
                SubscriptBox["k", "1"]], 
              SubsuperscriptBox["x", "2", 
                SubscriptBox["k", "2"]], "\[Ellipsis]", " ", 
              SubsuperscriptBox["x", "d", 
                SubscriptBox["k", "d"]]}], "]"}], 
          RowBox[{"(", 
            FractionBox["1", 
              SubscriptBox[
                RowBox[{"det", "(", 
                  RowBox[{
                    SubscriptBox["\[Delta]", 
                      RowBox[{"i", "\[InvisibleSpace]", "j"}]], "-", 
                    RowBox[{
                      SubscriptBox["a", 
                        RowBox[{"i", "\[InvisibleSpace]", "j"}]], 
                      SubscriptBox["x", "j"]}]}], ")"}], 
                RowBox[{
                  RowBox[{"1", "\[LessEqual]", "i"}], ",", 
                  RowBox[{"j", "\[LessEqual]", "d"}]}]]], ")"}]}], "=", 
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              SubsuperscriptBox["x", "1", 
                SubscriptBox["k", "1"]], 
              SubsuperscriptBox["x", "2", 
                SubscriptBox["k", "2"]], "\[Ellipsis]", " ", 
              SubsuperscriptBox["x", "d", 
                SubscriptBox["k", "d"]]}], "]"}], 
          RowBox[{"(", 
            RowBox[{
              UnderoverscriptBox["\[Product]", 
                RowBox[{"j", "=", "1"}], "d"], 
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{
                    UnderoverscriptBox["\[Sum]", 
                      RowBox[{"m", "=", "1"}], "d"], 
                    RowBox[{
                      SubscriptBox["a", 
                        RowBox[{"j", "\[InvisibleSpace]", "m"}]], 
                      SubscriptBox["x", "m"]}]}], ")"}], 
                SubscriptBox["k", "j"]]}], ")"}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Write a function that, for an explicitly given ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  ", verifies the MacMahon master theorem for all monomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["x", "1", 
            SubscriptBox["k", "1"]], 
          SubsuperscriptBox["x", "2", 
            SubscriptBox["k", "2"]], "\[Ellipsis]", " ", 
          SubsuperscriptBox["x", "d", 
            SubscriptBox["k", "d"]]}], TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"j", "=", "1"}], "d"], 
            SubscriptBox["k", "j"]}], "\[LessEqual]", "o"}], 
        TraditionalForm]]],
  " by explicit calculation of the coefficients. Check the theorem for all ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"1", "\[LessEqual]", "d"}], ",", 
          RowBox[{"o", "\[LessEqual]", "5"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "It is straightforward to implement a function that checks the identity of \
the monomials coefficients up to total degree ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  ". Instead of calculating a multivariate series, we scale all ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "k"], TraditionalForm]]],
  " to ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Tau]", " ", 
          SubscriptBox["x", "k"]}], TraditionalForm]]],
  " and expand with respect to ",
  Cell[BoxData[
      FormBox["\[Tau]", TraditionalForm]]],
  " around zero and extract the coefficients from the resulting series terms \
using the function ",
  StyleBox["Internal`DistributedTermsList", "MR"],
  ". "
}], "SolutionSubgroup"],

Cell[TextData[{
  "checkMacMahonMasterTheorem[d_Integer?Positive, o_Integer?Positive] := \n\
Module[{a, x, \[Tau], det, invDetSeries, xMonomials},\n       ",
  StyleBox["(* list of the indeterminates *)", "CodeComment"],
  "\n       xMonomials = Table[x[j], {j, d}];\n       ",
  StyleBox["(* the determinant, make homogeneous with \[Tau] *)", 
    "CodeComment"],
  "\n       det = Det[IdentityMatrix[d] - Table[a[i, j] x[j], {i, d}, {j, \
d}]] /. \n                 x[j_] :> \[Tau] x[j];\n       ",
  StyleBox["(* series of the inverse determinant in \[Tau] *)", 
    "CodeComment"],
  "\n       invDetSeries = (Series[1/det, {\[Tau], 0, o}] // Normal // \
Expand) /. \[Tau] -> 1;\n       ",
  StyleBox["(* extract coefficients of monomials in the series terms *)", 
    "CodeComment"],
  "\n       terms = Internal`DistributedTermsList[invDetSeries, \
xMonomials][[1]];\n       ",
  StyleBox["(* form right-hand-side for a given exponent vector, \n          \
extract coefficient and subtract *)", "CodeComment"],
  "\n       ((If[Union[#1] === {0}, 1, Plus @@ Cases[\n           \
Expand[Times @@ (Table[Sum[a[i, j] x[j], {j, d}], {i, d}]^#)], \n             \
    _ (Times @@ (xMonomials^#1)), {If[d === 1, 0, 1]}] /. \n                  \
    _x -> 1] - #2)& @@@ terms) // (Union[#] === {0})&]"
}], "Input"],

Cell[TextData[{
  "Of course, the MacMahon master theorem holds for ",
  "all ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"1", "\[LessEqual]", "d"}], ",", 
          RowBox[{"o", "\[LessEqual]", "5"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Table[checkMacMahonMasterTheorem[i, j], {i, 5}, {j, 5}] // Flatten \
// Union\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  4.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Adler\[Dash]Moser Polynomials"
}], "ExerciseHeading"],

Cell[TextData[{
  "The Adler\[Dash]Moser polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "k"], "(", "z", ")"}], TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "Adler78"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Adler78",
    ButtonStyle->"Hyperlink"],
  "] ",
  "defined recursively through"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{" ", 
        RowBox[{
          RowBox[{
            RowBox[{
              RowBox[{
                SubsuperscriptBox["\[Theta]", "n", "\[Prime]"], 
                "\[InvisibleApplication]", 
                RowBox[{"(", "z", ")"}]}], 
              RowBox[{
                SubscriptBox["\[Theta]", 
                  RowBox[{"n", "-", "2"}]], "\[InvisibleApplication]", 
                RowBox[{"(", "z", ")"}]}]}], "-", " ", 
            RowBox[{
              RowBox[{
                SubsuperscriptBox["\[Theta]", 
                  RowBox[{"n", "-", "2"}], "\[Prime]"], 
                "\[InvisibleApplication]", 
                RowBox[{"(", "z", ")"}]}], 
              RowBox[{
                SubscriptBox["\[Theta]", "n"], "\[InvisibleApplication]", 
                RowBox[{"(", "z", ")"}]}]}]}], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{"2", " ", "n"}], "-", "1"}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{
                RowBox[{
                  SubscriptBox["\[Theta]", 
                    RowBox[{"n", "-", "1"}]], "(", "z", ")"}], " "}], 
              "2"]}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "with the initial conditions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[Theta]", "0"], "(", "z", ")"}], "=", "1"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[Theta]", "1"], "(", "z", ")"}], "=", 
          RowBox[{"z", "+", 
            SubscriptBox["c", "1"]}]}], TraditionalForm]]],
  " depend on ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " free parameters ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "\[LessEqual]", "k", "\[LessEqual]", "n"}], 
        TraditionalForm]]],
  ". \nThe integrals ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Integral]", 
          RowBox[{
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], "/", 
                  RowBox[{
                    SubscriptBox["\[Theta]", 
                      RowBox[{"n", "-", "1"}]], "(", "z", ")"}]}], ")"}], 
              "2"], "d", "\[InvisibleSpace]", "z"}]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Integral]", 
          RowBox[{
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox["\[Theta]", 
                      RowBox[{"n", "-", "1"}]], "(", "z", ")"}], "/", 
                  RowBox[{
                    SubscriptBox["\[Theta]", "n"], "(", "z", ")"}]}], ")"}], 
              "2"], "d", "\[InvisibleSpace]", "z"}]}], TraditionalForm]]],
  " are rational functions and contain no logarithms [",
  
  CounterBox["BibliographyCounter", "Burchnall30"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Burchnall30",
    ButtonStyle->"Hyperlink"],
  "]. Verify this statement for the first few ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ".\nFor any generic complex values of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ", the roots of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", 
            RowBox[{"n", "-", "1"}]], "(", "z", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  " are the equilibrium positions of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"n", "(", 
            RowBox[{"n", "-", "1"}], ")"}], "/", "2"}], TraditionalForm]]],
  " positive and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"(", 
            RowBox[{"n", "+", "1"}], ")"}], 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"n", "+", "2"}], ")"}], "/", "2"}]}], 
        TraditionalForm]]],
  " negative unit charges that attract each other through a logarithmic \
potential in the plane [",
  
  CounterBox["BibliographyCounter", "Loutsenko02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Loutsenko02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Loutsenko03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Loutsenko03",
    ButtonStyle->"Hyperlink"],
  "]. For some parametrized ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ", show some such equilibrium configurations."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with the implementation of the recursive calculation of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  ". Instead of solving the differential equation, we use the (slightly \
faster) function ",
  StyleBox["Integrate", "MR"],
  "."
}], "SolutionSubgroup"],

Cell["\<\
Off[RuleDelayed::rhs];
\[Theta][0][z_] := 1;
\[Theta][1][z_] := z + c[1];
\[Theta][n_][z_] := \[Theta][n][z_] = 
\[Theta][n - 2][z] (c[n] + Integrate[(2 n \[Theta][n - 1][z]^2 - \[Theta][n - \
1][z]^2)/\[Theta][n - 2][z]^2, 
                              z]) // Together // Cancel\
\>", "Input"],

Cell[TextData[{
  "Here are the first few ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\[Theta][2][z]", "Input"],

Cell["\[Theta][3][z]", "Input"],

Cell["\[Theta][4][z]", "Input"],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  " grow quickly in size."
}], "Text"],

Cell["\[Theta][5][z] // Expand // Length", "Input"],

Cell[TextData[{
  "Replacing the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " by ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["\[Lambda]", 
            RowBox[{
              RowBox[{"2", "k"}], "-", "1"}]], 
          SubscriptBox["c", "k"]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " by ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", " ", "z"}], TraditionalForm]]],
  " yields a homogeneous polynomial of order ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[Lambda]", 
          RowBox[{
            RowBox[{"n", "(", 
              RowBox[{"n", "+", "1"}], ")"}], "/", "2"}]], 
        TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Adler78"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Adler78",
    ButtonStyle->"Hyperlink"],
  "] ."
}], "Text"],

Cell["\<\
Table[(Factor[\[Theta][n][z] /. {z -> \[Lambda] z, c[k_] :> \
\[Lambda]^(2k - 1) c[k]}]) /.
      _Plus :> 1, {n, 0, 5}]\
\>", "Input"],

Cell[TextData[{
  "Despite the parameters ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " present in the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  ", the above given integrals are rational functions in ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". Here are the first few of these integrals explicitly calculated."
}], "Text"],

Cell["\<\
Table[{n, Integrate[(\[Theta][n - 1][z]/\[Theta][n][z])^2, z]}, {n, \
1, 3}]\
\>", "Input"],

Cell["\<\
Table[{n, Integrate[(\[Theta][n][z]/\[Theta][n - 1][z])^2, z]}, {n, \
1, 3}]\
\>", "Input"],

Cell[TextData[{
  "For visualizing the position of the zeros of consecutive ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[Theta]", "n"], "(", "z", ")"}], TraditionalForm]]],
  ", we implement the function ",
  StyleBox["chargeGraphics", "MR"],
  "."
}], "Text"],

Cell["\<\
chargeGraphics[polyPair_, z_, {\[CurlyPhi]_, pp_}] := 
Module[{r1, r2}, 
Graphics[{PointSize[0.004], 
Table[{r1, r2} = NRoots[# == 0, z]& /@ polyPair;
{{Hue[0.0], Point[{Re[#], Im[#]}]& /@ Cases[r1, _?NumberQ, Infinity]},
 {Hue[0.8], Point[{Re[#], Im[#]}]& /@ Cases[r2, _?NumberQ, Infinity]}}, 
     {\[CurlyPhi], 0, 2Pi, 2Pi/pp}]}, AspectRatio -> Automatic]];\
\>", \
"Input"],

Cell[TextData[{
  "In the following two graphics, the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " are parametrized concentric circles and Lissajou figures."
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\n{",
  StyleBox["(* c[k] moves on concentric circles *)", "CodeComment"],
  "\n chargeGraphics[{\[Theta][4][z], \[Theta][5][z]} /. {c[k_] :> k Exp[I \
\[CurlyPhi]]}, z, {\[CurlyPhi], 480}],\n ",
  StyleBox["(* c[k] moves on Lissajou figures *)", "CodeComment"],
  "\n chargeGraphics[{\[Theta][4][z], \[Theta][5][z]} /. \n              \
{c[1] :> Cos[\[CurlyPhi]] + I Sin[\[CurlyPhi]], c[2] :> Cos[2 \[CurlyPhi]] + \
I Sin[3 \[CurlyPhi]],\n               c[3] :> Cos[5 \[CurlyPhi]] + I Sin[1 \
\[CurlyPhi]], c[4] :> Cos[2 \[CurlyPhi]] + I Sin[5 \[CurlyPhi]],\n            \
   c[5] :> Cos[1 \[CurlyPhi]] + I Sin[3 \[CurlyPhi]]}, z, {\[CurlyPhi], \
240}]}]]"
}], "Input"],

Cell[TextData[{
  "The next two graphics use random smooth functions for the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* random, smooth, periodic function *)", "CodeComment"],
  "\n\[DoubleStruckR] := Sum[Random[] Exp[I k (\[CurlyPhi] + 2Pi Random[])], \
{k, 0, 3}]"
}], "Input"],

Cell["\<\
SeedRandom[111];
Show[GraphicsArray[Table[
chargeGraphics[{\[Theta][4][z], \[Theta][5][z]} /. 
               Table[c[k] -> \[DoubleStruckR], {k, 5}], z, {\[CurlyPhi], \
600}], {2}]]]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  5.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ODE for Yablonskii\[Dash]Vorob\[CloseCurlyQuote]ev Polynomials"
}], "ExerciseHeading"],

Cell[TextData[{
  "The Yablonskii\[Dash]Vorob\[CloseCurlyQuote]ev polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["Q", "n"], "(", "z", ")"}], TraditionalForm]]],
  " fulfill the following nonlinear difference\[Hyphen]differential \
equation:"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["Q", 
            RowBox[{"n", "+", "1"}]], "(", "z", ")"}], "=", 
        RowBox[{
          FractionBox[
            RowBox[{
              RowBox[{"z", " ", 
                SuperscriptBox[
                  RowBox[{
                    SubscriptBox["Q", "n"], "(", "z", ")"}], "2"]}], "-", 
              RowBox[{"4", 
                RowBox[{"(", 
                  RowBox[{
                    RowBox[{
                      RowBox[{
                        SubscriptBox["Q", "n"], "(", "z", ")"}], 
                      RowBox[{
                        SubsuperscriptBox["Q", "n", "\[DoublePrime]"], "(", 
                        "z", ")"}]}], "-", 
                    SuperscriptBox[
                      RowBox[{
                        SubsuperscriptBox["Q", "n", "\[Prime]"], "(", "z", 
                        ")"}], "2"]}], ")"}]}]}], 
            RowBox[{
              SubscriptBox["Q", 
                RowBox[{"n", "-", "1"}]], "(", "z", ")"}]], "."}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "The initial polynomials are ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["Q", "0"], "(", "z", ")"}], "=", "1"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["Q", "1"], "(", "z", ")"}], "=", "z"}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "A recent article ",
  "[",
  
  CounterBox["BibliographyCounter", "Clarkson03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Clarkson03",
    ButtonStyle->"Hyperlink"],
  "] ",
  "asked for a pure differential equation for the Yablonskii\[Dash]Vorob\
\[CloseCurlyQuote]ev polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["Q", "n"], "(", "z", ")"}], TraditionalForm]]],
  ". Make a polynomial ansatz for a nonlinear differential equation for the \
",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["Q", "n"], "(", "z", ")"}], TraditionalForm]]],
  " and determine the unknown coefficients."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by implementing the Yablonskii\[Dash]Vorob\[CloseCurlyQuote]ev \
polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["Q", "n"], "(", "z", ")"}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell[TextData[{
  "Off[RuleDelayed::rhs];\n\nQ[0][z_] := 1;\nQ[1][z_] := z;\n",
  StyleBox["(* recursive definition *)", "CodeComment"],
  "\nQ[n_][z_] := Q[n][z_] = Together[\n(z Q[n - 1][z]^2 - 4 (Q[n - 1][z] Q[n \
- 1]''[z] - Q[n - 1]'[z]^2))/Q[n - 2][z]]"
}], "Input"],

Cell[TextData[{
  "Here are the first few ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["Q", "n"], "(", "z", ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["Table[Factor @ Q[k][z], {k, 0, 5}] // TableForm", "Input"],

Cell["\<\
The above nonlinear difference\[Hyphen]differential equation is of \
order two with respect to differentiation and is of order two with respect to \
differencing. So, a natural guess would be to look for a fourth order pure \
differential equation. We make the following ansatz:\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Sum]", 
            RowBox[{"k", ",", 
              SubscriptBox["\[Alpha]", "0"], ",", 
              SubscriptBox["\[Alpha]", "1"], ",", 
              SubscriptBox["\[Alpha]", "2"], ",", 
              SubscriptBox["\[Alpha]", "3"], ",", 
              RowBox[{
                SubscriptBox["\[Alpha]", "4"], "=", "0"}]}], "d"], 
          RowBox[{
            SubscriptBox["c", 
              RowBox[{"k", ",", 
                SubscriptBox["\[Alpha]", "0"], ",", 
                SubscriptBox["\[Alpha]", "1"], ",", 
                SubscriptBox["\[Alpha]", "2"], ",", 
                SubscriptBox["\[Alpha]", "3"], ",", 
                SubscriptBox["\[Alpha]", "4"]}]], 
            SuperscriptBox["z", "k"], 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["Q", "n"], "(", "z", ")"}], 
              SubscriptBox["\[Alpha]", "0"]], 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", "\[Prime]"], "(", "z", ")"}], 
              SubscriptBox["\[Alpha]", "1"]], 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", "\[DoublePrime]"], "(", "z", 
                ")"}], 
              SubscriptBox["\[Alpha]", "2"]], 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", 
                  RowBox[{"(", "3", ")"}]], "(", "z", ")"}], 
              SubscriptBox["\[Alpha]", "3"]], 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", 
                  RowBox[{"(", "4", ")"}]], "(", "z", ")"}], 
              SubscriptBox["\[Alpha]", "4"]]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Here the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", 
          RowBox[{"k", ",", 
            SubscriptBox["\[Alpha]", "0"], ",", 
            SubscriptBox["\[Alpha]", "1"], ",", 
            SubscriptBox["\[Alpha]", "2"], ",", 
            SubscriptBox["\[Alpha]", "3"], ",", 
            SubscriptBox["\[Alpha]", "4"]}]], TraditionalForm]]],
  "are ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]independent numbers. We start with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", "=", "4"}], TraditionalForm]]],
  " to obtain enough equations."
}], "Text"],

Cell[TextData[{
  "ansatz[Qn_, z_] := With[{d = 4, o = 4},\nSum[If[k + \[Alpha]0 + \[Alpha]1 \
+ \[Alpha]2 + \[Alpha]3 >= o, 0, \n       c[k, \[Alpha]0, \[Alpha]1, \
\[Alpha]2, \[Alpha]3, \[Alpha]4] z^k Qn[z]^\[Alpha]0 * ",
  StyleBox["(* avoid 0^0 *)", "CodeComment"],
  "\n       If[\[Alpha]1 == 0, 1, Qn'[z]^\[Alpha]1] If[\[Alpha]2 == 0, 1, \
Qn''[z]^\[Alpha]2]*\n       If[\[Alpha]3 == 0, 1, Qn'''[z]^\[Alpha]3] If[\
\[Alpha]4 == 0, 1, Qn''''[z]^\[Alpha]4]],\n    {k , 0, d}, {\[Alpha]0, 0, d}, \
{\[Alpha]1, 0, d}, \n    {\[Alpha]2, 0, d}, {\[Alpha]3, 0, d}, {\[Alpha]4, 0, \
d}]];"
}], "Input"],

Cell["We get 495 equations for 290 unknowns.", "Text"],

Cell["\<\
Length[cls = Flatten[Table[CoefficientList[ansatz[Q[k], z], z], {k, \
2, 7}]]]\
\>", "Input"],

Cell["Length[vars =  Union[Cases[cls, _c, Infinity]]]", "Input"],

Cell[TextData[{
  "We convert the equations ",
  StyleBox["cls", "MR"],
  " into the coefficient matrix ",
  Cell[BoxData[
      FormBox[
        StyleBox["M",
          FontWeight->"Bold",
          FontSlant->"Plain"], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
M = (Plus @@ (Times @@@ Internal`DistributedTermsList[#, \
vars][[1]]))& /@ cls;\
\>", "Input"],

Cell["\<\
Next, we calculate a modular nullspace (which is faster and if a \
differential equation exists, it will very probably have nice small \
coefficients).\
\>", "Text"],

Cell["\<\
prime = Prime[10000];
ns = NullSpace[M, Modulus -> prime];
Length[ns]\
\>", "Input"],

Cell["\<\
Substituting the result in the above ansatz yields the following \
nonlinear fourth order differential equation.\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            RowBox[{"-", "z"}], " ", 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", "\[Prime]",
                  MultilineFunction->None], "(", "z", ")"}], "2"]}], "+", 
          RowBox[{"4", " ", 
            RowBox[{
              SubsuperscriptBox["Q", "n", 
                TagBox[
                  RowBox[{"(", "3", ")"}],
                  Derivative],
                MultilineFunction->None], "(", "z", ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["Q", "n", "\[Prime]",
                MultilineFunction->None], "(", "z", ")"}]}], "-", 
          RowBox[{"3", " ", 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox["Q", "n", "\[Prime]\[Prime]",
                  MultilineFunction->None], "(", "z", ")"}], "2"]}], "+", 
          RowBox[{
            RowBox[{
              SubscriptBox["Q", "n"], "(", "z", ")"}], " ", 
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubsuperscriptBox["Q", "n", "\[Prime]",
                    MultilineFunction->None], "(", "z", ")"}], "+", 
                RowBox[{"z", " ", 
                  RowBox[{
                    SubsuperscriptBox["Q", "n", "\[Prime]\[Prime]",
                      MultilineFunction->None], "(", "z", ")"}]}], "-", 
                RowBox[{
                  SubsuperscriptBox["Q", "n", 
                    TagBox[
                      RowBox[{"(", "4", ")"}],
                      Derivative],
                    MultilineFunction->None], "(", "z", ")"}]}], ")"}]}]}], 
        "=", "0"}], TraditionalForm]], "DisplayFormula"],

Cell["\<\
Factor[ansatz[\[ScriptCapitalQ][n], z] /. 
       (Rule @@@ Transpose[{vars, Mod[ns[[1]], prime, \
-Floor[prime/2]]}])]\
\>", "Input"],

Cell["\<\
We end with a quick check of the differential equation for higher \
order polynomials.\
\>", "Text"],

Cell["\<\
Table[(Qn[z] Qn'[z] - z Qn'[z]^2 + z Qn[z] Qn''[z] - 
       3 Qn''[z]^2 + 4 Qn'[z] Qn'''[z] - Qn[z] Qn''''[z] /. 
                      Qn -> Function[z, Evaluate[Q[k][z]]]) // Expand,
      {k, 30}] // Union\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  6.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Implicit Hypocycloidal Torus"
}], "ExerciseHeading"],

Cell[TextData[{
  "Find an implicit polynomial representation for the parametrized surface ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalS]", TraditionalForm]]],
  " given by"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}], ",", 
            RowBox[{"y", "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}], ",", 
            RowBox[{"z", "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}]}], "}"}], 
        "=", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              RowBox[{"2", " ", 
                RowBox[{"cos", "(", "\[CurlyTheta]", ")"}]}], "+", 
              RowBox[{
                RowBox[{
                  SubsuperscriptBox["\[ScriptCapitalC]", "3", 
                    RowBox[{"(", "1", ")"}]], "(", 
                  RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}], 
                RowBox[{"cos", "(", "\[CurlyTheta]", ")"}]}]}], ",", 
            RowBox[{
              RowBox[{"2", " ", 
                RowBox[{"sin", "(", "\[CurlyTheta]", ")"}]}], "+", 
              RowBox[{
                RowBox[{
                  SubsuperscriptBox["\[ScriptCapitalC]", "3", 
                    RowBox[{"(", "1", ")"}]], "(", 
                  RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}], " ", 
                RowBox[{"sin", "(", "\[CurlyTheta]", ")"}]}]}], ",", 
            RowBox[{
              SubsuperscriptBox["\[ScriptCapitalC]", "3", 
                RowBox[{"(", "2", ")"}]], "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}]}], "}"}]}],
       TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SubsuperscriptBox["\[ScriptCapitalC]", "3", 
                RowBox[{"(", "1", ")"}]], "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}], ",", 
            RowBox[{
              SubsuperscriptBox["\[ScriptCapitalC]", "3", 
                RowBox[{"(", "2", ")"}]], "(", 
              RowBox[{"\[CurlyPhi]", ",", "\[CurlyTheta]"}], ")"}]}], "}"}], 
        "=", 
        RowBox[{
          RowBox[{"{", 
            RowBox[{
              FractionBox[
                RowBox[{
                  RowBox[{"cos", "(", "\[CurlyPhi]", ")"}], "+", 
                  RowBox[{
                    RowBox[{"tan", "(", 
                      RowBox[{"\[CurlyTheta]", "/", "4"}], ")"}], 
                    RowBox[{"cos", "(", 
                      RowBox[{"n", " ", "\[CurlyPhi]"}], ")"}], " "}]}], 
                RowBox[{"1", "+", 
                  RowBox[{"tan", "(", 
                    RowBox[{"\[CurlyTheta]", "/", "4"}], ")"}]}]], ",", 
              FractionBox[
                RowBox[{
                  RowBox[{"sin", "(", "\[CurlyPhi]", ")"}], "-", 
                  RowBox[{
                    RowBox[{"tan", "(", 
                      RowBox[{"\[CurlyTheta]", "/", "4"}], ")"}], 
                    RowBox[{"cos", "(", 
                      RowBox[{"n", " ", "\[CurlyPhi]"}], ")"}], " "}]}], 
                RowBox[{"1", "+", 
                  RowBox[{"tan", "(", 
                    RowBox[{"\[CurlyTheta]", "/", "4"}], ")"}]}]]}], "}"}], 
          "."}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Visualize the parametrized and the implicit surface. (The parametrized \
form is the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "3"}], TraditionalForm]]],
  " version of the hypocycloidal torus from Subsection 2.3.5 of the Graphics \
volume.)"
}], "Text"],

Cell["\<\
\[ScriptCapitalC][n_][\[CurlyTheta]_, \[CurlyPhi]_] = {Cos[\
\[CurlyPhi]] + Tan[\[CurlyTheta]/4] Cos[n \[CurlyPhi]],
                 Sin[\[CurlyPhi]] - Tan[\[CurlyTheta]/4] Sin[n \
\[CurlyPhi]]}/(Tan[\[CurlyTheta]/4] + 1);
                      
\[ScriptCapitalS][\[CurlyPhi]_, \[CurlyTheta]_] = {2 Cos[\[CurlyTheta]] + \
\[ScriptCapitalC][3][\[CurlyTheta], \[CurlyPhi]][[1]] Cos[\[CurlyTheta]], 
             2 Sin[\[CurlyTheta]] + \[ScriptCapitalC][3][\[CurlyTheta], \
\[CurlyPhi]][[1]] Sin[\[CurlyTheta]],  \[ScriptCapitalC][3][\[CurlyTheta], \
\[CurlyPhi]][[2]]};\
\>", "Input"],

Cell["Here is the parametrized surface.", "Text"],

Cell[TextData[{
  StyleBox["(* cut a hole in a polygon *)", "CodeComment"],
  "\nmakeHole[Polygon[l_], factor_] :=\nModule[{mp = Plus @@ l/Length[l], L, \
nOld, nNew},\n L = (mp + factor(# - mp))& /@ l;\n {nOld, nNew} = \
Partition[Append[#, First[#]]&[#], 2, 1]& /@ {l, L};\n \
{MapThread[Polygon[Join[#1, Reverse[#2]]]&, {nOld, nNew}],\n  Line /@ \
nNew}];"
}], "Input"],

Cell["\<\
Show[Block[{$DisplayFunction = Identity},
      ParametricPlot3D[Evaluate[Append[\[ScriptCapitalS][\[CurlyPhi], \
\[CurlyTheta]], {EdgeForm[], Thickness[0.001],
                        SurfaceColor[Hue[\[CurlyPhi]/(2Pi)], \
Hue[\[CurlyPhi]/(2Pi)], 2.2]}]], 
                       {\[CurlyPhi], 0, 2Pi}, {\[CurlyTheta], 0, 2Pi}, \
PlotPoints -> 37]] /. 
                                     p_Polygon :> makeHole[p, 0.8],
     Boxed -> False, Axes -> False]\
\>", "Input"],

Cell[TextData[{
  "To calculate a implicit polynomial version, we write the three coordinates \
in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{
            RowBox[{"\[PlusMinus]", "i"}], " ", "\[CurlyPhi]"}], ")"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{
            RowBox[{"\[PlusMinus]", "i"}], " ", "\[CurlyTheta]"}], ")"}], 
        TraditionalForm]]],
  " ."
}], "Text"],

Cell["\<\
eqs1 = Numerator[Together[{x, y, z} - \
\[ScriptCapitalS][\[CurlyPhi], \[CurlyTheta]]]] /. \[CurlyTheta] -> 4 \
\[Theta]\
\>", "Input"],

Cell["\<\
eqs\[CurlyPhi]\[CurlyTheta] = \
ExpandAll[Numerator[Together[TrigToExp[
          Numerator[Together[{x, y, z} - \[ScriptCapitalS][\[CurlyPhi], \
\[CurlyTheta]]]] /. \[CurlyTheta] -> 4 \[Theta]]]]] \
\>", "Input"],

Cell[TextData[{
  "Replacing the exponentials with variables yields three equations from \
which the two parametrization variables ",
  StyleBox["X", "MR"],
  " and ",
  StyleBox["Y", "MR"],
  " are to be eliminated."
}], "Text"],

Cell["\<\
eqsXY = eqs\[CurlyPhi]\[CurlyTheta] //. {Exp[\[Alpha]_ \[CurlyPhi] \
+ \[Beta]_ \[Theta]] :> X^(\[Alpha]/I) Y^(\[Beta]/I),
                   Exp[\[Alpha]_ \[CurlyPhi]] :> X^(\[Alpha]/I), Exp[\[Beta]_ \
\[Theta]] :> Y^(\[Beta]/I)}\
\>", "Input"],

Cell["\<\
We start by eliminating the variable X because it appears in a \
lower degree.\
\>", "Text"],

Cell["{Exponent[eqsXY, X], Exponent[eqsXY, Y]}", "Input"],

Cell["\<\
res1 = Cases[#, _Plus?(MemberQ[#, x, Infinity]&), Infinity]& @ 
       Factor[Resultant[eqsXY[[1]], eqsXY[[2]], X, Method -> Modular]]\
\>", \
"Input"],

Cell["\<\
(res2 = Cases[#, _Plus?(MemberQ[#, x, Infinity]&), Infinity]& @ 
       Factor[Resultant[eqsXY[[1]], eqsXY[[3]], X, Method -> Modular]]) //
                                                              Short[#, \
5]&\
\>", "Input"],

Cell[TextData[{
  "By introducing a new variable ",
  StyleBox["YS", "MR"],
  " via ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          StyleBox["Y",
            "MR",
            FontSlant->"Plain"], "2"], TraditionalForm]]],
  StyleBox["=Y", "MR"],
  ", yields two polynomials of degree 4 and 28 in ",
  StyleBox["YS", "MR"],
  ". Another call to ",
  StyleBox["Resultant", "MR"],
  " yields the desired implicit representation of the hypocycloidal torus. \
Because of its relatively large size (1792 terms), we display it in \
abbreviated form only."
}], "Text"],

Cell["{res1a, res2a} = {res1[[1]], res2[[1]]} /. Y -> YS^(1/2);", "Input"],

Cell["\<\
res3 = Factor[Resultant[res1a, res2a, YS, 
              Method -> Subresultants]/(268435456 x^24)];
{Head[res3], Length[res3], Exponent[res3, {x, y, z}]}              \
\>", \
"Input"],

Cell["Short[res3, 12]", "Input"],

Cell["\<\
By using two random points from the parametrized surface, we can \
quickly check the correctness of the derived implicit form.\
\>", "Text"],

Cell[TextData[{
  "res3 /. Block[{\[CurlyPhi] = Sqrt[Pi], \[CurlyTheta] = 1/E}, ",
  StyleBox["(* check to 1000 digits *)", "CodeComment"],
  "\n              Rule @@@ Transpose[{{x, y, z}, N[\[ScriptCapitalS][\
\[CurlyPhi], \[CurlyTheta]], 1000]}]]"
}], "Input"],

Cell[TextData[{
  "The following plot shows various cross sections of the implicit surface \
for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "=", 
          StyleBox["constant",
            FontSlant->"Italic"]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[Table[
ContourPlot[Evaluate[N[res3 /. z -> \[Zeta]]], {x, -4, 4}, {y, -4, 4}, 
            ContourStyle -> {{Hue[0.8 \[Zeta]/4], Thickness[0.001]}}, 
            PlotPoints -> 240, DisplayFunction -> Identity,
            Contours -> {0}, ContourShading -> False], 
            {\[Zeta], 4, 0, -4/24}],
     DisplayFunction -> $DisplayFunction]\
\>", "Input"],

Cell[TextData[{
  "Here is a similar plot showing various cross sections of the implicit \
surface for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "=", 
          StyleBox["constant",
            FontSlant->"Italic"]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Show[Table[
ContourPlot[Evaluate[N[res3 /. y -> \[Psi]]], {x, -4, 4}, {z, -2, 2}, 
            ContourStyle -> {{Hue[0.8 (\[Psi] + 4)/8], Thickness[0.001]}}, 
            PlotPoints -> 240, DisplayFunction -> Identity,
            Contours -> {0}, ContourShading -> False], 
            {\[Psi], -4, 4, 8/32}],
     DisplayFunction -> $DisplayFunction]\
\>", "Input"],

Cell["\<\
res4 = Factor[res3 //. {x -> r Cos[\[CurlyPhi]], y -> r Sin[\
\[CurlyPhi]]}]/r^4;\
\>", "Input"],

Cell[TextData[{
  "By making contour plots for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyPhi]", "=", "constant"}], TraditionalForm]]],
  " in a cylindrical coordinate system, we can visualize how the cross \
section of the hypocycloidal torus changes."
}], "Text"],

Cell[TextData[{
  StyleBox["(* change from Cartesian to polar coordinates *)", 
    "CodeComment"],
  "\nres4 = Factor[res3 //. {x -> r Cos[\[CurlyPhi]], y -> r \
Sin[\[CurlyPhi]]}]/r^4;"
}], "Input"],

Cell["\<\
tab = Table[
ContourPlot[Evaluate[N[res4 /. \[CurlyPhi] -> \[Phi]]], {r, 0, 4}, {z, -2, \
2}, 
            ContourStyle -> {{Hue[0.8 \[Phi]/(2Pi)], Thickness[0.001]}}, 
            PlotPoints -> 240, DisplayFunction -> Identity,
            Contours -> {0}, ContourShading -> False], 
            {\[Phi], 0, 2Pi (1 - 1/24), 2Pi/24}];
            
Show[Graphics3D[Table[{Thickness[0.002], Hue[k/24],
            Apply[{#1 Cos[k/24 2Pi], #1 Sin[k/24 2Pi], #2}&,
            Cases[Graphics @ tab[[k]], _Line, Infinity], {-2}]},
           {k, 24}]]]\
\>", "Input"],

Cell[TextData[{
  "We end with a visualization of the 3D surface using ",
  StyleBox["Graphics`ContourPlot3D", "MR"],
  ". We show the whole surface and the surface cut by the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "=", "0"}], TraditionalForm]]],
  "\[Hyphen]plane and the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "=", "0"}], TraditionalForm]]],
  "\[Hyphen]plane."
}], "Text"],

Cell["Needs[\"Graphics`ContourPlot3D`\"]", "Input"],

Cell["\<\
Show[Graphics3D[{EdgeForm[], 
SurfaceColor[Hue[0.12], Hue[0.32], 2.6], 
({#, Map[{1, 1, -1} #&, #, {-2}]}&[Apply[{#1 Cos[#2], #1 Sin[#2], #3}&, 
        Cases[ContourPlot3D[Evaluate[N[res4]], 
                {r, 0, 4}, {\[CurlyPhi], 0, 2Pi}, {z, 0, 2},
                MaxRecursion -> 1, PlotPoints -> {{24, 3}, {32, 3}, {12, 3}},
                DisplayFunction -> Identity], _Polygon, Infinity], {-2}]])}] \
/. 
     p_Polygon :> DeleteCases[makeHole[p, 0.76], _Line, Infinity]]\
\>", \
"Input"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity},
      {Show[%, PlotRange -> {All, All, {-2, 0}}, ViewPoint -> {0, 0, 5}],
       Show[%, PlotRange -> {All, {-4, 0}, All}, ViewPoint -> {0, 5, \
0}]}]]]\
\>", "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  7.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Second Feigenbaum Constant"
}], "ExerciseHeading"],

Cell[TextData[{
  "Construct an approximate solution to the functional equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"f", "(", "z", ")"}], "=", 
          RowBox[{"\[Alpha]", " ", 
            RowBox[{"f", "(", 
              RowBox[{"f", "(", 
                RowBox[{"z", " ", "/", "\[Alpha]"}], ")"}], ")"}]}]}], 
        TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", 
          RowBox[{"1", "/", 
            RowBox[{"f", "(", "1", ")"}]}]}], TraditionalForm]]],
  " in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"f", "(", "z", ")"}], "=", 
          RowBox[{"1", "+", 
            RowBox[{
              UnderoverscriptBox["\[Sum]", 
                RowBox[{"k", "=", "1"}], "n"], 
              RowBox[{
                SubscriptBox["c", "k"], 
                SuperscriptBox["z", 
                  RowBox[{"2", "k"}]]}]}]}]}], TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["f", "\[DoublePrime]"], "(", "0", ")"}], "<", 
          "0"}], TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Feigenbaum78"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Feigenbaum78",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Vul84"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Vul84",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lanford82"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lanford82",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Lesne98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lesne98",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Rasband90"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Rasband90",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Calculate ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " (the second Feigenbaum constant) to 20 significant digits. Use the power \
series and argument reduction to plot the function ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "x", ")"}], TraditionalForm]]],
  " in the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"100", ",", " ", "100"}], "]"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "To calculate the coefficients ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ", we will fix ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ", substitute the series into the functional equation, and set the \
resulting coefficients of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " equal to zero. The function ",
  StyleBox["eqs", "MR"],
  " gives a list of the resulting series coefficients for a given list of \
numeric ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
f[z_, cList_] := 1 + cList.z^(2 Range[Length[cList]]);

rGSeries[z_, cList_] := With[{\[Alpha] = 1/f[1, cList]}, f[z, cList] - 
         \[Alpha] f[f[z/\[Alpha], cList], cList] + O[z]^(2 Length[cList] + \
1)];

eqs[cList_?(VectorQ[#, NumericQ]&)] :=
Module[{\[Delta] = rGSeries[z, cList]}, 
      Table[Coefficient[\[Delta], z, 2j], {j, Length[cList]}]]\
\>", "Input"],

Cell[TextData[{
  "An approximate value for ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "1"], TraditionalForm]]],
  "is ",
  Cell[BoxData[
      FormBox[
        RowBox[{"-", "1.4"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["rGSeries[z, {c1}]", "Input"],

Cell["Solve[CoefficientList[%, z] == 0, {c1}] // N", "Input"],

Cell[TextData[{
  "Adding now one ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " at a time, we can quickly calculate a 20\[Hyphen]digit approximation for \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "/", 
          RowBox[{"f", "(", "0", ")"}]}], TraditionalForm]]],
  ". To avoid large symbolic expressions of the truncated functional \
equation, we restrict the first argument of ",
  StyleBox["FindRoot", "MR"],
  " to purely numeric ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "cListT = {-3/2}; \[CurlyEpsilon] = 10^-6; n = 1; \[Alpha]Old = 0;\n  \n\
While[\[Alpha]New = 1/f[1, cListT]; Abs[\[Alpha]New - \[Alpha]Old] > 10^-12,\n\
      n++; \[Alpha]Old = \[Alpha]New; cList = Table[c[k], {k, n}];\n      ",
  StyleBox["(* smallest coefficient plus some digits *)", "CodeComment"],
  "\n      scale = Round[-Log[10, Abs[Last[cListT]]]] + 10; \n      ",
  StyleBox["(* new coefficient list *)", "CodeComment"],
  "\n      cListT = Last /@ ",
  StyleBox["(* solve for the c_k *)", "CodeComment"],
  "\n        FindRoot[eqs[cList] == 0, ",
  StyleBox["(* starting values *)", "CodeComment"],
  "\n         Evaluate[MapIndexed[{c[#2[[1]]], (1 - \[CurlyEpsilon]) #1, (1 + \
\[CurlyEpsilon]) #1}&, \n                  AppendTo[cListT, \
Last[cListT]/10]]],\n         ",
  StyleBox["(* use adaptive precision and goals *)", "CodeComment"],
  "         \n         WorkingPrecision -> 2 scale, PrecisionGoal -> scale,\n \
        AccuracyGoal -> {scale, Infinity}, Method -> Secant]]"
}], "Input"],

Cell["N[\[Alpha]New, 20]", "Input"],

Cell[TextData[{
  "This results agrees with the known value of ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Briggs91"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Briggs91",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Christiansen90"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Christiansen90",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "Now we will plot the function. A direct use of the power series allows to \
plot the function for small ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ", say ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "\[LessTilde]", "3."}], TraditionalForm]]],
  " By observing that in the interval ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{
            RowBox[{"-", "1"}], ",", "1"}], "]"}], TraditionalForm]]],
  ", the function ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "x", ")"}], TraditionalForm]]],
  " is always contracting, we repeatedly apply the functional equation to \
bring the argument finally to a size where we can apply the power series ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"f", "(", "x", ")"}], "=", 
          RowBox[{
            SuperscriptBox["\[Alpha]", "n"], 
            RowBox[{
              SuperscriptBox["f", 
                RowBox[{"(", 
                  SuperscriptBox["2", "n"], ")"}]], "(", 
              RowBox[{"x", "/", 
                SuperscriptBox["\[Alpha]", "n"]}], ")"}]}]}], 
        TraditionalForm]]],
  " (here ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["f", 
          RowBox[{"(", "k", ")"}]], TraditionalForm]]],
  " stands for the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th iterate of ",
  Cell[BoxData[
      FormBox["f", TraditionalForm]]],
  ") ",
  "[",
  
  CounterBox["BibliographyCounter", "Wells94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wells94",
    ButtonStyle->"Hyperlink"],
  "]",
  ". The function ",
  StyleBox["fCF", "MR"],
  " implements a compiled version of this procedure."
}], "Text"],

Cell[TextData[{
  StyleBox["(* machine number version inside the interval [-1, 1] *)", 
    "CodeComment"],
  "\nfUD[z_] = 1. - 1.5276329970363323 z^2 + \n0.1048151947874277 z^4 + \
0.026705670524930787 z^6 - \n0.003527409660464297 z^8 + \
0.00008160096594827505 z^10 + \n0.000025285084886512315 z^12 - \
2.5563177536625283*^-6 z^14 - \n9.65122702290271*^-8 z^16 + \
2.8193175723520713*^-8 z^18 - \n2.771441260107602*^-10 z^20 - \
3.0292086423142963*^-10 z^22 + \n2.6739057855563045*^-11 z^24 + \
9.838888060875235*^-13 z^26 - \n3.5838769501333333*^-13 z^28 + \
2.063994985307743*^-14 z^30;"
}], "Input"],

Cell[TextData[{
  "fCF = Compile[{z},\n             Module[{\[Alpha] = \
-2.5029078750959130867, n, \[Zeta]},\n                    If[Abs[z] <= 1., n \
= 0, ",
  StyleBox["(* reduce argument size *)", "CodeComment"],
  "\n                       n = Ceiling[Log[-\[Alpha], Abs[z]]]]; \n          \
          \[Zeta] = z/\[Alpha]^n; Do[\[Zeta] = #, {2^n}]; (\[Alpha])^n \
\[Zeta]]]&[fUD[\[Zeta]]];"
}], "Input"],

Cell[TextData[{
  "Here is a plot of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "x", ")"}], TraditionalForm]]],
  ". It has a quite complicated structure ",
  "[",
  
  CounterBox["BibliographyCounter", "Chang86"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chang86",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
Plot[fCF[x], {x, -100, 100}, PlotPoints -> 200, PlotRange -> All]\
\
\>", "Input"],

Cell[TextData[{
  "We now could try to make a plot in the complex plane. Unfortunately, the \
last construction does not always converge because for some numbers ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " from the unit disk, the values ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "z", ")"}], TraditionalForm]]],
  " become too large ",
  "[",
  
  CounterBox["BibliographyCounter", "Wells94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wells94",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Trying to use the recursion directly might not terminate. So we restrict \
the number of recursions in the following (to 40) and calculate the function \
over a domain where the recursions end quickly. "
}], "Text"],

Cell[TextData[{
  StyleBox["(* use larger value to obtain potentially more points *)", 
    "CodeComment"],
  "\n$RecursionLimit = 40 ;\n\[Alpha] = 2.5029078750959130867`",
  StyleBox["(* use machine arithmetic! *)", "CodeComment"],
  ";\nfR[z_] := -\[Alpha] fR[fR[z/\[Alpha]]] /; Abs[z] >= 1\nfR[z_] := fUD[z] \
/; Abs[z] < 1\n\nL = 16; pp = 240;\nOff[$RecursionLimit::reclim];\ndata = \
Table[If[NumberQ[#], #, \n                ",
  StyleBox["(* no recursion termination *)", "CodeComment"],
  " C]&[fR[x + I y]],\n             {y, -L, L, 2L/pp}, {x, -L, L, 2L/pp}];"
}], "Input"],

Cell[TextData[{
  "Here is the absolute value of the Feigenbaum\[Dash]Cvitanovi\[CAcute] \
function for the ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]values where the recursion terminates within 40 iterations. It \
shows a very complicated behavior over the complex plane."
}], "Text"],

Cell[TextData[{
  "Show[Graphics3D[\nListPlot3D[ArcTan[Abs[data]] /. ArcTan[Abs[C]] -> -1,\n  \
         ",
  StyleBox["(* color cyclically with argument *)", "CodeComment"],
  "\n           Map[Hue, (Arg[data] + Pi)/(2Pi), {2}], ClipFill -> None,\n    \
       PlotRange -> {0, Pi/2}, BoxRatios -> {1, 1, 0.3}, \n           Mesh -> \
False, DisplayFunction -> Identity,\n           MeshRange -> L {{-1, 1}, {-1, \
1}}]] /. \n           ",
  StyleBox["(* remove steep vertical polygons *)", "CodeComment"],
  "\n           {p:Polygon[l_] :> If[Min[Last /@ l] < 0, {}, p],\n            \
h_Hue :> SurfaceColor[h, h, 2.2]},\n           DisplayFunction -> \
$DisplayFunction, Lighting -> True]"
}], "Input"],

Cell[TextData[{
  "For the Feigenbaum attractor, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Frisch03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Frisch03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  8.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Sequence of Delta Function Potential"
}], "ExerciseHeading"],

Cell[TextData[{
  "The Green\[CloseCurlyQuote]s function ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["G", "k"], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "n", ")"}]]}]}], ")"}], TraditionalForm]]],
  " for the time\[Hyphen]independent Schr\[ODoubleDot]dinger equation with a \
sum of delta function potentials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["V", 
              RowBox[{"(", "n", ")"}]], "(", "z", ")"}], "=", 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "n"], 
            RowBox[{
              SubscriptBox["V", "k"], 
              RowBox[{"\[Delta]", "(", 
                RowBox[{"z", "-", 
                  SubscriptBox["z", "k"]}], ")"}]}]}]}], TraditionalForm]]],
  " is defined through the equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{
              RowBox[{"-", 
                RowBox[{
                  SuperscriptBox["\[PartialD]", "2"], 
                  RowBox[{
                    SubscriptBox["G", "k"], "(", 
                    RowBox[{"y", ",", 
                      RowBox[{"x", ";", 
                        SuperscriptBox["V", 
                          RowBox[{"(", "n", ")"}]]}]}], ")"}]}]}], "/", 
              RowBox[{"\[PartialD]", 
                SuperscriptBox["x", "2"]}]}], "+", 
            RowBox[{
              RowBox[{"V", "(", "x", ")"}], 
              RowBox[{
                SubscriptBox["G", "k"], "(", 
                RowBox[{"y", ",", 
                  RowBox[{"x", ";", 
                    SuperscriptBox["V", 
                      RowBox[{"(", "n", ")"}]]}]}], ")"}]}]}], "=", 
          RowBox[{
            SuperscriptBox["k", "2"], 
            RowBox[{
              SubscriptBox["G", "k"], "(", 
              RowBox[{"y", ",", 
                RowBox[{"x", ";", 
                  SuperscriptBox["V", 
                    RowBox[{"(", "n", ")"}]]}]}], ")"}]}]}], 
        TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Byron70"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Byron70",
    ButtonStyle->"Hyperlink"],
  "] and fulfills the recursion [",
  
  CounterBox["BibliographyCounter", "Besprosvany01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Besprosvany01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Grosche98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Grosche98",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Schmidt02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Schmidt02",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["G", "k", 
            RowBox[{"(", "0", ")"}]], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "0", ")"}]]}]}], ")"}], "=", 
        RowBox[{
          RowBox[{"-", 
            FractionBox["i", "k"]}], 
          SuperscriptBox["e", 
            RowBox[{"i", " ", "k", " ", 
              RowBox[{"\[LeftBracketingBar]", 
                RowBox[{"y", "-", "x"}], "\[RightBracketingBar]"}]}]]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["G", "k", 
            RowBox[{"(", "j", ")"}]], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "j", ")"}]]}]}], ")"}], "=", 
        RowBox[{
          RowBox[{
            SubsuperscriptBox["G", "k", 
              RowBox[{"(", 
                RowBox[{"j", "-", "1"}], ")"}]], "(", 
            RowBox[{"y", ",", 
              RowBox[{"x", ";", 
                SuperscriptBox["V", 
                  RowBox[{"(", "0", ")"}]]}]}], ")"}], "+", 
          FractionBox[
            RowBox[{
              SubscriptBox["V", "j"], 
              RowBox[{
                SubsuperscriptBox["G", "k", 
                  RowBox[{"(", 
                    RowBox[{"j", "-", "1"}], ")"}]], "(", 
                RowBox[{"y", ",", 
                  RowBox[{
                    SubscriptBox["z", "j"], ";", 
                    SuperscriptBox["V", 
                      RowBox[{"(", 
                        RowBox[{"j", "-", "1"}], ")"}]]}]}], ")"}], 
              RowBox[{
                SubsuperscriptBox["G", "k", 
                  RowBox[{"(", 
                    RowBox[{"j", "-", "1"}], ")"}]], "(", 
                RowBox[{
                  SubscriptBox["z", "j"], ",", 
                  RowBox[{"x", ";", 
                    SuperscriptBox["V", 
                      RowBox[{"(", 
                        RowBox[{"j", "-", "1"}], ")"}]]}]}], ")"}]}], 
            RowBox[{"1", "-", 
              RowBox[{
                SubscriptBox["V", "j"], 
                RowBox[{
                  SubsuperscriptBox["G", "k", 
                    RowBox[{"(", 
                      RowBox[{"j", "-", "1"}], ")"}]], "(", 
                  RowBox[{
                    SubscriptBox["z", "j"], ",", 
                    RowBox[{
                      SubscriptBox["z", "j"], ";", 
                      SuperscriptBox["V", 
                        RowBox[{"(", 
                          RowBox[{"j", "-", "1"}], ")"}]]}]}], ")"}]}]}]]}]}],
       TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["G", "k"], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "0", ")"}]]}]}], ")"}], "=", 
        RowBox[{
          RowBox[{
            SubsuperscriptBox["G", "k", 
              RowBox[{"(", "n", ")"}]], "(", 
            RowBox[{"y", ",", 
              RowBox[{"x", ";", 
                SuperscriptBox["V", 
                  RowBox[{"(", "0", ")"}]]}]}], ")"}], "."}]}], 
      TraditionalForm]}], "DisplayFormula"],

Cell[TextData[{
  "The poles of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["G", "k"], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "n", ")"}]]}]}], ")"}], TraditionalForm]]],
  " in the complex ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "\[Hyphen]plane indicate bound and resonant states. Make an animation that \
shows how the poles move in the complex ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "\[Hyphen]plane for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["V", 
            RowBox[{"(", "8", ")"}]], "(", "z", ")"}], TraditionalForm]]],
  " with the parameters ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["V", "j"], "=", 
          SuperscriptBox["e", 
            RowBox[{"i", " ", "\[Omega]"}]]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "\[LessEqual]", "\[Omega]", "\[LessEqual]", 
          RowBox[{"2", "\[Pi]"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["z", "j"], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"j", "-", "1"}], ")"}], "\[Lambda]"}]}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", "\[Element]", "\[DoubleStruckCapitalR]"}], 
        TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell["\<\
This is the general recursive definition of the Green\
\[CloseCurlyQuote]s function for a sum of 1D delta potentials.\
\>", \
"SolutionSubgroup"],

Cell[TextData[{
  "G[0][y_, x_] := -I/k Exp[I k Abs[y - x]]\n    \n",
  StyleBox["(* summed Dyson equation *)", "CodeComment"],
  "\nG[n_][y_, x_] := G[n - 1][y, x] + V[n] G[n - 1][y, z[n]] G[n - 1][z[n], \
x]/\n                 (1 - V[n] G[n - 1][z[n], z[n]])"
}], "Input"],

Cell[TextData[{
  "We specialize to the case of equidistant potential spikes (with distance \
",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  ") of identical strength ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalV]", TraditionalForm]]],
  " and cache togethered forms of the Green\[CloseCurlyQuote]s function. \
(Calculating these togethered forms instead of the direct ones is of course \
slower, but avoids an exponential increase of the size of the Green\
\[CloseCurlyQuote]s function.)"
}], "Text"],

Cell[TextData[{
  StyleBox["(* specialize to equal distance and identical strength *", 
    "CodeComment"],
  StyleBox[")", "CodeComment"],
  "\nz[n_] := \[Lambda] (n - 1); V[n_] := \[ScriptCapitalV]\n",
  StyleBox["(* recursively cache calculated Green's functions *)", 
    "CodeComment"],
  "\nDo[G[n][y_, x_] = Together[G[n][y, x]], {n, 1, 8}]"
}], "Input"],

Cell[TextData[{
  "This is the simplified form of the denominator of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["G", "k", 
            RowBox[{"(", "8", ")"}]], "(", 
          RowBox[{"y", ",", 
            RowBox[{"x", ";", 
              SuperscriptBox["V", 
                RowBox[{"(", "8", ")"}]]}]}], ")"}], TraditionalForm]]],
  ". Its poles in the complex ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "\[Hyphen]plane are the bound and resonant states of the potential. It \
factors into two parts."
}], "Text"],

Cell["\<\
den[k_, \[ScriptCapitalV]_, \[Lambda]_] = (If[Head[#] === Times, \
Collect[#, k, Factor]& /@ #, #]& @
                   Factor[Denominator[Together[G[8][0, 0]]]]) /. \
Abs[\[Lambda]] -> \[Lambda]\
\>", "Input"],

Cell[TextData[{
  "At ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "=", "0"}], TraditionalForm]]],
  " , the denominator has a root of order 7 for all generic values of ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalV]", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Series[den[k, \[ScriptCapitalV], \[Lambda]], {k, 0, 8}] // Factor\
\
\>", "Input"],

Cell[TextData[{
  "The following graphic shows the negative logarithm of the absolute value \
of the denominator over the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"i", " ", "\[Kappa]"}], TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]plane for attractive ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "=", 
          RowBox[{"-", "1"}]}], TraditionalForm]]],
  ". Poles in the denominator show up as humps. For large ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  " (meaning the single delta potentials) are widely separated we have 8 \
bound states (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Kappa]", "<", "0"}], TraditionalForm]]],
  ") with exponential (in ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  ") separation. For smaller ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  ", some of the bound states merge into the \[OpenCurlyDoubleQuote]zero \
energy state\[CloseCurlyDoubleQuote] until only one bound state survives. "
}], "Text"],

Cell["\<\
Plot3D[Evaluate[-Log @ Abs @ Re[den[I \[Kappa], -1, \[Lambda]]]],
       {\[Kappa], -3, 3},  {\[Lambda], 0, 3}, PlotPoints -> 360, 
       Mesh -> False, BoxRatios -> {1, 1/2, 1/4}, 
       PlotRange -> All, ViewPoint -> {0, -3, 2.6},
       AxesLabel -> {\"\[Kappa]\", \"\[Lambda]\", None}]\
\>", "Input"],

Cell[TextData[{
  "The following graphic shows the logarithm of the absolute value of the \
denominator over the complex ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "\[Hyphen]plane for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "=", "i"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", " ", "=", " ", "1"}], TraditionalForm]]],
  ". Most of the resonance states lie near the real axis."
}], "Text"],

Cell["\<\
Plot3D[Evaluate[{Log @ Abs @ Re[den[kx + I ky, I, 1]],
                   Hue[(Cos[Arg[den[kx + I ky, I, 1]]] + 1)/2]}],
       {kx, -6, 6}, {ky, -2, 2},  PlotPoints -> 360 {1, 1/3}, 
       Mesh -> False, BoxRatios -> {1, 1/2, 1/4}, PlotRange -> All,
       ViewPoint -> {1, 3, 2}]\
\>", "Input"],

Cell[TextData[{
  "For a speedy generation of the animation frames, we generate a compiled \
version of the denominator. We use ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", "=", "1"}], TraditionalForm]]],
  " in the following."
}], "Text"],

Cell["\<\
denCF = Compile[{{k, _Complex}, {\[ScriptCapitalV], _Complex}, \
\[Lambda]}, Evaluate[den[k, \[ScriptCapitalV], \[Lambda]]]];\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["polePlot", "MR"],
  " generates one frame of the animation for a given ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "=", 
          RowBox[{"exp", "(", 
            RowBox[{"i", " ", "\[Omega]"}], ")"}]}], TraditionalForm]]],
  ". The graphic shows the curves of vanishing real part in red and the \
curves of vanishing imaginary part in blue. The intersections are the bound \
and resonant states. We mark the poles by black dots. To find the \
intersection programmatically, we calculate the imaginary part of the \
denominators along the curves of vanishing real part. Because the \
intersections of the real and imaginary part are perpendicular (it is an \
analytic function in ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "), this will work fine. Using the endpoints of the line segments where the \
imaginary part changes sign as the starting points for ",
  StyleBox["FindRoot", "MR"],
  " allows to calculate the poles. (We could have also calculated a \
differential equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["k", "\[Prime]"], "(", "\[Omega]", ")"}], "=", 
          "\[Ellipsis]"}], TraditionalForm]]],
  " by differentiating the denominator with respect to ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " and solve this differential equation for once\[Hyphen]calculated starting \
pole position for a fixed ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Omega]", "0"], TraditionalForm]]],
  ".)"
}], "Text"],

Cell[TextData[{
  "polePlot[\[ScriptCapitalV]_, \[Lambda]_, L_, pp_] := \nModule[{data, \
cpPlots, cps, segments, startPoints},\n",
  StyleBox["(* values of the denominator over the complex k-plane *)", 
    "CodeComment"],
  "\ndata = Table[denCF[kx + I ky, \[ScriptCapitalV], \[Lambda]], \n          \
   {ky, -L/3, L/3, 2/3 L/(pp/3)}, {kx, -L, L, 2L/pp}];\n",
  StyleBox["(* contour plots of vanishing real and imaginary part *)", 
    "CodeComment"],
  "\ncpPlots = Show[cps = \nListContourPlot[#1[data], Contours -> {0}, \
ContourShading -> False,\n            MeshRange -> L {{-1, 1}, {-1, 1}/3}, \
AspectRatio -> Automatic,\n            DisplayFunction -> Identity, \
ContourStyle -> {Hue[#2]}]& @@@\n            {{Re, 0}, {Im, 0.76}}];\n",
  StyleBox["(* line segments of vanishing real part over the complex k-plane \
*)", "CodeComment"],
  "\nsegments = Map[{1, I}.#&, Flatten[Partition[First[#], 2, 1]& /@ \n       \
                   Cases[Graphics[cps[[1]]], _Line, Infinity], 1], {-2}];\n",
  StyleBox["(* start points for the numerical root finding *)", 
    "CodeComment"],
  "\nstartPoints = Plus @@@ segments[[Flatten[Position[Times @@@ \n           \
        Map[Sign[Im[denCF[#, \[ScriptCapitalV], \[Lambda]]]]&, segments, \
{-1}], -1]]]]/2;\n",
  StyleBox["(* the poles *)", "CodeComment"],
  "\nroots[\[ScriptCapitalV]] = Cases[FindRoot[den[k, \[ScriptCapitalV], \
\[Lambda]], {k, #},\n                     PrecisionGoal -> 5, AccuracyGoal -> \
5]& /@ startPoints,\n                   _Complex, {-1}];\n",
  StyleBox["(* show contour plots and poles *)", "CodeComment"],
  "\nShow[{cpPlots, Graphics[{PointSize[0.01], GrayLevel[0], \n               \
     Point[{Re[#], Im[#]}]& /@ roots[\[ScriptCapitalV]]}]},\n       \
DisplayFunction -> $DisplayFunction]]"
}], "Input"],

Cell[TextData[{
  "Here are some of the resulting plots for various ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalV]", TraditionalForm]]],
  "."
}], "Text"],

Cell["polePlot[#, 1, 6, 360]& /@ {1, -I, -1}", "Input"],

Cell[TextData[{
  "And here is the animation. It shows how the 2\[Times]8 poles nearest to \
the origin take part in an exchange of their position with respect to the \
axis ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"Re", "(", "k", ")"}], "=", "0"}], TraditionalForm]]],
  ". While doing this, the curves of vanishing real and imaginary parts \
perform a relatively complicated splitting and reuniting process. The other \
poles are largely uninfluenced by the changing potential."
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_DeltaFunctionPotential.nb"],
           None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
frames = 121; 
Do[polePlot[Exp[I \[Omega]], 1, 6, 360], {\[Omega], 0, 2Pi (1 - 1/frames), \
2Pi/frames}]\
\>", "Program"],

Cell["", "ProgramBottom"],

Cell["\<\
The movement of the poles as the potential changed along the unit \
circle is shown in the following.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* calculate zeros to be displayed in the next graphic *)", 
    "CodeComment"],
  "\nframes = 121; \nDo[Block[{$DisplayFunction = Identity},\n          \
polePlot[Exp[I \[Omega]], 1, 6, 360]], \n         {\[Omega], 0, 2Pi (1 - \
1/frames), 2Pi/frames}]"
}], "Input"],

Cell["\<\
Show[Graphics[{Hue[(Arg[#[[1, 1, 1]]] + Pi)/(2Pi)], 
               Point[{Re[#], Im[#]}]& /@ #[[2]]}& /@ DownValues[roots]],
     PlotRange -> All, AspectRatio -> Automatic]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  9.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Implicit Poynting Vector"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the Poynting vector ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            StyleBox["S",
              FontWeight->"Bold",
              FontSlant->"Plain"], "\[RightBracketingBar]"}], "\[Tilde]", 
          RowBox[{
            SuperscriptBox[
              RowBox[{"\[LeftBracketingBar]", 
                RowBox[{
                  StyleBox["n",
                    SpanMaxSize->2,
                    FontWeight->"Bold",
                    FontSlant->"Plain"], 
                  StyleBox["\[Times]",
                    SpanMaxSize->2,
                    FontWeight->"Bold",
                    FontSlant->"Plain"], 
                  RowBox[{
                    StyleBox["(",
                      SpanMaxSize->2,
                      FontSlant->"Plain"], 
                    RowBox[{
                      RowBox[{
                        StyleBox["(",
                          SpanMaxSize->2,
                          FontSlant->"Plain"], 
                        StyleBox[
                          RowBox[{"n", "-", "v"}],
                          SpanMaxSize->2,
                          FontWeight->"Bold",
                          FontSlant->"Plain"], 
                        StyleBox[")",
                          SpanMaxSize->2,
                          FontWeight->"Plain",
                          FontSlant->"Plain"]}], 
                      StyleBox["\[Times]",
                        SpanMaxSize->2,
                        FontWeight->"Bold",
                        FontSlant->"Plain"], 
                      StyleBox["a",
                        SpanMaxSize->2,
                        FontWeight->"Bold",
                        FontSlant->"Plain"]}], 
                    StyleBox[")",
                      SpanMaxSize->2,
                      FontWeight->"Bold",
                      FontSlant->"Plain"]}]}], 
                StyleBox["\[RightBracketingBar]",
                  SpanMaxSize->2]}], "2"], 
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{"1", "-", 
                  RowBox[{
                    StyleBox["n",
                      FontWeight->"Bold",
                      FontSlant->"Plain"], ".", 
                    StyleBox["v",
                      FontWeight->"Bold",
                      FontSlant->"Plain"]}]}], ")"}], 
              RowBox[{"-", "5"}]]}]}], TraditionalForm]]],
  " from Section 2.2 of the Graphics volume. Calculate the volume of the \
emission cone bounded by ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            StyleBox["S",
              FontWeight->"Bold",
              FontSlant->"Plain"], "\[RightBracketingBar]"}], 
          StyleBox["n",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"]}], TraditionalForm]]],
  ". For ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["a",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"], 
          StyleBox[
            RowBox[{
              StyleBox["|",
                SpanMaxSize->2,
                FontSlant->"Plain"], 
              StyleBox["|",
                SpanMaxSize->2,
                FontWeight->"Plain",
                FontSlant->"Plain"]}]], 
          StyleBox["n",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"]}], TraditionalForm]]],
  ", find an implicit polynomial representation ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", 
          RowBox[{"x", ",", "y", ",", "z"}], "}"}], TraditionalForm]]],
  " for the surface ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"{", 
            RowBox[{"x", ",", "y", ",", "z"}], "}"}], "=", 
          RowBox[{
            RowBox[{"\[LeftBracketingBar]", 
              StyleBox["S",
                FontWeight->"Bold",
                FontSlant->"Plain"], "\[RightBracketingBar]"}], 
            StyleBox["n",
              SpanMaxSize->2,
              FontWeight->"Bold",
              FontSlant->"Plain"]}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "Here is the Poynting vector. As before, we denote by ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " the angle between the vector ",
  Cell[BoxData[
      FormBox[
        StyleBox["a",
          SpanMaxSize->2,
          FontWeight->"Bold",
          FontSlant->"Plain"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        StyleBox["v",
          FontWeight->"Bold",
          FontSlant->"Plain"], TraditionalForm]]],
  "; the direction of ",
  Cell[BoxData[
      FormBox[
        StyleBox["v",
          FontWeight->"Bold",
          FontSlant->"Plain"], TraditionalForm]]],
  " we use again as the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis."
}], "SolutionSubgroup"],

Cell[TextData[{
  "Poynting[\[CurlyPhi]_, \[CurlyTheta]_, v0_, \[Alpha]_] =\nWith[{",
  StyleBox["(* direction *) ", "CodeComment"],
  "n = {Cos[\[CurlyTheta]], Sin[\[CurlyPhi]] Sin[\[CurlyTheta]], Cos[\
\[CurlyPhi]] Sin[\[CurlyTheta]]},\n      ",
  StyleBox["(* velocity *)", "CodeComment"],
  " v = {v0, 0, 0},\n      ",
  StyleBox["(* acceleration *)", "CodeComment"],
  " a = {Cos[\[Alpha]], 0, Sin[\[Alpha]]}}, \n      (Cross[n, Cross[n - v, \
a]].Cross[n, Cross[n - v, a]])/((1 - n.v)^5)];"
}], "Input"],

Cell[TextData[{
  "We obtain the volume ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "(", 
          RowBox[{
            SubscriptBox["v", "0"], ",", "\[Alpha]"}], ")"}], 
        TraditionalForm]]],
  " of the emission cone by carrying out the following integral: "
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[ScriptCapitalV]", "(", 
          RowBox[{
            SubscriptBox["v", "0"], ",", "\[Alpha]"}], ")"}], "\[Tilde]", 
        RowBox[{
          UnderoverscriptBox["\[Integral]", "0", "\[Pi]"], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "0", 
              RowBox[{"2", "\[Pi]"}]], 
            RowBox[{
              UnderoverscriptBox["\[Integral]", "0", 
                RowBox[{"\[LeftBracketingBar]", 
                  StyleBox["S",
                    FontWeight->"Bold",
                    FontSlant->"Plain"], "\[RightBracketingBar]"}]], 
              RowBox[{
                SuperscriptBox["r", "2"], 
                RowBox[{"sin", "(", "\[CurlyTheta]", ")"}], "d", 
                "\[InvisibleSpace]", "r", " ", "d", "\[InvisibleSpace]", 
                "\[CurlyPhi]", " ", "d", "\[InvisibleSpace]", 
                RowBox[{"\[CurlyTheta]", "."}]}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox["r", TraditionalForm]]],
  "\[Hyphen]integration is trivial and only the two angular integrations \
remain. Because ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox[
            RowBox[{"\[LeftBracketingBar]", 
              StyleBox["S",
                FontWeight->"Bold",
                FontSlant->"Plain"], "\[RightBracketingBar]"}], "3"], "/", 
          "3"}], TraditionalForm]]],
  " is a rational function in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cos", "(", "\[CurlyPhi]", ")"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sin", "(", "\[CurlyPhi]", ")"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cos", "(", "\[CurlyTheta]", ")"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sin", "(", "\[CurlyTheta]", ")"}], TraditionalForm]]],
  ", we will expand the integrand into products and integrate each term \
individually. For the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]integration we have 438 terms to integrate. Because all terms are \
smooth functions of ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[CurlyTheta]", TraditionalForm]]],
  ", we calculate the indefinite integral and substitute limits. This is \
faster than using ",
  StyleBox["Integrate", "MR"],
  " to calculate the definite integrals directly."
}], "Text"],

Cell["\<\
\[ScriptCapitalL] = Expand[Poynting[\[CurlyPhi], \[CurlyTheta], v0, \
\[Alpha]]^3/3];
Length[\[ScriptCapitalL]]\
\>", "Input"],

Cell["\<\
IndefInt\[CurlyPhi] = Integrate[#, \[CurlyPhi]]& /@ \
\[ScriptCapitalL];
defInt\[CurlyPhi] = (IndefInt\[CurlyPhi] /. \[CurlyPhi] -> 2Pi) - (IndefInt\
\[CurlyPhi] /. \[CurlyPhi] -> 0);
Length[defInt\[CurlyPhi]]\
\>", "Input"],

Cell[TextData[{
  "We have 95 terms to integrate for the ",
  Cell[BoxData[
      FormBox["\[CurlyTheta]", TraditionalForm]]],
  "\[Hyphen]integration. The resulting volume ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "(", 
          RowBox[{
            SubscriptBox["v", "0"], ",", "\[Alpha]"}], ")"}], 
        TraditionalForm]]],
  " is a relatively complicated function of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["v", "0"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
IndefInt\[CurlyTheta] = Integrate[# Sin[\[CurlyTheta]], \
\[CurlyTheta]]& /@ defInt\[CurlyPhi];
defInt\[CurlyTheta] = (IndefInt\[CurlyTheta] /. \[CurlyTheta] -> Pi) - \
(IndefInt\[CurlyTheta] /. \[CurlyTheta] -> 0);
emissionVolume[v0_, \[Alpha]_] = Factor[Together[defInt\[CurlyTheta]]]\
\>", \
"Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["v", "0"], "\[Rule]", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptCapitalV]", "(", 
          RowBox[{
            SubscriptBox["v", "0"], ",", "\[Alpha]"}], ")"}], 
        TraditionalForm]]],
  " diverges as ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{"(", 
            RowBox[{"1", "-", 
              SubscriptBox["v", "0"]}], ")"}], "11"], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Series[emissionVolume[v0, \[Alpha]], {v0, 1, -9}] // Simplify \
\
\>", "Input"],

Cell[TextData[{
  "Here is a plot of the normalized ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[ScriptCapitalV]", "(", 
            RowBox[{
              SubscriptBox["v", "0"], ",", "\[Alpha]"}], ")"}], "/", 
          RowBox[{"\[ScriptCapitalV]", "(", 
            RowBox[{
              SubscriptBox["v", "0"], ",", "0"}], ")"}]}], 
        TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["v", "0"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Plot3D[emissionVolume[v0, \[Alpha]]/emissionVolume[v0, 0], 
       {v0, -0.8, 0.8}, {\[Alpha], -Pi, Pi}, PlotRange -> All];\
\>", "Input"],

Cell[TextData[{
  "Now, let us derive the implicit form of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            StyleBox["S",
              FontWeight->"Bold",
              FontSlant->"Plain"], "\[RightBracketingBar]"}], 
          StyleBox["n",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"]}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["a",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"], 
          StyleBox[
            RowBox[{
              StyleBox["|",
                SpanMaxSize->2,
                FontSlant->"Plain"], 
              StyleBox["|",
                SpanMaxSize->2,
                FontWeight->"Plain",
                FontSlant->"Plain"]}]], 
          StyleBox["n",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"]}], TraditionalForm]]],
  ". These are the three parametrized equations for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "\[CurlyTheta]", ")"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "(", "\[CurlyTheta]", ")"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "(", "\[CurlyTheta]", ")"}], TraditionalForm]]],
  " (because of the rotational symmetry of the problem around the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis, we can use ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyPhi]", "=", "0"}], TraditionalForm]]],
  ")."
}], "Text"],

Cell["\<\
eqs = Numerator[Together[{x, y, z} - 
        Poynting[\[CurlyPhi], \[CurlyTheta], v0, 0] {Cos[\[CurlyTheta]], Sin[\
\[CurlyPhi]] Sin[\[CurlyTheta]], Cos[\[CurlyPhi]] Sin[\[CurlyTheta]]}]] /. \
\[CurlyPhi] -> 0\
\>", "Input"],

Cell["\<\
We convert the last equation into polynomial form by using the \
exponential representation for the trigonometric functions.\
\>", "Text"],

Cell["\<\
eqs1 = Numerator[Factor[Together[TrigToExp[eqs]] /. 
                 Exp[s_] :> (\[Theta]^(Coefficient[s, \
\[CurlyTheta]]/I))]]\
\>", "Input"],

Cell[TextData[{
  "Eliminating the parametrization variable ",
  Cell[BoxData[
      FormBox["\[Theta]", TraditionalForm]]],
  " yields an implicit polynomial of total degree 10 in ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Resultant[eqs1[[1]], eqs1[[3]], \[Theta], Method -> Modular] // \
Factor\
\>", "Input"],

Cell["\<\
Using the rotational symmetry, we have the following result for the \
surface of the emission cone.\
\>", "Text"],

Cell["\<\
PoyntingImplicit[{x_, y_, z_}, v0_] = Simplify[%[[-1]] /. z -> \
Sqrt[y^2 + z^2]]\
\>", "Input"],

Cell["\<\
Substituting the original expression for the Poynting vector in the \
last result shows its correctness.\
\>", "Text"],

Cell["\<\
Together[TrigToExp[PoyntingImplicit[Poynting[\[CurlyPhi], \
\[CurlyTheta], v0, 0]*
             {Cos[\[CurlyTheta]], Sin[\[CurlyPhi]] Sin[\[CurlyTheta]], Cos[\
\[CurlyPhi]] Sin[\[CurlyTheta]]}, v0]]]\
\>", "Input"],

Cell[TextData[{
  "We end with a set of contour plots of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            StyleBox["S",
              FontWeight->"Bold",
              FontSlant->"Plain"], "\[RightBracketingBar]"}], 
          StyleBox["n",
            SpanMaxSize->2,
            FontWeight->"Bold",
            FontSlant->"Plain"]}], TraditionalForm]]],
  " in the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]plane."
}], "Text"],

Cell[TextData[{
  "Show[{#, ",
  StyleBox["(* construct the lower half *)", "CodeComment"],
  "\n      # /. Line[l_] :> Line[{1, -1}# & /@ l]}&[ \n     Table[Graphics @ \
\n            ContourPlot[Evaluate[PoyntingImplicit[{x, 0, z}, v0]],\n        \
      {x, -3/2, 3}, {z, 0, 3}, PlotPoints -> 160,\n              Contours -> \
{0}, ContourShading -> False,\n              ContourStyle -> \
{{Thickness[0.002], Hue[v0]}},\n              DisplayFunction -> Identity, \
FrameTicks -> False],\n      ",
  StyleBox["(* various velocity/c values *)", "CodeComment"],
  " {v0, 0, 0.5, 0.5/20}]], \n      DisplayFunction -> $DisplayFunction]"
}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "10.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Symmetric Sphere Points"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the implicit equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], 
              RowBox[{"d", "+", "1"}]], 
            SubsuperscriptBox["x", "k", "2"]}], "=", "1"}], 
        TraditionalForm]]],
  " of a ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D sphere in ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[DoubleStruckCapitalR]", 
          RowBox[{"d", "+", "1"}]], TraditionalForm]]],
  ". For a fixed prime ",
  Cell[BoxData[
      FormBox["p", TraditionalForm]]],
  ", find integer solutions ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "k"], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], 
              RowBox[{"d", "+", "1"}]], 
            SubsuperscriptBox["x", "k", "2"]}], "=", 
          RowBox[{"1", " ", "mod", " ", "p"}]}], TraditionalForm]]],
  ". Symmetrize the resulting solution points ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["x", "1"], ",", 
            SubscriptBox["x", "2"], ",", "\[Ellipsis]", ",", 
            SubscriptBox["x", 
              RowBox[{"d", "+", "1"}]]}], "}"}], TraditionalForm]]],
  " with respect to the origin, then map them to the unit sphere and \
visualize them [",
  
  CounterBox["BibliographyCounter", "Bajnok02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bajnok02",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "The function ",
  StyleBox["spherePoints", "MR"],
  " calculates the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[DoubleStruckCapitalF]", "p"], TraditionalForm]]],
  "\[Hyphen]solutions of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "d"], 
            SubsuperscriptBox["x", "k", "2"]}], "=", "1"}], 
        TraditionalForm]]],
  ", then applies the symmetrization map ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "\[Rule]", 
          RowBox[{"x", "-", 
            RowBox[{
              RowBox[{"\[Theta]", "(", 
                RowBox[{"x", "-", 
                  RowBox[{"p", "/", "2"}], "+", 
                  RowBox[{"3", "/", "4"}]}], ")"}], " ", "p"}]}]}], 
        TraditionalForm]]],
  ", and finally maps the resulting points on the unit sphere. The function \
",
  StyleBox["Reduce", "MR"],
  " does the main work by solving the diophantine equation."
}], "SolutionSubgroup"],

Cell[TextData[{
  "spherePoints[d_Integer?(# > 1&), p_Integer?PrimeQ] := \nModule[{x, k, ffp, \
sffp},\n",
  StyleBox["(* return only explicit points *)", "CodeComment"],
  "\nDeveloper`SetSystemOptions[\"ReduceOptions\" -> \n                       \
     {\"DiscreteSolutionBound\" -> 10^5}];\n",
  StyleBox["(* solve implicit sphere equation over F_p *)", "CodeComment"],
  "\nffp = Reduce[Sum[x[i]^2, {i, d}] == 1 + ",
  StyleBox["(* any integer k *)", "CodeComment"],
  " k p &&\n              ",
  StyleBox["(* solutions in F_p only *)", "CodeComment"],
  "\n              And @@ Table[0 <= x[i] <= p - 1, {i, d}] && \n             \
 Element[k, Integers] && Element[Table[x[i], {i, d}], Integers], \n           \
   Table[x[i], {i, d}], Backsubstitution -> True];\n",
  StyleBox["(* symmetrize \[PlusMinus] *)", "CodeComment"],
  "\nsffp = Map[If[# <= (p - 1)/2, #, # - p]&, \n           Table[x[i], {i, \
d}] /. {ToRules[ffp]}, {-1}];\n",
  StyleBox["(* map points to unit sphere *) ", "CodeComment"],
  "#/Sqrt[#.#]& /@ sffp]           "
}], "Input"],

Cell[TextData[{
  "For points in 2D, we obtain regular ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "gons and some other symmetric arrangements of vertices. Here are a few \
examples shown."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
 Table[Graphics[{PointSize[0.02], Point /@ spherePoints[2, Prime[k]]},
                AspectRatio -> Automatic, Frame -> True, FrameTicks -> False,
                PlotRange -> 1.1 {{-1, 1}, {-1, 1}}], {k, 2, 7}]]]\
\>", \
"Input"],

Cell["\<\
For points in 3D, we obtain the following point sets for small \
primes.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[
 Table[Graphics3D[{PointSize[0.01], Point /@ spherePoints[3, Prime[k]]},
                Boxed -> True,
                PlotRange -> 1.1 {{-1, 1}, {-1, 1}, {-1, 1}}], {k, 2, 7}]]]\
\
\>", "Input"],

Cell["\<\
Here are the projected points for the 3D case for some larger \
primes.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@
Partition[
 Table[Graphics[{PointSize[0.01], Point[Most[#]]& /@ spherePoints[3, \
Prime[k]]},
                AspectRatio -> Automatic, Frame -> True, FrameTicks -> False,
                PlotRange -> 1.1 {{-1, 1}, {-1, 1}}], {k, 8, 19}], 6]\
\>", \
"Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "11.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L3"], TraditionalForm]]],
  " Isospectral Polygons"
}], "ExerciseHeading"],

Cell[TextData[{
  "Calculate and visualize some of the eigenvalues and eigenfunctions of the \
Helmholtz equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[CapitalDelta]\[Psi]", "(", 
            RowBox[{"x", ",", "y"}], ")"}], "=", 
          RowBox[{
            RowBox[{"-", 
              SuperscriptBox["\[Omega]", "2"]}], 
            RowBox[{"\[Psi]", "(", 
              RowBox[{"x", ",", "y"}], ")"}]}]}], TraditionalForm]]],
  " in the interior of the two spectral twins bilby and hawk [",
  
  CounterBox["BibliographyCounter", "Driscoll97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll97",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Driscoll03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Wu95"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wu95",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Sridhar94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sridhar94",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Dhar03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Dhar03",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Knowles04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Knowles04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Here are the shapes of the bilby and hawk. All horizontal and vertical \
edges have length 2 and all non\[Hyphen]90\[Degree] angles of the boundary \
are 45\[Degree] ."
}], "Text"],

Cell["\<\
Use higher order triangular finite elements (up to order 12) to \
discretize the problem. Compare the quality of higher order refinements with \
more triangles in a regular homogeneous refinement. \
\>", "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by implementing a streamlined and optimized version of the \
functions from Exercise 7a) that calculates the mass and stiffness matrices \
for the reference triangle with vertices ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0", ",", "0"}], "}"}], TraditionalForm]]],
  ", {1,0}, and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"0", ",", "1"}], "}"}], TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Solin04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Solin04",
    ButtonStyle->"Hyperlink"],
  "]. The optimizations include calculating all shape functions at once for a \
given order, using a simplified numbering of the nodes (only sums over all \
nodes occur in the results, so the individual node number does not matter), \
and carrying out the integration over the triangles not recursively, but at \
once."
}], "SolutionSubgroup"],

Cell[TextData[{
  "For a given order ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  ", the function ",
  StyleBox["ShapeFunctionList", "MR"],
  " returns a list of the ",
  StyleBox["O[", "MR"],
  StyleBox["o", "TI"],
  StyleBox["]", "MR"],
  " shape functions, such that the value of the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th shape function is one at the point ",
  StyleBox["basePoint[", "MR"],
  StyleBox["o", "TI"],
  StyleBox["][[", "MR"],
  StyleBox["k", "TI"],
  StyleBox["]]", "MR"],
  " and zero at the other base points."
}], "Text"],

Cell["\[ScriptCapitalO][o_] := (o + 1)(o + 2)/2;", "Input"],

Cell["\<\
basePoints[o_] := Flatten[Table[{i, j}/o, {j, 0, o}, {i, 0, o - \
j}], 1]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* calculate all shape functions of order o at once;\n   store \
calculated list of shape functions *)", "CodeComment"],
  "\nShapeFunctionList[o_, {\[Xi]_, \[Eta]_}] := ShapeFunctionList[o, {\[Xi], \
\[Eta]}] =\nModule[{monomials, \[ScriptCapitalL], sols},\n  monomials[{x_, \
y_}] = Flatten[Table[x^i y^(j - i), \n                                      \
{j, 0, o}, {i, 0, j}]];\n  ",
  StyleBox["(* form and solve equations efficiently *)", "CodeComment"],
  "\n  \[ScriptCapitalL] = LinearSolve[monomials /@ basePoints[o]];\n  ",
  StyleBox["(* use all \[ScriptCapitalO][o] right-hand side *)", 
    "CodeComment"],
  "\n  sols = Table[\[ScriptCapitalL] @ Table[KroneckerDelta[i, j], {i, \
\[ScriptCapitalO][o]}], {j, \[ScriptCapitalO][o]}];               \n  ",
  StyleBox["(* form polynomials *)", "CodeComment"],
  "\n  Evaluate[monomials[{\[Xi], \[Eta]}].#]& /@ sols]"
}], "Input"],

Cell["\<\
Calculating the 66 shape functions of order 10 can be done in a \
fraction of a second.\
\>", "Text"],

Cell["\<\
ShapeFunctionList[10, {\[Xi], \[Eta]}]; // Timing\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["\[ScriptCapitalT]\[ScriptCapitalI]", "MR"],
  " integrates the bivariate polynomial ",
  StyleBox["\[ScriptP]", "MR"],
  " over the unit triangle."
}], "Text"],

Cell[TextData[{
  StyleBox["(* integrating a bivariate polynomial over the unit triangle *)\n\
", "CodeComment"],
  "\[ScriptCapitalT]\[ScriptCapitalI][\[ScriptP]_, {x_, y_}] := Plus @@ \n   \
(Function[{p, q, c}, c (p! q!) /(p + q + 2)!] @@@ (Flatten /@ \n             \
Internal`DistributedTermsList[\[ScriptP], {x, y}][[1]]))"
}], "Input"],

Cell[TextData[{
  "And here are the definitions for the mass and stiffness matrices. For \
uniformity of notations and the arguments, both have the geometry parameters \
",
  Cell[BoxData[
      FormBox["J", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["A", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"B", " "}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox["C", TraditionalForm]]],
  " as parameters."
}], "Text"],

Cell[TextData[{
  "MassMatrix[o_, {J_, A_, B_, C_}] := MassMatrix[o, {J, A, B, C}] =\n\
Module[{M = Table[0, {\[ScriptCapitalO][o]}, {\[ScriptCapitalO][o]}], SL = \
ShapeFunctionList[o, {\[Xi], \[Eta]}]},\n       ",
  StyleBox["(* calculate matrix elements and fill in symmetrically *)", 
    "CodeComment"],
  "\n       Do[m = \[ScriptCapitalT]\[ScriptCapitalI][Expand[SL[[i]] \
SL[[j]]], {\[Xi], \[Eta]}];\n          M[[i, j]] = m; M[[j, i]] = m, {i, \
\[ScriptCapitalO][o]}, {j, i}]; J M]    "
}], "Input"],

Cell[TextData[{
  "StiffnessMatrix[o_, {J_, A_, B_, C_}] := StiffnessMatrix[o, {J, A, B, C}] \
=\nModule[{M = Table[0, {\[ScriptCapitalO][o]}, {\[ScriptCapitalO][o]}], SL = \
ShapeFunctionList[o, {\[Xi], \[Eta]}]},\n       ",
  StyleBox["(* calculate matrix elements and fill in symmetrically *)", 
    "CodeComment"],
  "\n       Do[m = (A \[ScriptCapitalT]\[ScriptCapitalI][Expand[D[SL[[i]], \
\[Xi]] D[SL[[j]], \[Xi]]], {\[Xi], \[Eta]}] +\n               C \
\[ScriptCapitalT]\[ScriptCapitalI][Expand[D[SL[[i]], \[Eta]] D[SL[[j]], \
\[Eta]]], {\[Xi], \[Eta]}] +\n               ",
  StyleBox["(* for the following, the next term vanishes *)", "CodeComment"],
  "\n               B \[ScriptCapitalT]\[ScriptCapitalI][Expand[D[SL[[i]], \
\[Xi]] D[SL[[j]], \[Eta]] +\n                           D[SL[[i]], \[Eta]] \
D[SL[[j]], \[Xi]]], {\[Xi], \[Eta]}]);\n          M[[i, j]] = m; M[[j, i]] = \
m, {i, \[ScriptCapitalO][o]}, {j, i}]; M]   "
}], "Input",
  CellMargins->{{Inherited, -23.1875}, {Inherited, Inherited}}],

Cell[TextData[{
  "Here are some timings for calculating some higher\[Hyphen]order mass and \
stiffness matrices that we will use later. Each requires the calculation of \
",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"o", "+", "1"}], ")"}], " ", 
            RowBox[{"(", 
              RowBox[{"o", "+", "2"}], ")"}], " ", 
            RowBox[{
              RowBox[{"(", 
                RowBox[{
                  SuperscriptBox["o", "2"], "+", 
                  RowBox[{"3", " ", "o"}], "+", "4"}], ")"}], "/", "8"}]}]}], 
        TraditionalForm]]],
  " integrations over the unit triangle. Calculating the 3\[Times]4186 \
integrals for the order 12 stiffness matrices takes a few minutes."
}], "Text"],

Cell["\<\
Table[{o, Timing[MassMatrix[o, {J, A, B, C}];][[1]],
          Timing[StiffnessMatrix[o, {J, A, B, C}];][[1]]}, {o, 12}]\
\>", \
"Input"],

Cell["\<\
Next let us deal with the geometrical shapes. Here are the outlines \
of bilby and hawk.\
\>", "Text"],

Cell[TextData[{
  "{triangles[bilby], triangles[hawk]} =\n",
  StyleBox["(* triangles expressed through vertices *)", "CodeComment"],
  "\n{Evaluate[Map[Slot, {{1, 2, 3}, {3, 4, 1}, {5, 1, 4}, {1, 5, 9}, \n      \
               {6, 9, 5}, {6, 8, 9}, {6, 7, 8}}, {2}]]&[\n     { 1, -1}, { 1, \
-3}, { 3, -1}, { 3,  1}, { 1,  1}, \n     {-1,  1}, {-1,  3}, {-3,  1}, {-1, \
-1}],\n Evaluate[Map[Slot, {{2, 9, 1}, {2, 3, 4}, {2, 4, 9}, {5, 9, 4}, \n    \
                 {5, 8, 9}, {5, 6, 8}, {7, 8, 6}}, {2}]]&[\n     { 1, -3}, { \
1, -1}, { 3, -1}, { 1,  1}, {-1,  1}, \n     {-1,  3}, {-3,  3}, {-3,  1}, \
{-1, -1}]};    "
}], "Input"],

Cell[TextData[{
  "Because later we will need smaller triangles, we define a function ",
  StyleBox["triangleMesh", "MR"],
  " that contains the ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  "\[Hyphen]times recursively subdivided triangles of bilby and hawk."
}], "Text"],

Cell["\<\
subdivideTriangle[{p1_, p2_, p3_}] :=
Module[{p4 = (p2 + p3)/2}, {{p4, p1, p2}, {p4, p3, p1}}]\
\>", "Input"],

Cell["\<\
triangleMesh[bilbyHawk_][o_] := triangleMesh[bilbyHawk][o] =
 Flatten[subdivideTriangle /@ triangleMesh[bilbyHawk][o - 1], 1];
   
triangleMesh[bilbyHawk_][0] = triangles[bilbyHawk];\
\>", "Input"],

Cell["\<\
Also, for later use, we define the bounding line segments of bilby \
and hawk.\
\>", "Text"],

Cell["\<\
borderLine[bilby] = {{1, -3}, {3, -1}, {3, 1}, {1, 1}, {-1, 1}, 
                     {-1, 3}, {-3, 1}, {-1, -1}, {1, -1}, {1, -3}};
                     
borderLine[hawk] = {{1, -3}, {1, -1}, {3, -1}, {1, 1}, {-1, 1}, 
                    {-1, 3}, {-3, 3}, {-3, 1}, {-1, -1}, {1, -3}}; \
\>", \
"Input"],

Cell[TextData[{
  "The functions ",
  StyleBox["edgePointQ[", "MR"],
  StyleBox["bilbyHawk", "TI"],
  StyleBox["]", "MR"],
  " calculate if a point ",
  StyleBox["{", "MR"],
  StyleBox["x", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["y", "TI"],
  StyleBox["}", "MR"],
  " lies on the boundary of bilby or hawk."
}], "Text"],

Cell[TextData[{
  "edgePointQ[bilby][{x_, y_}] := ",
  StyleBox["(* check all edges *)", "CodeComment"],
  "\n-1 <= x <= 3 && y == 1 || x == 3 && -1 <= y <= 1 ||\ny == x - 4 && -3 <= \
y <= -1 || x == 1 && -3 <= y <= -1 ||\n-1 <= x <= 1 && y == -1 || y == -x - 2 \
&& -1 <= y <= 1 ||\ny == x + 4 && 1 <= y <= 3 || x == -1 && 1 <= y <= 3"
}], "Input"],

Cell[TextData[{
  "edgePointQ[hawk][{x_, y_}] := ",
  StyleBox["(* check all edges *)", "CodeComment"],
  "\n-1 <= x <= 1 && y == 1 || x == -1 && 1 <= y <= 3 ||\n-3 <= x <= -1 && y \
== 3 || x == - 3 && 1 <= y <= 3 ||\ny == -x - 2 && -3 <= y <= 1 || x == 1 && \
-3 <= y <= -1 ||\n1 <= x <= 3 && y == -1 || y == -x + 2 && -1 <= y <= 1"
}], "Input"],

Cell["\<\
Here are triangulated versions of bilby and hawk and their \
outlines.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* f0r better visibility, contract a triangle *)", 
    "CodeComment"],
  "\ncontract[l_, f_] := Function[m, (m + f (# - m))& /@ l][Plus @@ l/3]\n\n\
Show[GraphicsArray[\nGraphics[{",
  StyleBox["(* the border lines segments *)", "CodeComment"],
  "\n          {GrayLevel[0], Thickness[0.02], Line[borderLine[#]]}, \n       \
    ",
  StyleBox["(* triangles forming bilby and hawk *)", "CodeComment"],
  "\n          {GrayLevel[0.6], Polygon[contract[#, 0.96]]}& /@ \n            \
                                triangleMesh[#][0],\n          ",
  StyleBox["(* recursively subdivided triangles *)", "CodeComment"],
  "\n          {Hue[Random[]], Polygon[contract[#, 0.5]]& /@ #}& /@ \n        \
                     Partition[triangleMesh[#][4], 8]},\n         AspectRatio \
-> Automatic, Frame -> True,\n         FrameTicks -> None]& /@ {bilby, \
hawk}]]"
}], "Input"],

Cell[TextData[{
  "For getting a couple of correct digits for the eigenvalues, we might have \
to subdivide the triangles. The function ",
  StyleBox["meshData", "MR"],
  " returns a list of the finite element vertices obtained after ",
  StyleBox["order", "TI"],
  " subdivisions of all triangles of bilby or hawk for a given finite element \
order ",
  StyleBox["femOrder", "TI"],
  ". The second argument ",
  StyleBox["DN", "TI"],
  " indicates the use of Dirichlet boundary conditions (",
  StyleBox["D", "MR"],
  ") or Neumann boundary conditions (",
  StyleBox["N", "MR"],
  "). For Dirichlet boundary conditions, all points at the boundary are \
eliminated because they have the value zero by definition and their values do \
not have to be calculated, and for Neumann boundary conditions all points are \
returned (Neumann boundary conditions are the most natural boundary boundary \
conditions for finite element discretizations). The numbered finite element \
vertices are returned in lists, each list containing the vertices of the \
triangle. Each vertex is specified in the form ",
  StyleBox["P[", "MR"],
  StyleBox["coordinates", "TI"],
  StyleBox[", {", "MR"],
  StyleBox["triangleNumber", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["vertexNumberInsideTriangle", "TI"],
  StyleBox["}, ", "MR"],
  StyleBox["globalvertexNumber", "TI"],
  StyleBox["]", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* map the point {x, y} into the triangle {p1, p2, p3} *)", 
    "CodeComment"],
  "\ntoTriangle[{p1_, p2_, p3_}, {x_, y_}] := p1 + (p2 - p1) x + (p3 - p1) y"
}], "Input"],

Cell[TextData[{
  "meshData[{bilbyHawk_, order_}, DN_, femOrder_] :=\nModule[{",
  StyleBox["(* the triangulated bilby and hawk *)", "CodeComment"],
  "\n        tm = triangleMesh[bilbyHawk][order], \[Lambda] = \
\[ScriptCapitalO][femOrder],\n        trianglePoints, \
relevantPointsInTriangles, numberedPoints, \n        vertexNumber}, \n ",
  StyleBox["(* points in the form {coordinate, {triangleNumber, \
pointNumber}};\n    grouped by triangles *) ", "CodeComment"],
  "\n trianglePoints = Table[Table[P[toTriangle[tm[[j]], \n                   \
             basePoints[femOrder][[k]]], {j, k}], \n                          \
    {k, \[Lambda]}], {j, Length[tm]}]; \n ",
  StyleBox["(* all shape functions base points in all triangles *)", 
    "CodeComment"],
  "\n relevantPointsInTriangles =\n",
  StyleBox[" (* keep only inner points for Dirichlet boundary conditions *)", 
    "CodeComment"],
  "\n If[DN === D, DeleteCases[trianglePoints, \n                          \
_?(edgePointQ[bilbyHawk][#[[1]]]&), {2}],\n    ",
  StyleBox["(* use all points for Neumann case *)", "CodeComment"],
  " trianglePoints];                       \n ",
  StyleBox["(* the numbered inner points, no multiplicity *)", 
    "CodeComment"],
  "\n numberedPoints = MapIndexed[{#2[[1]], #1}&, Union[First /@ \n           \
                  Flatten[relevantPointsInTriangles]]];\n ",
  StyleBox["(* constant-time look-up for vertex numbers *)", "CodeComment"],
  "\n (vertexNumber[#2] = #1)& @@@ numberedPoints;        \n Map[Append[#, \
vertexNumber[#[[1]]]]&, relevantPointsInTriangles, {2}]]"
}], "Input"],

Cell["\<\
Here are the numbered vertices for the simplest nontrivial case\
\[LongDash]the seventh order zero bilby triangles for Dirichlet boundary \
conditions with degree one basis functions. The triangles at the cusp \
vertices have no nontrivial vertices and appear as empty lists.\
\>", "Text"],

Cell["meshData[{bilby, 1}, D, 1]", "Input"],

Cell[TextData[{
  "Next, we have to assemble the global mass and stiffness matrices. For a \
given list of numbered finite element vertices ",
  StyleBox["numberedTrianglePoints", "TI"],
  ", and a given element mass or stiffness matrix ",
  StyleBox["massStiffnessMatrix", "TI"],
  ", the function ",
  StyleBox["globalMatrix", "MR"],
  " does most of this. Because the resulting global matrices are rather \
sparse in average, we will return the matrices as sparse arrays. If needed, \
the sparse array can easily converted to a dense one."
}], "Text"],

Cell[TextData[{
  "globalMatrix[numberedTrianglePoints_, massStiffnessMatrix_] :=\n\
Module[{dim, thePoints, \[ScriptCapitalT], j, m, a, n, b},\n",
  StyleBox["(* make definition for the inner points *)\n", "CodeComment"],
  " dim = Max[Last /@ Flatten[numberedTrianglePoints]];\n",
  StyleBox[" (* indices m, n for the triangles;\n    indices a, b for the \
global matrix *)\n (* all points of the mesh *)\n ", "CodeComment"],
  "thePoints = Flatten[numberedTrianglePoints];\n",
  StyleBox[" (* now loop over all points of the triangle mesh *) \n", 
    "CodeComment"],
  " \[ScriptCapitalT] = Table[{j, m} = thePoints[[i, 2]]; a = thePoints[[i, \
3]];\n           ",
  StyleBox["(* loop over all vertices from the same triangle *)", 
    "CodeComment"],
  "\n           Table[n = numberedTrianglePoints[[j, l, 2, 2]]; \n            \
     b = numberedTrianglePoints[[j, l, 3]]; \n                 {a, b} -> \
massStiffnessMatrix[[m, n]],\n                 {l, \
Length[numberedTrianglePoints[[j]]]}],\n          {i, 1, Length[thePoints]}]; \
                  \n ",
  StyleBox["(* return global matrix as a sparse array *)", "CodeComment"],
  "\n SparseArray[",
  StyleBox["(* sum entries belonging to same vertices *)", "CodeComment"],
  "\n             ((#[[1, 1]] -> (Plus @@ (Last /@ #)))& /@ \n                \
 Split[Sort[Flatten[\[ScriptCapitalT]]], #1[[1]] === #2[[1]]&])]]"
}], "Input"],

Cell["\<\
The next graphics show the nonzero elements of the resulting \
elements of the global mass matrix for the original triangles for finite \
element orders 2 to 6. We clearly see the overlapping square \
block\[Hyphen]type matrices from the individual elements,\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity}, 
Table[ListDensityPlot[1 - Sign[Abs[Normal[
      globalMatrix[meshData[{bilby, 0}, D, femOrder], 
                            MassMatrix[femOrder, {4, 1, 0, 1}]]]]],
             FrameTicks -> False, Mesh -> False], {femOrder, 2, 6}]]]]\
\>", \
"Input"],

Cell["\<\
Here are two matrices from higher order subdivision (three and \
four). The overall banded nature of the matrices is clearly visible.\
\>", \
"Text"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity}, 
Table[ListDensityPlot[1 - Sign[Abs[Normal[
      globalMatrix[meshData[{bilby, \[ScriptO]}, D, \[ScriptO]], 
                            MassMatrix[\[ScriptO], {2^(2 - \[ScriptO]), 1, 0, \
1}]]]]],
             FrameTicks -> False, Mesh -> False], {\[ScriptO], 3, \
4}]]]]\
\>", "Input"],

Cell[TextData[{
  "For further use, we calculate the mass and stiffness matrices ",
  StyleBox["\[ScriptCapitalM]", "MR"],
  " and ",
  StyleBox["\[ScriptCapitalS]", "MR"],
  " for various orders. For all the triangles and subdivision orders of our \
subdivisions of bilby and hawk, we have ",
  Cell[BoxData[
      FormBox[
        RowBox[{"A", "=", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"B", "=", "0"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"C", "=", "1"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* use values of J, A, B, and C corresponding to \n   uniform \
triangle subdivision implemented above *)", "CodeComment"],
  "\nDo[JABCRule = Dispatch[{J -> 2^(2 - order), A -> 1, B -> 0, C -> 1}];\n  \
 ",
  StyleBox["(* reuse already calculated mass and stiffness matrices *)", 
    "CodeComment"],
  "\n   \[ScriptCapitalM][femOrder][order_] = MassMatrix[femOrder, \n         \
                            {J, A, B, C}] //. JABCRule;\n    \
\[ScriptCapitalS][femOrder][order_] = StiffnessMatrix[femOrder, \n            \
                              {J, A, B, C}] //. JABCRule, \n   {femOrder, 1, \
12}]"
}], "Input"],

Cell["\<\
Here are some assembly timings, dimensions, and number of \
nonvanishing matrix elements for the resulting global matrices for various \
subdivision and finite element orders. The subdivision order 6, finite \
element order 6 global matrices are of dimensions 7849\[Times]7849. And a \
subdivision order 4, finite element order 12 global matrix is also of \
dimensions 7849\[Times]784, but has 818353 nonvanishing elements.\
\>", "Text"],

Cell["\<\
Table[{order, femOrder,
       Timing[{Dimensions[#][[1]], Length[ArrayRules[#]] - 1}& @   
       globalMatrix[meshData[{bilby, order}, D, femOrder], 
                    \[ScriptCapitalM][femOrder][order]]]},
      {order, 6}, {femOrder, 6}]\
\>", "Input"],

Cell[TextData[{
  "Now we are ready to test the isospectrality numerically. For a given \
subdivision order ",
  StyleBox["order", "TI"],
  " and a given finite element order ",
  StyleBox["femOrder", "TI"],
  ", we now construct the pair of global mass and stiffness matrices ",
  StyleBox["bilbyHawkFEMMatrices", "MR"],
  ". "
}], "Text"],

Cell["\<\
bilbyHawkFEMMatrices[{bilbyHawk_, order_}, DN_, femOrder_] :=
(globalMatrix[meshData[{bilbyHawk, order}, DN, femOrder], 
                               #[femOrder][order]]& /@ {\[ScriptCapitalS], \
\[ScriptCapitalM]})\
\>", "Input"],

Cell[TextData[{
  "We will use the Arnoldi method to calculate the eigenvalues (and the \
eigenvectors) to make efficient use of the sparse structure of the matrices \
and to deal with larger matrices. At this stage, we numericalize the global \
mass and stiffness matrices. The function ",
  StyleBox["bilbyHawkEigenvalues", "MR"],
  " calculates the eigenvalues. We allow for options ",
  StyleBox["opts", "TI"],
  " to extract higher eigenvalues conveniently."
}], "Text"],

Cell[TextData[{
  "bilbyHawkEigenvalues[{{bilbyHawk_, order_}, DN_, femOrder_}, \n            \
         n_, opts___] :=\nModule[{M, S},\n",
  StyleBox["(* global mass and stiffness matrix *)", "CodeComment"],
  "\n{S, M} = bilbyHawkFEMMatrices[{bilbyHawk, order}, DN, femOrder];\n",
  StyleBox["(* return eigenvalues in increasing order *)", "CodeComment"],
  "\nReverse @ Eigenvalues[N[{S, M}], n,\n                Method -> \
{\"Arnoldi\", opts, Tolerance -> 10^-8,\n                BasisSize -> \
Min[Abs[20 n], Dimensions[M]],\n                                  \
MaxIterations -> 10^5}]]"
}], "Input"],

Cell["\<\
We start with the original seven triangles of bilby and hawk and \
use a sixth order finite element approximation.\
\>", "Text"],

Cell["bilbyHawkEigenvalues[{{bilby, 0}, D, 6}, -6]", "Input"],

Cell["bilbyHawkEigenvalues[{{hawk, 0}, D, 6}, -6]", "Input"],

Cell["\<\
The first six eigenvalues agree quite well. Using the sixth \
subdivision and linear finite elements gives considerably worse results \
(although the matrix dimension is nearly twice as large). But the actual \
values of bilby and hawk eigenvalues agree perfectly with each other. The \
weak performance of low\[Hyphen]order finite elements for domains with \
reentrant corners is a well\[Hyphen]known weakness of the finite element \
method.\
\>", "Text"],

Cell["bilbyHawkEigenvalues[{{bilby, 6}, D, 1}, -6]", "Input"],

Cell["bilbyHawkEigenvalues[{{hawk, 6}, D, 1}, -6]", "Input"],

Cell[TextData[{
  "Because the finite element approximation is basically a variational \
solution, the resulting values bound the Dirichlet eigenvalues from above. We \
obtain a few correct digits of the eigenvalues by using higher order triangle \
subdivisions. In addition, we can extrapolate the sequence of eigenvalues ",
  "[",
  
  CounterBox["BibliographyCounter", "Goldman84"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Goldman84",
    ButtonStyle->"Hyperlink"],
  "]",
  ". The correct value of the first eigenvalue to ten digits is ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          RowBox[{"2.537949998", "\[Ellipsis]"}],
          ZeroWidthTimes->True], TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Driscoll97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll97",
    ButtonStyle->"Hyperlink"],
  "]. With just seven of the order twelve elements, we obtain the lowest \
eigenvalue accurate to more ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0.0001", "%"}], TraditionalForm]]],
  ". "
}], "Text"],

Cell["\<\
Table[bilbyHawkEigenvalues[{{bilby, 0}, D, fo}, -1][[1]], {fo, 2, \
12}]\
\>", "Input"],

Cell["\<\
Table[bilbyHawkEigenvalues[{{bilby, 1}, D, fo}, -1][[1]], {fo, 2, \
12}]\
\>", "Input"],

Cell["\<\
Table[bilbyHawkEigenvalues[{{bilby, 2}, D, fo}, -1][[1]], {fo, 2, \
12}]\
\>", "Input"],

Cell[TextData[{
  "Assuming that the eigenvalues ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  " obey a ",
  Cell[BoxData[
      FormBox[
        StyleBox["femOrder",
          "TI"], TraditionalForm]]],
  " dependence ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", "=", 
          RowBox[{
            SubscriptBox["\[Lambda]", "0"], "+", 
            RowBox[{
              UnderscriptBox["\[Sum]", "k"], 
              RowBox[{
                SubscriptBox["c", "k"], "  ", 
                SuperscriptBox[
                  StyleBox["femOrder",
                    "TI"], 
                  RowBox[{"-", "k"}]]}]}]}]}], TraditionalForm]]],
  ", we can refine our predicted value of the lowest eigenvalue. The \
resulting error is now less than 0.0001%."
}], "Text"],

Cell["\<\
Module[{\[Lambda]s = %, l = Length[%], eqs, sol, c, \[Lambda]0},
 eqs = Table[\[Lambda]0 + Sum[c[j] fo^-(j + 2), {j, l - 1}] == 
             Rationalize[\[Lambda]s[[k]], 0] /. fo -> k, {k, l}];
 sol = Solve[eqs, Join[{\[Lambda]0}, Table[c[j], {j, l - 1}]]];
 N[\[Lambda]0 /. sol[[1]]]]\
\>", "Input"],

Cell[TextData[{
  "Because bilby and hawk can be constructed from right angles isosceles \
triangles, there exist eigenfunctions that are finite linear combinations of \
products of sine functions and have nodes along coinciding triangle edges. \
The smallest such eigenvalue for bilby and hawk is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                SuperscriptBox["1", "2"], "+", 
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{"1", "+", "1"}], ")"}], "2"]}], ")"}], 
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{"\[Pi]", "/", "2"}], ")"}], "2"]}], "=", 
          RowBox[{
            RowBox[{"5", "/", "4"}], 
            SuperscriptBox["\[Pi]", "2"]}]}], TraditionalForm]]],
  ". Here we find the numerical eigenvalue nearest to this value and its \
relative error. "
}], "Text"],

Cell["\<\
{#, # - 5/4 Pi^2}&[
  bilbyHawkEigenvalues[{{bilby, 1}, D, 12}, 1, Shift -> 12.337][[1]]]\
\>", \
"Input"],

Cell[TextData[{
  "And here are the first few eigenvalues for Neumann boundary conditions. \
For the solution ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", 
            RowBox[{"x", ",", "y"}], ")"}], "=", 
          StyleBox["constant",
            FontSlant->"Italic"]}], TraditionalForm]]],
  ", we have a zero eigenvalue. Again, we see the isospectrality of the bilby \
and hawk."
}], "Text"],

Cell["bilbyHawkEigenvalues[{{bilby, 0}, N, 6}, -6]", "Input"],

Cell["bilbyHawkEigenvalues[{{hawk, 0}, N, 6}, -6]", "Input"],

Cell[TextData[{
  "For mixed boundary conditions (some of the edges have Dirichlet, and some \
of the edges have Neumann boundary conditions), see ",
  "[",
  
  CounterBox["BibliographyCounter", "Driscoll03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll03",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell[TextData[{
  "For visualizing the eigenmodes we need the eigenvectors. The next input \
defines the function ",
  StyleBox["bilbyHawkEigenvectors", "MR"],
  " in an analogous way to the function ",
  StyleBox["bilbyHawkEigenvalues", "MR"],
  ". Again, we use the Arnoldi method option in ",
  StyleBox["Eigenvectors", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "DownValues[bilbyHawkEigenvectors] = \n",
  StyleBox["(* reuse code from above *)", "CodeComment"],
  " DownValues[bilbyHawkEigenvalues] /. \n    {bilbyHawkEigenvalues -> \
bilbyHawkEigenvectors,\n     Eigenvalues -> Eigenvectors};"
}], "Input"],

Cell["\<\
We start with some 3D plots of the eigenmodes. To obtain good \
graphics for low subdivision orders of bilby and hawk, we define a triangle \
subdivision mask that will be applied to each triangle.\
\>", "Text"],

Cell[TextData[{
  "subdividedTriangleMask[o_] := subdividedTriangleMask[o] =\nModule[{sd, ts, \
allPoints, dp},\n       ",
  StyleBox["(* subdivide a triangle into four *)", "CodeComment"],
  "\n       sd[{p1_, p2_, p3_}] := \n       With[{p12 = (p1 + p2)/2, p23 = \
(p2 + p3)/2, p31 = (p3 + p1)/2},\n            {{p1, p12, p31}, {p12, p2, \
p23}, {p23, p3, p31}, \n             {p12, p23, p31}}];\n       ",
  StyleBox["(* iterate subdivision *) ", "CodeComment"],
  "     \n       ts = Nest[Flatten[sd /@ #, 1]&, {{{0, 0}, {1, 0}, {0, 1}}}, \
o];\n       ",
  StyleBox["(* all points of the subdivision *) ", "CodeComment"],
  "\n       allPoints = Union[Flatten[ts, 1]];\n       ",
  StyleBox["(* identify identical points in the subdivision *)", 
    "CodeComment"],
  "\n       dp = Dispatch[MapIndexed[(#1 -> #2[[1]])&, allPoints]];\n       \
",
  StyleBox["(* return list of relative point coordinates and triangles *)", 
    "CodeComment"],
  "\n       {allPoints,\n        Function[Evaluate[Map[Slot, Polygon /@ ts /. \
dp, {-1}]]]}]"
}], "Input"],

Cell[TextData[{
  "Now, we define the function ",
  StyleBox["eigenfunctionsGraphics3D", "MR"],
  " that generates a 3D plot of the eigenfunctions over bilby and hawk. The \
argument ",
  StyleBox["opp", "TI"],
  " denotes the order of the triangle subdivisions for visualizations and ",
  StyleBox["colorFunction", "TI"],
  " is a pure function that will be applied to assign a color to each \
triangle."
}], "Text"],

Cell[TextData[{
  "eigenfunctionsGraphics3D[{{bilbyHawk_, order_}, DN_, femOrder_}, \n        \
                 evec_, opp_, colorFunction_, opts___] :=\nModule[{",
  StyleBox["(* get triangles *)", "CodeComment"],
  "\n        tm = triangleMesh[bilbyHawk][order], \[Lambda] = \
numKnots[femOrder],\n        ",
  StyleBox["(* scale eigenvector *)", "CodeComment"],
  "\n        evecN = evec/Plus @@ evec, numberedTrianglePoints = \n           \
            meshData[{bilbyHawk, order}, DN, femOrder],\n        basePointsT, \
polygonFunction, polys, ST, STF}, \n ",
  StyleBox["(* form the approximate eigenfunctions within a triangle *)", 
    "CodeComment"],
  "\n Do[ST[j][{\[Xi]_, \[Eta]_}] = Join[toTriangle[tm[[j]], {\[Xi], \
\[Eta]}], {Plus @@ \n    ((evecN[[#[[3]]]]*\n      \
ShapeFunctionList[femOrder, {\[Xi], \[Eta]}][[#[[2, 2]]]])& /@ \n             \
                      numberedTrianglePoints[[j]])}],\n    {j, Length[tm]}];\n\
 STF = ST;                 \n ",
  StyleBox["(* refinement template *)", "CodeComment"],
  "\n {basePointsT, polygonFunction} = subdividedTriangleMask[opp];    \n ",
  StyleBox["(* construct polygons *)", "CodeComment"],
  "\n polys = Table[polygonFunction @@ (STF[j] /@ basePointsT), \n            \
   {j, Length[tm]}];      \n ",
  StyleBox["(* return Graphics3D object *)\n ", "CodeComment"],
  "{min, max} = {Min[evecN], Max[evecN]};\n ",
  StyleBox["(* scaled z-coordinate of polygons *)", "CodeComment"],
  "\n scaledZ[Polygon[l_]] := ((Plus @@ (Last /@ l)/4) - min)/(max - min);\n \
",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\n Graphics3D[{EdgeForm[], Map[{colorFunction[scaledZ[#]], #}&, polys, \
{2}],\n            {Thickness[0.008], GrayLevel[0], \n             \
Line[Append[#, 0]& /@ borderLine[bilbyHawk]]}}, \n            opts, PlotRange \
-> All, BoxRatios -> {1, 1, 0.33},\n            BoxStyle -> \
{Thickness[0.002], GrayLevel[0.5]}]] "
}], "Input"],

Cell["Here are some examples of the eigenfunctions.", "Text"],

Cell["\<\
evecsDBilby = bilbyHawkEigenvectors[{{bilby, 3}, D, 4}, -9];
evecsDHawk = bilbyHawkEigenvectors[{{hawk, 3}, D, 4}, -9];\
\>", "Input"],

Cell["\<\
Do[Show[GraphicsArray[
  eigenfunctionsGraphics3D[{{#1, 3}, D, 4}, #2[[j]], 3, 
                SurfaceColor[Hue[0.78 (1 - #)], 
                             Hue[0.78 # + 0.12], 2.2]&]& @@@
       {{bilby, evecsDBilby}, {hawk, evecsDHawk}}]], {j, 1, 9}];        \
\
\>", "Input"],

Cell[TextData[{
  "As already mentioned, the relatively poor performance of the \
low\[Hyphen]order finite element eigenvalues above can be traced back to the \
reentrant corners of bilby and hawk. There the gradient diverges. With a \
slight change of the function ",
  StyleBox["eigenfunctionsGraphics3D", "MR"],
  ", we can easily display the magnitudes of the gradient vectors over bilby \
and hawk. "
}], "Text"],

Cell[TextData[{
  "DownValues[eigenfunctionsGradGraphics3D] = \n\
DownValues[eigenfunctionsGraphics3D] /. \n\
HoldPattern[eigenfunctionsGraphics3D] :> eigenfunctionsGradGraphics3D /.\n",
  StyleBox["(* modify code *)", "CodeComment"],
  "\nHoldPattern[Module[{args__}, body_]] :> Module[{args, \[Xi]\[Eta]dx, \
\[Xi]\[Eta]dy}, body] /.\nHoldPattern[STF = ST] :>\n Do[",
  StyleBox["(* chain rule parts in derivative change from {x, y} \[Rule] {\
\[Xi], \[Eta]} *)", "CodeComment"],
  "\n   {\[Xi]\[Eta]dx, \[Xi]\[Eta]dy} = {D[#, x], D[#, y]}&[{\[Xi], \[Eta]} \
/. \n    Solve[{x, y} == toTriangle[tm[[j]], {\[Xi], \[Eta]}], {\[Xi], \
\[Eta]}][[1]]];\n    ",
  StyleBox["(* norm of gradient *)", "CodeComment"],
  "\n    STF[j][{\[Xi]_, \[Eta]_}] = Join[Most[ST[j][{\[Xi], \[Eta]}]], \n    \
     {Sqrt[#.#]&[{\[Xi]\[Eta]dx.#, \[Xi]\[Eta]dy.#}&[({D[#, \[Xi]], D[#, \
\[Eta]]}&[\n                     ST[j][{\[Xi], \[Eta]}][[-1]]])]]}], {j, \
Length[tm]}];       "
}], "Input"],

Cell["\<\
While the Lagrange element\[Hyphen]based calculations give a \
continuous solution, it is not continuously differentiable. As a result, the \
following gradient plots have discontinuities along the finite element \
boundaries. But the following graphics nevertheless clearly show the \
divergence of the gradient at the reentrant boundary vertices for the first \
three of the just\[Hyphen]visualized eigenfunctions.\
\>", "Text"],

Cell["\<\
Do[Show[GraphicsArray[
  eigenfunctionsGradGraphics3D[{{#1, 3}, D, 4}, #2[[j]], 3, 
                SurfaceColor[Hue[0.78 (1 - #)], 
                             Hue[0.78 # + 0.12], 2.2]&]& @@@
       {{bilby, evecsDBilby}, {hawk, evecsDHawk}}]], {j, 1, 3}];        \
\
\>", "Input"],

Cell["\<\
And here are the corresponding eight lowest nontrivial \
eigenfunctions eigenfunctions for the Neumann case (the lowest eigenfunction \
is just a constant).\
\>", "Text"],

Cell["\<\
evecsNBilby = bilbyHawkEigenvectors[{{bilby, 3}, N, 4}, -9];
evecsNHawk = bilbyHawkEigenvectors[{{hawk, 3}, N, 4}, -9];\
\>", "Input"],

Cell["\<\
Do[Show[GraphicsArray[
  eigenfunctionsGraphics3D[{{#1, 3}, N, 4}, #2[[j]], 3, 
                SurfaceColor[Hue[0.78 (1 - #)], 
                             Hue[0.78 # + 0.12], 2.2]&]& @@@
       {{bilby, evecsNBilby}, {hawk, evecsNHawk}}]], {j, 2, 9}];        \
\
\>", "Input"],

Cell[TextData[{
  "Contour plots are a better way to visualize higher states. The complicated \
pattern of minima and maxima is visible at once, without some of the minima \
and maxima covered by others. To make a contour plot inside the bilby and \
hawk polygons, we cannot use ",
  StyleBox["ListContourPlot", "MR"],
  " directly because it expects a rectangular array of data. While the points \
of the triangle subdivisions and the finite element base points lie on a \
Cartesian tensor product grid, they do not fill a rectangle. We could either \
supplement with function values zero or make individual contour plots in each \
(subdivided) triangle. First, we will follow the last possibility. "
}], "Text"],

Cell[TextData[{
  StyleBox["(* function to insert points along the edges of a polygon *)", 
    "CodeComment"],
  "\ninsertAdditionalPoints[Polygon[l_], \[CurlyEpsilon]_] := \n  Module[{n, \
\[Lambda]}, Polygon[Join @@ (Function[s, \n               ",
  StyleBox["(* segment small enough? *)", "CodeComment"],
  "\n               If[(\[Lambda] = Sqrt[#. #]&[Subtract @@ s]) <= \
\[CurlyEpsilon], s, \n         ",
  StyleBox["(* insert more points *)", "CodeComment"],
  "\n         n = Floor[\[Lambda]/\[CurlyEpsilon]] + 1; ",
  StyleBox["(* form segments *)", "CodeComment"],
  "\n         Table[# + i/n (#2 - #1), {i, 0, n - 1}]& @@ s]] /@ \n           \
        Partition[Append[l, First[l]], 2, 1])]]"
}], "Input"],

Cell[TextData[{
  "eigenfunctionsContourGraphics[{{bilbyHawk_, order_}, DN_, femOrder_}, \n   \
                            evec_, pp_, zeroContourQ_] :=\nModule[{tm = \
triangleMesh[bilbyHawk][order], \[Lambda] = numKnots[femOrder],\n        \
evecN = evec/Plus @@ evec, numberedTrianglePoints = \n                        \
 meshData[{bilbyHawk, order}, DN, femOrder],\n       mp = {1/3, 1/3}, \
\[CurlyEpsilon] = 10^-12, \[ScriptC], ST, SF}, \n{min, max} = {Min[evecN], \
Max[evecN]};        \nevecN1 = (evecN - Min[evecN])/(Max[evecN] - \
Min[evecN]);      \n",
  StyleBox["(* form the approximate eigenfunctions within a triangle;\n   \
compile for speed *)", "CodeComment"],
  " \nDo[ST[j] = Compile[{\[Xi], \[Eta]}, Evaluate[Plus @@ ((evecN[[#[[3]]]]*\
\n         ShapeFunctionList[femOrder, {\[Xi], \[Eta]}][[#[[2, 2]]]])& /@ \n  \
                                 numberedTrianglePoints[[j]])]],\n   {j, \
Length[tm]}];\n",
  StyleBox["(* make contour plots within each triangle *)", "CodeComment"],
  "\ncps = Table[",
  StyleBox["(* parametrize triangle with rectangular domain *)", 
    "CodeComment"],
  "\n            tab = Table[If[\[Xi] === 1, Table[ST[j][1, 0], {pp + 1}],\n  \
                      Table[ST[j][\[Xi], \[Eta]], {\[Eta], 0, 1 - \[Xi], (1 - \
\[Xi])/pp}]], \n                        {\[Xi], 0, 1, 1/pp}];\n            ",
  StyleBox["(* options for the two ListContourPlot calls *)\n            ", 
    "CodeComment"],
  "copts =  Sequence[MeshRange -> {{0, 1}, {0, 1}}, \n                \
PlotRange -> {min, max}, ColorFunctionScaling -> False,\n                \
ContourSmoothing -> True, DisplayFunction -> Identity];\n             ",
  StyleBox["(* make contour plot; use some absolute coloring function *)", 
    "CodeComment"],
  "\n            cp = ListContourPlot[Transpose[tab], copts, \n               \
  Contours -> 50, ContourLines -> False, \n                 ColorFunction -> \
(GrayLevel[(max - #)/(max - min)]&)];\n             ",
  StyleBox["(* make contour plot of zero0value curve *)", "CodeComment"],
  "\n            cpZeroLines = If[zeroContourQ, \n            \
ListContourPlot[Transpose[tab], copts, Contours -> {0}, \n                 \
ContourLines -> True, ContourShading -> False,\n                 ContourStyle \
-> {{Thickness[0.004], RGBColor[0, 0, 1]}}], {}];    \n            ",
  StyleBox["(* make Graphics object *)", "CodeComment"],
  "\n            gr = Show[Graphics /@ {cp, cpZeroLines}]; \n            gr1 \
= gr /. p_Polygon  :> \n                        ",
  StyleBox["(* insert points along edges *)", "CodeComment"],
  "\n                        insertAdditionalPoints[p, 2^-order/12];    \n    \
        ",
  StyleBox["(* map to triangle; expand upper polygons *)", "CodeComment"],
  "\n            cM = Count[gr, _Polygon, Infinity];            \n            \
\[Xi]\[Eta][{\[Xi]_, \[Eta]_}] := {\[Xi], \[Eta] (1 - \[Xi])};\n            \
xy[{\[Xi]_, \[Eta]_}] = toTriangle[tm[[j]], {\[Xi], \[Eta]}];\n            \
expandT[{\[Xi]_, \[Eta]_}] := mp + (1 + (\[ScriptC]++) \[CurlyEpsilon]) ({\
\[Xi], \[Eta]} - mp);\n            gr1 /. Polygon[l_] :> \n                   \
(\[ScriptC] = 0; Polygon[xy /@ expandT /@ \[Xi]\[Eta] /@ l]) /.\n             \
      Line[l_] :> Line[xy /@ \[Xi]\[Eta] /@ l],\n          {j, Length[tm]}];  \
 \n ",
  StyleBox["(* the border *)", "CodeComment"],
  "\n borderGraphics = Graphics[{Hue[0], Thickness[0.008], \n                 \
           Line[borderLine[bilbyHawk]]}];               \n ",
  StyleBox["(* form one Graphics object from all contour plots *)", 
    "CodeComment"],
  "\n Show[Append[cps, borderGraphics],\n      PlotRange -> All, Frame -> \
False, AspectRatio -> Automatic] /.  \n                            \
(DisplayFunction -> Identity) -> \n                            \
(DisplayFunction -> $DisplayFunction)] "
}], "Input"],

Cell["\<\
Here are the contour plot equivalents of the above 3D plots for \
bilby.\
\>", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Partition[
  Block[{$DisplayFunction = Identity}, 
  eigenfunctionsContourGraphics[{{bilby, 3}, D, 4}, #, 4, False]& /@
                                          Take[evecsDBilby, 6]], 3]\
\>", \
"Input"],

Cell[TextData[{
  "The zeroth Neumann eigenfunction is constant and the contour plot shows \
just the numerical uncertainties. Now, we also show the nodal lines ",
  "[",
  
  CounterBox["BibliographyCounter", "Gladwell02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Gladwell02",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Partition[
  Block[{$DisplayFunction = Identity}, 
  eigenfunctionsContourGraphics[{{bilby, 3}, D, 4}, #, 4, True]& /@
                                    Take[evecsDBilby, {2, 7}]], 3]\
\>", \
"Input"],

Cell[TextData[{
  "For applying methods more adapted to the reentrant corners of bilby and \
hawk to calculate their eigensystems, see [",
  
  CounterBox["BibliographyCounter", "Driscoll97"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Driscoll97",
    ButtonStyle->"Hyperlink"],
  "]; for experimental data about their eigensystems, see [",
  
  CounterBox["BibliographyCounter", "Sridhar94"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sridhar94",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "For higher states, it is faster and more convenient to use one call to ",
  StyleBox["ListContourPlot", "MR"],
  ". For even orders of the triangle subdivision, all triangle vertices lie \
on a Cartesian ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  " tensor product grid (for odd orders, rotating bilby and hawk by ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "4"}], TraditionalForm]]],
  " will make the vertices lie on such a grid). We start by creating a square \
matrix with the function values to be used in ",
  StyleBox["ListContourPlot", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "eigenfunctionsMat[{{bilbyHawk_, order_}, DN_, femOrder_}, evec_, pp_] :=\n\
Module[{tm = triangleMesh[bilbyHawk][order], \[Lambda] = numKnots[femOrder],\n\
        evecN = evec/Plus @@ evec, numberedTrianglePoints = \n                \
         meshData[{bilbyHawk, order}, DN, femOrder],\n       ST, toInteger, \
toIntegerCoordinates, lcpM, \[Delta] = 2/2^(order/2)/pp}, \n",
  StyleBox["(* form the approximate eigenfunctions within a triangle;\n   \
compile for speed *)", "CodeComment"],
  " \nDo[ST[j] = Compile[{\[Xi], \[Eta]}, Evaluate[Plus @@ ((evecN[[#[[3]]]]*\
\n         ShapeFunctionList[femOrder, {\[Xi], \[Eta]}][[#[[2, 2]]]])& /@ \n  \
                                 numberedTrianglePoints[[j]])]],\n   {j, \
Length[tm]}];\n",
  StyleBox["(* physical coordinates to grid numberings *)", "CodeComment"],
  "\ntoIntegerCoordinates[{x_, y_}] := ({x, y} + 3)/\[Delta] + 1;\n",
  StyleBox["(* empty matrix *)", "CodeComment"],
  "\nlcpM = Table[0, {6/\[Delta] + 1}, {6/\[Delta] + 1}]; \n",
  StyleBox["(* fill in matrix *)", "CodeComment"],
  "\nDo[",
  StyleBox["(* go through all triangles *)", "CodeComment"],
  "\n   Do[",
  StyleBox["(* ", "CodeComment"],
  StyleBox["pp (1 + pp)", "CodeComment"],
  StyleBox[" points inside each triangle *)", "CodeComment"],
  "\n      {a, b} = toIntegerCoordinates[toTriangle[tm[[j]], {\[Xi], \
\[Eta]}]];\n      lcpM[[a, b]] = ST[j][\[Xi], \[Eta]], {\[Xi], 0, 1, 1/pp}, {\
\[Eta], 0, 1 - \[Xi], 1/pp}],\n      {j, Length[tm]}]; lcpM]"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["eigenfunctionsContourGraphicsHolistic", "MR"],
  " takes the matrix returned by ",
  StyleBox["eigenfunctionsMat", "MR"],
  " and generates a contour plot of the eigenfunctions of bilby and hawk. We \
cover the parts of the matrix that represent points outside of bilby or hawk \
with the white polygons ",
  StyleBox["outerCoverPolygon", "MR"],
  "."
}], "Text"],

Cell["\<\
{outerCoverPolygon[bilby], outerCoverPolygon[hawk]} = Polygon /@ 
 {{{3, 1}, {-1, 1}, {-1, 3}, {-3, 1}, {-1, -1}, {1, -1}, {1, -3}, {3, -1}, 
   {3, -3}, {-3, -3}, {-3, 3}, {3, 3}}, {{-1, 3}, {-1, 1}, {1, 1}, {3, -1}, 
   {1, -1}, {1, -3}, {-3, 1}, {-3, -3}, {3, -3}, {3, 3}, {-1, 3}}};\
\>", \
"Input"],

Cell[TextData[{
  "eigenfunctionsContourGraphicsHolistic[{{bilbyHawk_, order_}, DN_, \
femOrder_}, \n                                      {evec_, F_}, pp_] :=\n\
Module[{M0, lcp, coverGraphics, borderGraphics}, \n ",
  StyleBox["(* matrix with elongation values *)", "CodeComment"],
  "\n M0 = eigenfunctionsMat[{{bilbyHawk, order}, DN, femOrder}, evec, pp];\n \
",
  StyleBox["(* make contour plot *)", "CodeComment"],
  "\n lcp = ListContourPlot[Map[F, Transpose[M0], {2}], \n                  \
PlotRange -> All, DisplayFunction -> Identity,\n                  MeshRange \
-> {{-3, 3}, {-3, 3}}, ContourLines -> False,\n                  Contours -> \
36];  \n ",
  StyleBox["(* cover the outside with white polygons *)", "CodeComment"],
  "\n coverGraphics = Graphics[{GrayLevel[1], outerCoverPolygon[bilbyHawk]}];\
\n borderGraphics = Graphics[{Hue[0], Thickness[0.008], \n                    \
        Line[borderLine[bilbyHawk]]}];       \n ",
  StyleBox["(* make resulting graphic *)", "CodeComment"],
  "\n Show[{lcp, coverGraphics, borderGraphics},\n      DisplayFunction -> \
$DisplayFunction, Frame -> False]]"
}], "Input"],

Cell["\<\
Here are some of the higher states for the Dirichlet case shown. \
This time, we show the fourth root of the absolute value of the amplitudes to \
mimick the appearance of the sand in Chladny figures. The second pair of \
graphics shows again a state that can be written as a product of sine \
functions inside each of the seven order zero triangles.\
\>", "Text"],

Cell["\<\
evecsDBilby = bilbyHawkEigenvectors[{{bilby, 4}, D, 10}, 8, Shift \
-> 101];
evecsDHawk  = bilbyHawkEigenvectors[{{hawk,  4}, D, 10}, 8, Shift -> \
101];\
\>", "Input"],

Cell["\<\
Do[Show[GraphicsArray[
     Block[{$DisplayFunction = Identity}, 
     eigenfunctionsContourGraphicsHolistic[{{#1, 4}, D, 10}, 
                                {#2[[j]], Abs[#]^(1/4)&}, 12]& @@@
                             {{bilby, evecsDBilby}, {hawk, evecsDHawk}}]]],
   {j, 8}];\
\>", "Input"],

Cell["We end with the corresponding graphics for the Neumann case.", "Text"],

Cell["\<\
evecsNBilby = bilbyHawkEigenvectors[{{bilby, 4}, N, 10}, 8, Shift \
-> 101];
evecsNHawk  = bilbyHawkEigenvectors[{{hawk,  4}, N, 10}, 8, Shift -> \
101];\
\>", "Input"],

Cell["\<\
Do[Show[GraphicsArray[
     Block[{$DisplayFunction = Identity}, 
     eigenfunctionsContourGraphicsHolistic[{{#1, 4}, N, 10}, 
                                {#2[[j]], Abs[#]^(1/4)&}, 12]& @@@
                             {{bilby, evecsNBilby}, {hawk, evecsNHawk}}]]],
   {j, 8}];\
\>", "Input"],

Cell[TextData[{
  "After dealing with the inside of these two isospectral drums, one could \
continue and investigate the Helmholtz (scattering) problem for the outside. \
See [",
  
  CounterBox["BibliographyCounter", "Okada03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Okada03",
    ButtonStyle->"Hyperlink"],
  "] for some initial results."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "12.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"z", "/", "z"}], "\[TildeTilde]", "1"}], TraditionalForm]]]
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the quotient ",
  Cell[BoxData[
      FormBox[
        RowBox[{"q", "=", 
          RowBox[{
            SubscriptBox["z", "1"], "/", 
            SubscriptBox["z", "2"]}]}], TraditionalForm]]],
  ", where the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", "2"], TraditionalForm]]],
  " are random complex numbers chosen with uniform probability from the \
square ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"1", "+", "i"}], ",", 
            RowBox[{"2", "+", "i"}], ",", 
            RowBox[{"2", "+", 
              RowBox[{"2", "i"}]}], ",", 
            RowBox[{"1", "+", 
              RowBox[{"2", "i"}]}]}], "}"}], TraditionalForm]]],
  " in the complex plane. Calculate the probability distribution function ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", 
          RowBox[{
            RowBox[{"Re", "(", "q", ")"}], ",", 
            RowBox[{"Im", "(", "q", ")"}]}], ")"}], TraditionalForm]]],
  " analytically."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by expressing the real and imaginary parts of the quotient ",
  Cell[BoxData[
      FormBox[
        RowBox[{"q", "=", 
          RowBox[{
            SubscriptBox["q", "r"], "+", 
            RowBox[{"i", " ", 
              SubscriptBox["q", "i"]}]}]}], TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["z", "j"], "=", 
          RowBox[{
            SubscriptBox["x", "j"], "+", 
            RowBox[{"i", " ", 
              SubscriptBox["y", "j"]}]}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"j", "=", "1"}], ",", "2"}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
{qRe, qIm} = 
Simplify[ComplexExpand[#[(x1 + I y1)/(x2 + I y2)], 
                    TargetFunctions -> {Re, Im}]]& /@ {Re, Im}\
\>", "Input"],

Cell[TextData[{
  "It is straightforward to calculate exact expressions for the averages of \
the real and imaginary parts of ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ". Intuitively one would expect the average value of ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " to be approximately 1. This is the case to a remarkable precision."
}], "Text"],

Cell["\<\
{qrAv, qiAv} = 
(Integrate[#, {y2, 1, 2}, {x2, 1, 2}, {y1, 1, 2}, {x1, 1, 2},
           GenerateConditions -> False] // 
           TrigToExp // FullSimplify)& /@ {qRe, qIm}\
\>", "Input"],

Cell["N[%]", "Input"],

Cell["\<\
It is also possible to calculate exactly the variances for the real \
and imaginary parts. This time, we obtain considerably more complicated \
expressions containing polylogarithmic functions. From the numerical values \
of the variances, we expect a half width of about 0.2 for the real and the \
imaginary part.\
\>", "Text"],

Cell[TextData[{
  "(FullSimplify[Integrate[FullSimplify[\n ",
  StyleBox["(* split off last integration and simplify before *)", 
    "CodeComment"],
  "\n Integrate[#, {x2, 1, 2}, {y1, 1, 2}, {x1, 1, 2},\n           \
GenerateConditions -> False]], {y2, 1, 2}] /. \n            xA -> qrAv]& /@ \
(({qRe, qIm} - {qrAv, qiAv})^2)) //\n                     ",
  StyleBox["(* for a shorter result *)", "CodeComment"],
  " TraditionalForm"
}], "Input"],

Cell["N[Sqrt[%], 22]  // N", "Input"],

Cell[TextData[{
  "Using quantifier elimination it is also easily possible to calculate \
bounds for the range of nonvanishing values for the quotient ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ". We find ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"1", "/", "2"}], "\[LessEqual]", 
          RowBox[{"Re", "(", "q", ")"}], "\[LessEqual]", "2"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"1", "-", "\[CurlyPhi]"}], "\[LessEqual]", 
          RowBox[{"Im", "(", "q", ")"}], "\[LessEqual]", 
          RowBox[{"\[CurlyPhi]", "-", "1"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Function[reim, Function[lg, 
Exists[{x1, y1, x2, y2}, 
      Element[{x1, y1, x2, y2, q}, Reals] && 
              1 < x1 < 2 && 1 < y1 < 2 &&
              1 < x2 < 2 && 1 < y2 < 2, lg[q, reim]] // 
               Resolve] /@ {Less, Greater}] /@ {qRe, qIm}\
\>", "Input"],

Cell[TextData[{
  "Next, we carry out a numerical simulation that uses ten million pairs of \
random numbers. We use the compiled function ",
  StyleBox["qCF", "MR"],
  " for carry simulation."
}], "Text"],

Cell[TextData[{
  "qCF = Compile[{{n, _Integer}, {pp, _Integer}},\n        Module[{m = \
Table[0, {pp + 1}, {pp + 1}], q, qr, qi, \n                i, j, q0 = {0, \
-1}, \[Lambda]q = {2, 2}, norm}, \n            Do[",
  StyleBox["(* form the quotient of the two random numbers *)", 
    "CodeComment"],
  "\n               q = Random[Complex, {1 + I, 2 + 2 I}]/ \n                 \
  Random[Complex, {1 + I, 2 + 2 I}];\n               {qr, qi} = {Re[q], \
Im[q]}; \n               ",
  StyleBox["(* discretize and count *)", "CodeComment"],
  "\n               {j, i} = Round[({qr, qi} - q0)/\[Lambda]q pp] + 1;\n      \
         m[[i, j]] = m[[i, j]] + 1, {n}]; \n               norm = Plus @@ \
Flatten[Sign[m]];\n               ",
  StyleBox["(* return normalized result *)", "CodeComment"],
  "\n               m/n norm]];"
}], "Input"],

Cell["\<\
The following graphic of the modelled probability distribution \
agrees quantitatively with the above\[Hyphen]calculated parameters.\
\>", \
"Text"],

Cell["\<\
ListPlot3D[qCF[10^7, 60], PlotRange -> All,
           MeshRange -> {{0, 5/2}, {-1, 1}}, Mesh -> False]\
\>", "Input"],

Cell["\<\
Now, we calculate the exact probability distribution function. The \
bivariate distribution is given as the following four\[Hyphen]fold \
integral:\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"p", "(", 
          RowBox[{
            SubscriptBox["q", "r"], ",", 
            SubscriptBox["q", "i"]}], ")"}], "=", 
        RowBox[{
          UnderoverscriptBox["\[Integral]", "1", "2"], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "1", "2"], 
            RowBox[{
              UnderoverscriptBox["\[Integral]", "1", "2"], 
              RowBox[{
                UnderoverscriptBox["\[Integral]", "1", "2"], 
                RowBox[{
                  RowBox[{"\[Delta]", "(", 
                    RowBox[{
                      SubscriptBox["q", "r"], "-", 
                      FractionBox[
                        RowBox[{
                          RowBox[{
                            SubscriptBox["x", "1"], " ", 
                            SubscriptBox["x", "2"]}], "+", 
                          RowBox[{
                            SubscriptBox["y", "1"], " ", 
                            SubscriptBox["y", "2"]}]}], 
                        RowBox[{
                          SubsuperscriptBox["x", "2", "2"], "+", 
                          SubsuperscriptBox["y", "2", "2"]}]]}], ")"}], 
                  RowBox[{"\[Delta]", "(", 
                    RowBox[{
                      SubscriptBox["q", "i"], "-", 
                      FractionBox[
                        RowBox[{
                          RowBox[{
                            SubscriptBox["x", "2"], " ", 
                            SubscriptBox["y", "1"]}], "-", 
                          RowBox[{
                            SubscriptBox["x", "1"], " ", 
                            SubscriptBox["y", "2"]}]}], 
                        RowBox[{
                          SubsuperscriptBox["x", "2", "2"], "+", 
                          SubsuperscriptBox["y", "2", "2"]}]]}], ")"}], "d", 
                  "\[InvisibleSpace]", 
                  SubscriptBox["x", "1"], "d", "\[InvisibleSpace]", 
                  SubscriptBox["y", "1"], "d", "\[InvisibleSpace]", 
                  SubscriptBox["x", "2"], "d", "\[InvisibleSpace]", 
                  RowBox[{
                    SubscriptBox["y", "2"], "."}]}]}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Using the well known integration rules for the Dirac delta function, it is \
straightforward to carry out the integration over ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["y", "1"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* carry out integration over x1 *)", "CodeComment"],
  "\nsolx1 = x1 /.  Solve[qr - qRe == 0, x1][[1]];\nfd1 = -D[qr - qRe, x1];\n\
int1 = 1/fd1 UnitStep[solx1 - 1] UnitStep[2 - solx1];\n",
  StyleBox["(* carry out integration over y1; independent factor *)", 
    "CodeComment"],
  "\nqiP = (qi - qIm /. x1 -> solx1);\nsoly1 = y1 /. Solve[qiP == 0, y1][[1]] \
;\nfd2 = -D[qiP, y1];\nint2 = 1/fd2 UnitStep[soly1 - 1] UnitStep[2 - soly1] \
// Simplify;\n",
  StyleBox["(* unite results *)", "CodeComment"],
  "\nint3 = (int1 /. y1 -> soly1) int2 // Simplify"
}], "Input"],

Cell["This leaves us with the following double integral:", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"p", "(", 
          RowBox[{
            SubscriptBox["q", "r"], ",", 
            SubscriptBox["q", "i"]}], ")"}], "=", 
        RowBox[{
          UnderoverscriptBox["\[Integral]", "1", "2"], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "1", "2"], 
            RowBox[{
              RowBox[{"(", 
                RowBox[{
                  SubsuperscriptBox["x", "2", "2"], "+", 
                  SubsuperscriptBox["y", "2", "2"]}], ")"}], " ", 
              RowBox[{
                InterpretationBox["\[Theta]",
                  UnitStep,
                  Editable->False,
                  Selectable->False], "(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox["q", "r"], 
                    SubscriptBox["x", "2"]}], "-", 
                  RowBox[{
                    SubscriptBox["q", "i"], " ", 
                    SubscriptBox["y", "2"]}], "-", "1"}], ")"}], " ", 
              RowBox[{
                InterpretationBox["\[Theta]",
                  UnitStep,
                  Editable->False,
                  Selectable->False], "(", 
                RowBox[{"2", "-", 
                  RowBox[{
                    SubscriptBox["q", "r"], " ", 
                    SubscriptBox["x", "2"]}], "+", 
                  RowBox[{
                    SubscriptBox["q", "i"], " ", 
                    SubscriptBox["y", "2"]}]}], ")"}], " ", 
              RowBox[{
                InterpretationBox["\[Theta]",
                  UnitStep,
                  Editable->False,
                  Selectable->False], "(", 
                RowBox[{"2", "-", 
                  RowBox[{
                    SubscriptBox["q", "i"], 
                    SubscriptBox["x", "2"]}], "-", 
                  RowBox[{
                    SubscriptBox["q", "r"], 
                    SubscriptBox["y", "2"]}]}], ")"}], " ", 
              RowBox[{
                InterpretationBox["\[Theta]",
                  UnitStep,
                  Editable->False,
                  Selectable->False], "(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox["q", "i"], 
                    SubscriptBox["x", "2"]}], "+", 
                  RowBox[{
                    SubscriptBox["q", "r"], " ", 
                    SubscriptBox["y", "2"]}], "-", "1"}], ")"}], "d", 
              "\[InvisibleSpace]", 
              SubscriptBox["x", "2"], "d", "\[InvisibleSpace]", 
              RowBox[{
                SubscriptBox["y", "2"], "."}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "We subdivide the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          FormBox[
            SubscriptBox["x", "2"],
            "TraditionalForm"], ",", 
          SubscriptBox["y", "2"]}], TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox[
        SubscriptBox["q", "r"], TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox[
        SubscriptBox["q", "i"], TraditionalForm]]],
  "\[Hyphen]space into cells using cylindrical algebraic decomposition. \
Because we are interested only in cells of finite 4D Lebesgue measure, we use \
the function ",
  StyleBox["Experimental`GenericCylindricalAlgebraicDecomposition", "MR"],
  ". This function ignores boundaries having a vanishing 4D Lebesgue measure. \
Inside each cell, all four arguments of the Heaviside functions will have \
arguments of definite signs. This will allow to ignore the Heaviside theta \
function for process of integration."
}], "Text"],

Cell["\<\
dC[{x2_, y2_}, {qr_, qi_}] := 
   -1 + qr x2 - qi y2 > 0 &&  2 - qr x2 + qi y2 > 0 &&
    2 - qi x2 - qr y2 > 0 && -1 + qi x2 + qr y2 > 0 &&
\t1 < x2 < 2 && 1 < y2 < 2\
\>", "Input"],

Cell[TextData[{
  "cad = ((Experimental`GenericCylindricalAlgebraicDecomposition[\n           \
         dC[{x2, y2}, {qr, qi}], {qr, qi, x2, y2}][[1]] /. \n                 \
   ",
  StyleBox["(* expand all cells to use explicit description *)", 
    "CodeComment"],
  "\n                       Inequality -> inequality) // LogicalExpand) /. \n \
                                           inequality -> Inequality;\n\
Length[cad]                   "
}], "Input"],

Cell["\<\
We obtained 229 cells. Here are the parametrizations for the first \
two cells.\
\>", "Text"],

Cell["Take[cad, 2]", "Input"],

Cell[TextData[{
  "Now it is straightforward to carry out the remaining two integrations over \
",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "2"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["y", "2"], TraditionalForm]]],
  ". The function ",
  StyleBox["doThex2y2Integration", "MR"],
  " integrates ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["x", "2", "2"], "+", 
          SubsuperscriptBox["y", "2", "2"]}], TraditionalForm]]],
  " over each cell and adds Heaviside functions to restrict the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["q", "r"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["q", "i"], TraditionalForm]]],
  " values appropriately."
}], "Text"],

Cell[TextData[{
  "doThex2y2Integration[a_And] := \nModule[{ix2, iy2, iqr, iqi, sInt1, \
dsInt1, sInt2, dsInt2, res},\n ",
  StyleBox["(* the variable ranges *)", "CodeComment"],
  "\n {ix2, iy2, iqr, iqi} = Cases[a, HoldPattern[\n            Inequality[_, \
_, #, _, _]]][[1]]& /@ {x2, y2, qr, qi};\n ",
  StyleBox["(* carry out the x3=2 and y2 integration *)", "CodeComment"],
  "\n sInt1 = Integrate[x2^2 + y2^2, y2];\n dsInt1 = (sInt1 /. y2 -> \
iy2[[-1]]) - (sInt1 /. y2 -> iy2[[+1]]);\n sInt2 = Integrate[dsInt1, x2];\n \
dsInt2 = (sInt2 /. x2 -> ix2[[-1]]) - (sInt2 /. x2 -> ix2[[+1]]);\n ",
  StyleBox["(* canonicalize result *)", "CodeComment"],
  "\n res = Factor //@ Together[dsInt2];\n If[(iqr && iqi), Evaluate @ res, \
0]]"
}], "Input"],

Cell["Here is the result for the first cell.", "Text"],

Cell["doThex2y2Integration[cad[[1]]]", "Input"],

Cell["\<\
It is now a matter to seconds to obtain a closed\[Hyphen]form \
expression for the distribution function.\
\>", "Text"],

Cell["\<\
q\[ScriptCapitalP][qr_, qi_] = Plus @@ (doThex2y2Integration /@ \
cad);\
\>", "Input"],

Cell["\<\
q\[ScriptCapitalP][qr_, qi_] = Plus @@
(Function[p, If @@ {p[[1, 1]], Together[Plus @@ (#[[2]]& /@ p)], 0}] /@ 
    Split[List @@ (doThex2y2Integration /@ cad), (#1[[1]] === \
#2[[1]])&]);\
\>", "Input"],

Cell["\<\
Piecewise the distribution function is a rational function. \
Overall, we obtain 45 different rational functions.\
\>", "Text"],

Cell["\<\
\[ScriptP]s = Union[(List @@ q\[ScriptCapitalP][qr, qi]) /. If[_, \
i_, _] :> i];
\[ScriptP]s // Length\
\>", "Input"],

Cell["Here are three of them.", "Text"],

Cell["Take[\[ScriptP]s, 3]", "Input"],

Cell["\<\
Some of the rational function are quite complicated\[LongDash]they \
are quotients of two total degree 15 polynomials.\
\>", "Text"],

Cell["\<\
{First[#], Length[#]}& /@ Split[Sort[
   Exponent[({Numerator[#], Denominator[#]}& /@ \[ScriptP]s) /. 
                              {qr -> C, qi -> C}, C]]]\
\>", "Input"],

Cell[TextData[{
  "The global maximum of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", 
          RowBox[{
            SubscriptBox["q", "r"], ",", 
            SubscriptBox["q", "i"]}], ")"}], TraditionalForm]]],
  " is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"p", "(", 
            RowBox[{"1", ",", "0"}], ")"}], "=", 
          RowBox[{"14", "/", "3"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
To visualize the various rational functions, we number each of the \
45 rational functions.\
\>", "Text"],

Cell[TextData[{
  "q\[ScriptCapitalP]C[qr_, qi_] = Evaluate //@ (q\[ScriptCapitalP][qr, qi] \
/. If[cond_, int_, 0] -> \n                   If[cond, {int, Position[\
\[ScriptP]s, int][[1, 1]]}, {0, 0}]);\n                   \n",
  StyleBox["(* unite If's with identical first condition *) ", 
    "CodeComment"],
  "                  \nq\[ScriptCapitalP]C[qr_, qi_] = \
q\[ScriptCapitalP]C[qr, qi] //. \n    If[Inequality[qrl_, Less, qr, Less, \
qru_] && qip1_, r1__] +\n    If[Inequality[qrl_, Less, qr, Less, qru_] && \
qip2_, r2__] :>\n    If[Inequality[qrl,  Less, qr, Less, qru], \n       \
If[qip1, r1] + If[qip2, r2], {0, 0}];"
}], "Input"],

Cell["\<\
By continuity, we could now continue the distribution functions to \
the boundaries. For a visualization, it is sufficient to avoid hitting the \
boundaries. We achieve this by using a slightly asymmetric plot domain.\
\>", \
"Text"],

Cell["\<\
data = Module[{\[CurlyEpsilon] = 1/Pi 10^-6, pp = 241}, N[#, 22]& @ \

       Table[q\[ScriptCapitalP]C[N[qr, 22], N[qi, 22]], {qi, -1, 1 + \
\[CurlyEpsilon], (2 + \[CurlyEpsilon])/pp},
                          {qr, 0, 5/2 + \[CurlyEpsilon], (5/2 + \
\[CurlyEpsilon])/pp}]];\
\>", "Input"],

Cell["\<\
Here is a plot of the resulting probability distribution function. \
We use a different (randomly chosen) color for each of the 45 rational \
functions covering the plane.\
\>", "Text"],

Cell["\<\
randomColor[0] := RGBColor[0, 0, 0];
randomColor[x_] := randomColor[x] = ToColor[Hue[Random[]], RGBColor]\
\>", \
"Input"],

Cell["\<\
Show[Graphics3D[
 ListPlot3D[Map[First, data, {2}], 
            Map[randomColor[Round[#]]&, Map[Last, data, {2}], {2}], 
            PlotRange -> All, MeshRange -> {{0, 5/2}, {-1, 1}},
            Mesh -> False, DisplayFunction -> Identity]] /. 
                                  h_Hue :> SurafeColor[h, h, 2.8],
     DisplayFunction -> $DisplayFunction]\
\>", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "13.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ",
  "Spring System"
}], "ExerciseHeading"],

Cell["\<\
Consider a level three Gosper curve from Chapter 2 of the Graphics \
volume. Assuming harmonically bound point masses at the vertices (the two \
outermost points are kept fixed) and springs of a given stiffness along the \
straight line segments of the Gosper curve, the resulting object is a 2D \
vibrating system. For small elongations, calculate the resulting \
eigenoscillations for identical stiffnesses and random stiffnesses. Starting \
with one inner vertex initially elongated, visualize how the vibrations \
propagate through the spring chain in the two cases.\
\>", "Text",
  CellTags->{
  "T[D[Vibrating Gosper Curve]]", "Index[12, {Gosper, curve}]", 
    "Index[12, {springs, along a Gosper curve}]"}],

Cell[CellGroupData[{

Cell["\<\
We start with defining the line segments that form the Gosper curve \
of order 3 using code adapted from Chapter 2 of the Graphics volume.\
\>", \
"SolutionSubgroup"],

Cell["\<\
LSystemWithlAndr[axiom_, rules_, iterations_, \[Delta]_] :=
Module[{m, p, c = Cos[\[Delta]], s = Sin[\[Delta]], \[ScriptCapitalR], \
\[ScriptL] = {0, 0}, \[ScriptD] = {1, 0}},
 m = {{ c, s}, {-s, c}}; p = {{ c, -s}, { s, c}};
 \[ScriptCapitalR] = rules /. {(a_ -> b_) -> (a :> Sequence @@ b)};
 Select[Prepend[
 (Which[# == \"l\", \[ScriptL] = \[ScriptL] + \[ScriptD],  # == \"r\", \
\[ScriptL] = \[ScriptL] + \[ScriptD],
        # == \"+\", \[ScriptD] = p.\[ScriptD]; Null, # == \"-\", \[ScriptD] = \
m.\[ScriptD]; ]& /@
       Nest[(# /. \[ScriptCapitalR])&, axiom, iterations]), {0, 0}], # =!= \
Null&]]\
\>", "Input"],

Cell["\<\
Gosper[i_Integer] := Gosper[i] = LSystemWithlAndr[
{\"l\"}, {\"l\" -> Characters[\"l+r++r-l--ll-r+\"],
        \"r\" -> Characters[\"-l+rr++r+l--l-r\"]}, i, Pi/3]\
\>", "Input"],

Cell["Next, we join the adjacent parallel line segments into one.", "Text"],

Cell[TextData[{
  StyleBox["(* are the three points p1, p2, p3 on one straight line? *)", 
    "CodeComment"],
  "\noneOneLineQ[{p1_, p2_, p3_}] := oneOneLineQ[{p1, p2, p3}] =\nWith[{\
\[ScriptN] = Sqrt[#.#]&}, \n     Expand[\[ScriptN][p3 - p1] - (\[ScriptN][p2 \
- p1] + \[ScriptN][p3 - p2])] === 0]"
}], "Input"],

Cell["\<\
order = 3;
gosperLine = Gosper[order] //. {a___, p1_, p2_, p3_, b___} :>
              {a, p1, p3, b} /; oneOneLineQ[{p1, p2, p3}];\
\>", "Input"],

Cell["\<\
Here is the resulting Gosper curve with 293 inner vertices. We \
color each line segment differently. For later use, we mark one central \
point.\
\>", "Text"],

Cell["\<\
{\[ScriptD] = Length[gosperLine], dim = \[ScriptD] - 2}\
\>", \
"Input"],

Cell["\<\
Position[#, Min[#]]&[
Function[mp, (mp - #).(mp - #)& /@ gosperLine][
         Plus @@ gosperLine/Length[gosperLine]]][[1, 1]]\
\>", "Input"],

Cell[TextData[{
  StyleBox["(* position of one central vertex *)", "CodeComment"],
  "\nm = Which[order == 1, 4, order == 2, 15, \n          order == 3, 113, \
order == 4, 791];\n",
  StyleBox["(* or use point nearest to center:\nPosition[#, Min[#]]&[\n\
Function[mp, (mp - #).(mp - #)& /@ gosperLine][\n         Plus @@ \
gosperLine/Length[gosperLine]]][[1, 1]] *)  ", "CodeComment"],
  "        \n",
  StyleBox["(* show straight line segments of the Gosper curve *)", 
    "CodeComment"],
  "\nShow[Graphics[{{Hue[Random[]], Thickness[0.002], Line[#]}& /@ \n         \
       Partition[gosperLine, 2, 1],\n               {PointSize[0.03], \
Point[gosperLine[[m]]]}}], \n     AspectRatio -> Automatic]"
}], "Input"],

Cell[TextData[{
  "Giving the first vertex the index 0, allows to conveniently refer to the \
293 movable vertices by their number ",
  StyleBox["vertexNumber", "MR"],
  "."
}], "Text"],

Cell["\<\
Do[vertexNumber[gosperLine[[k]]] = k - 1;
   vertexCoordinates[k - 1] = gosperLine[[k]],
   {k, Length[gosperLine]}] \
\>", "Input"],

Cell[TextData[{
  "To calculate the eigenoscillations of the Gosper spring chain, we make the \
ansatz ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              OverscriptBox[
                StyleBox["u",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], ".."], "j"], "(", "t", ")"}], 
          "\[Tilde]", 
          RowBox[{
            SuperscriptBox["e", 
              RowBox[{"i", " ", "\[Omega]", " ", "t"}]], 
            SubscriptBox[
              OverscriptBox[
                StyleBox["u",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], "^"], "j"]}]}], TraditionalForm]]],
  " in the equations of motions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              OverscriptBox[
                StyleBox["u",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], ".."], "j"], "(", "t", ")"}], "=", 
          RowBox[{
            RowBox[{
              SubscriptBox["k", 
                RowBox[{"j", " "}]], 
              RowBox[{
                StyleBox["f",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], "(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox[
                      StyleBox["u",
                        FontWeight->"Bold",
                        FontSlant->"Plain"], 
                      RowBox[{"j", "-", "1"}]], "(", "t", ")"}], ",", 
                  RowBox[{
                    SubscriptBox[
                      StyleBox["u",
                        FontWeight->"Bold",
                        FontSlant->"Plain"], "j"], "(", "t", ")"}]}], ")"}]}],
             "+", 
            RowBox[{
              SubscriptBox["k", 
                RowBox[{"j", "+", "1", " "}]], 
              RowBox[{
                StyleBox["f",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], "(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox[
                      StyleBox["u",
                        FontWeight->"Bold",
                        FontSlant->"Plain"], 
                      RowBox[{"j", "+", "1"}]], "(", "t", ")"}], ",", 
                  RowBox[{
                    SubscriptBox[
                      StyleBox["u",
                        FontWeight->"Bold",
                        FontSlant->"Plain"], "j"], "(", "t", ")"}]}], ")"}]}],
             "-", 
            RowBox[{"\[Kappa]", " ", 
              RowBox[{
                RowBox[{
                  SubscriptBox[
                    StyleBox["u",
                      FontWeight->"Bold",
                      FontSlant->"Plain"], "j"], "(", "t", ")"}], " ", 
                "."}]}]}]}], TraditionalForm]]],
  " Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            StyleBox["u",
              FontWeight->"Bold",
              FontSlant->"Plain"], "j"], "(", "t", ")"}], TraditionalForm]]],
  " is the elongation of the ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  "th vertex, ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["k", "j"], TraditionalForm]]],
  " is the stiffness of the ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  "th spring connecting the vertices ",
  Cell[BoxData[
      FormBox[
        RowBox[{"j", "-", "1"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"j", " "}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["f",
            FontWeight->"Bold",
            FontSlant->"Plain"], "(", 
          RowBox[{
            RowBox[{
              SubscriptBox[
                StyleBox["u",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], 
                RowBox[{"j", "-", "1"}]], "(", "t", ")"}], ",", 
            RowBox[{
              SubscriptBox[
                StyleBox["u",
                  FontWeight->"Bold",
                  FontSlant->"Plain"], "j"], "(", "t", ")"}]}], ")"}], 
        TraditionalForm]]],
  " is the force exerted by the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"j", "+", "1"}], TraditionalForm]]],
  "th vertex on the ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  "th vertex, and ",
  Cell[BoxData[
      FormBox["\[Kappa]", TraditionalForm]]],
  " accounts for the harmonic bounds at the original positions of the \
vertices along the Gosper curve. Here the forces defined."
}], "Text",
  CellTags->"Index[12, {Cosper, spring chain}]"],

Cell[TextData[{
  "F[k_] := force[{k, k + 1}] + force[{k, k - 1}] + force[{k}]\n\nforce[{i_, \
j_}] := \nModule[{p0i = vertexCoordinates[i], \n        p0j = \
vertexCoordinates[j], pi, pj},\n        pi = p0i + {x[i], y[i]}; pj = p0j + \
{x[j], y[j]};\n        \[ScriptK][Max[{i, j}]] #/Sqrt[#.#]&[pj - pi]*\n       \
  (Sqrt[#.#]&[pj - pi] - Sqrt[#.#]&[p0j - p0i])]\n         \n",
  StyleBox["(* harmonic bound to the original vertices *)", "CodeComment"],
  "\nforce[{k_}] := -\[Kappa] {x[k], y[k]};  "
}], "Input"],

Cell[TextData[{
  "For small elongations, we keep only terms linear in the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            OverscriptBox[
              StyleBox["u",
                FontWeight->"Bold",
                FontSlant->"Plain"], "^"], "j"], "=", 
          RowBox[{"{", 
            RowBox[{
              SubscriptBox["x", "j"], ",", 
              SubscriptBox["y", "j"]}], "}"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "FLinearized[k_] := Normal[\n   Series[F[k] /. xy:(_x | _y) :> \
\[CurlyEpsilon] xy, {\[CurlyEpsilon], 0, 1}]]/\[CurlyEpsilon] /.\n  ",
  StyleBox["(* endpoints *) ", "CodeComment"],
  "{x[0 | \[ScriptD] - 1] -> 0, y[0 | \[ScriptD] - 1] -> 0}"
}], "Input"],

Cell["This is the linearized force exerted on the second vertex.", "Text"],

Cell["FLinearized[2] // Collect[#, {_x, _y}]&", "Input"],

Cell[TextData[{
  "Forming the coefficient matrix of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["x", "j"], ",", 
            SubscriptBox["y", "j"]}], "}"}], TraditionalForm]]],
  ". In this matrix of dimension ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", "d", "\[Times]", "2", "d"}], TraditionalForm]]],
  " we first take the coefficients of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "j"], TraditionalForm]]],
  " and then the coefficients of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["y", "j"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "coefficientRules[\[ScriptK]_, \[Kappa]_] = \nModule[{\[Upsilon], xC, yC},\n\
 ",
  StyleBox["(* extract x[j], y[j] and coefficient *)", "CodeComment"],
  "\n \[Upsilon][p_Plus] := \[Upsilon] /@ (List @@ p); \[Upsilon][l_List] := \
\[Upsilon] /@ l;\n \[Upsilon][f_. x[j_]] := {j, f}; \[Upsilon][f_. y[j_]] := \
{dim + j, f}; \[Upsilon][0] := {};\n Flatten[Table[{xC, yC} = \
Collect[FLinearized[k], {_x, _y}];\n               ",
  StyleBox["(* matrix entries *)", "CodeComment"],
  "\n               {({k, #1} -> #2)& @@@ \[Upsilon][xC],\n               ",
  StyleBox["(* y[] after all the x[] *)", "CodeComment"],
  "\n               ({dim + k, #1} -> #2)& @@@ \[Upsilon][yC]}, {k, dim}]]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* form matrix from rules of nonvanishing elements *)", 
    "CodeComment"],
  "\nmakeMatrix[\[ScriptR]:rules_] := \nModule[{\[ScriptM] = Table[0, {#}, \
{#}]&[Max[First /@ rules]]},\n      ",
  StyleBox["(* insert nonvanishing matrix elements *)", "CodeComment"],
  "\n       Do[\[ScriptM][[\[ScriptR][[i, 1, 1]], \[ScriptR][[i, 1, 2]]]] = \n\
          \[ScriptM][[\[ScriptR][[i, 1, 1]], \[ScriptR][[i, 1, 2]]]] + \
\[ScriptR][[i, 2]],\n          {i, Length[\[ScriptR]]}]; \[ScriptM]]"
}], "Input"],

Cell[TextData[{
  "Here are two coefficient matrices. The first ",
  StyleBox["M[1]", "MR"],
  " uses constant spring stiffnesses and the second ",
  StyleBox["M[2]", "MR"],
  " uses random ones with the same mean as the values of the first one (we \
could also use some negative spring constants ",
  "[",
  
  CounterBox["BibliographyCounter", "Wang04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Wang04",
    ButtonStyle->"Hyperlink"],
  "])",
  " ."
}], "Text"],

Cell["\<\
M[1] = makeMatrix[coefficientRules[2&, 1]];

SeedRandom[1];
M[2] = makeMatrix[
        coefficientRules[(SeedRandom[#]; 4 Random[])&, 
                         2 Random[]]];\
\>", "Input"],

Cell["Do[{evals[j], evecs[j]} = Eigensystem[N[M[j]]], {j, 2}]", "Input"],

Cell[TextData[{
  "Here are the two spectra and eigenvectors visualized. The first half are \
the nontrivial global modes and the second half are the superpositions of \
local modes due to the harmonic bounds at the lattice points and \
perpendicular movements. (The two intermediate modes in ",
  StyleBox["M[1]", "MR"],
  " arise from the two endpoints.) In the case of random spring constants, we \
clearly see localized modes."
}], "Text"],

Cell["\<\
Do[Show[GraphicsArray[
   Block[{$DisplayFunction = Identity},
         {ListPlot[-evals[j]], ListDensityPlot[Re[evecs[j]], 
           Mesh -> False, FrameTicks -> None]}]]], {j, 2}]\
\>", "Input"],

Cell[TextData[{
  "The localization properties of the modes can be demonstrated by \
considering the overlap with the situation of all vertices are initially \
elongated in direction ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"cos", "(", "\[CurlyPhi]", ")"}], ",", 
            RowBox[{"sin", "(", "\[CurlyPhi]", ")"}]}], "}"}], 
        TraditionalForm]]],
  ". The following graphics show the value of the scalar product of the modes \
with the initial elongation as a function of ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[\nGraphics3D[{PointSize[0.002], \nTable[",
  StyleBox["(* all initial positions are equal *)", "CodeComment"],
  "\n      initialVector = Join[#, #]&[Table[Cos[\[CurlyPhi]], {dim}]];\n     \
 ",
  StyleBox["(* show overlaps *)", "CodeComment"],
  "\n      MapIndexed[{Hue[#2[[1]]/dim], Point[{#2[[1]], \[CurlyPhi], Re @ \
#1}]}&,\n           initialVector.#& /@ evecs[#]], {\[CurlyPhi], 0., 2.Pi, \
2Pi/10}]},\n     BoxRatios -> {2, 1, 1}, Axes -> True]& /@ {1, 2}]]"
}], "Input"],

Cell["\<\
Now, we consider the time\[Hyphen]dependence of an inner vertex \
initially elongated. The scalar products of the eigenvectors with this \
initial state are shown in the following two graphics.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* one vertex is initially elongated *)", "CodeComment"],
  "\ninitialVector = MapAt[-1&, Table[0, {2dim}], m - 1] // N;\n",
  StyleBox["(* form scalar products *)", "CodeComment"],
  "\nDo[coeffs[j] = (initialVector.#& /@ evecs[j]), {j, 2}];\n",
  StyleBox["(* show scalar products *)", "CodeComment"],
  "\nShow[GraphicsArray[\n ListPlot[Re[coeffs[#]], PlotRange -> All, \
DisplayFunction -> Identity,\n          PlotStyle -> {PointSize[0.01]}]& /@ \
{1, 2}]]"
}], "Input"],

Cell[TextData[{
  "The time dependent elongation of all vertices follows from the \
superposition ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              StyleBox["u",
                FontWeight->"Bold",
                FontSlant->"Plain"], "j"], "(", "t", ")"}], "=", 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "d"], 
            RowBox[{
              SubsuperscriptBox["c", "k", 
                RowBox[{"(", "j", ")"}]], 
              SuperscriptBox["e", 
                RowBox[{"i", " ", 
                  SubscriptBox["\[Omega]", "k"], " ", "t"}]]}]}]}], 
        TraditionalForm]]],
  " where the ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["c", "k", 
          RowBox[{"(", "j", ")"}]], TraditionalForm]]],
  " is the scalar product of the ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "th eigenvector with the initial elongation vector."
}], "Text"],

Cell["\<\
evI[j_][t_] := Plus @@ (Times @@@ Transpose[
               {coeffs[j] Cos[Sqrt[Abs[evals[j]]] t], evecs[j]}])\
\>", \
"Input"],

Cell["\<\
Here are the resulting time\[Hyphen]dependent elongations shown. In \
the equal stiffness case, we see a constant speed propagation of the \
perturbation. After the two end vertices of the chain are reached, \
reflections occur. In the random stiffness case, the perturbation stays \
largely localized over the same time.\
\>", "Text"],

Cell[TextData[{
  "Show[GraphicsArray[Table[\n",
  StyleBox["(* elongation values *)", "CodeComment"],
  "\nT = Table[Sqrt[Re[#.#]]& /@ Transpose[Partition[evI[j][t], dim]],\n      \
    {t, 0, 600, 2}];\n",
  StyleBox["(* homogeneously spaced elongation values *)", "CodeComment"],
  "\ncls = #[[Round[Length[#]/2]]]& /@\n         \
Partition[Sort[Flatten[Chop[T, 10^-12]]], dim];   \n",
  StyleBox["(* color function *)", "CodeComment"],
  "\ncf[j][x_] = Which @@ Flatten[Append[\n             MapIndexed[{x < #1, \
GrayLevel[(#2[[1]] - 1)/Length[cls]]}&, \n                        cls], \
{True, GrayLevel[1]}]];   \n",
  StyleBox["(* generate homogeneously colored density plot *)", 
    "CodeComment"],
  "\nListDensityPlot[T,  PlotRange -> All, ColorFunction -> cf[j], \n         \
       Mesh -> False, DisplayFunction -> Identity,\n                MeshRange \
-> {{1, dim}, {0, 600}}], {j, 2}]]]       "
}], "Input"],

Cell["\<\
We end with an animation of the spread of the initial elongation.\
\
\>", "Text"],

Cell[TextData[{
  "frame[vec_, opts___] :=\nModule[{mima, vecS, segments, elongs, colors}, \n \
",
  StyleBox["(* scaled elongation vectors *)", "CodeComment"],
  "\n vecS = Join[{{0, 0}}, Transpose[Partition[vec, dim]], {{0, 0}}];\n ",
  StyleBox["(* line along elongated vertices *)", "CodeComment"],
  "\n segments = Line /@ Partition[gosperLine + 1/2 vecS, 2, 1];\n elongs = \
#/Max[#]&[Sqrt[#.#]& /@ Re[vecS]]; \n ",
  StyleBox["(* color segments according to elongation *)", "CodeComment"],
  "\n colors = Hue /@ (Plus @@@ Partition[elongs, 2, 1]/2);                \n \
",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\n Graphics[{{PointSize[0.03], Point[gosperLine[[m]]]},\n           \
Transpose[{colors, segments}]}, \n           ",
  StyleBox["(* use uniform plot range *) ", "CodeComment"],
  "PlotRange -> \n           ((# + {-1, 1})& /@ ({Min[#], Max[#]}& /@ \n      \
      Transpose[gosperLine])), opts, \n            AspectRatio -> \
Automatic]];"
}], "Input"],

Cell["\<\
Do[Show[GraphicsArray[Table[frame[evI[j][t]], {j, 2}]]],
   {t, 0, 600, 120}]\
\>", "Input"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "WSA_VibratingGosperCurve.nb"], 
          None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["\<\
Do[Show[GraphicsArray[Table[frame[evI[j][t]], {j, 2}]]],
   {t, 0, 600, 5}]\
\>", "Program"],

Cell["", "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "14.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Average Distance Distribution"
}], "ExerciseHeading"],

Cell[TextData[{
  "In exercise 35 of Chapter 1 of the Symbolics volume, the average distance \
of two randomly chosen points from within the unit square was calculated. \
Now, calculate the probability distribution ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptP]", "(", "d", ")"}], TraditionalForm]]],
  " for the occurring lengths ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "\[LessEqual]", "d", "\[LessEqual]", 
          SuperscriptBox["2", 
            RowBox[{
              RowBox[{"1", "/", "2"}], " "}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start numerical simulation. We use ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "8"], TraditionalForm]]],
  " pairs of points and bin the calculated distances. The lower and upper \
limits of the possible lengths are ",
  Cell[BoxData[
      FormBox["0", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["2", 
          RowBox[{"1", "/", "2"}]], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell["\<\
cf = Compile[{{n, _Integer}, {bins, _Integer}},
            Module[{tab = Table[0, {bins}], \[Lambda], b},
                   Do[\[Lambda] = Sqrt[(Random[] - Random[])^2 + 
                               (Random[] - Random[])^2];
                      b = Ceiling[bins \[Lambda]/Sqrt[2]];
                      tab[[b]] = tab[[b]] + 1, {n}];
                    tab/n]];\
\>", "Input"],

Cell[TextData[{
  "The resulting distribution is relatively broad with a maximum around ",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", "\[TildeTilde]", "0.5"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
lcp = With[{bins = 100, n = 10^8}, 
ListPlot[MapIndexed[{Sqrt[2] #2[[1]]/bins, bins/Sqrt[2] #1}&, 
                    cf[n, bins]], PlotStyle -> PointSize[0.006]]];\
\>", \
"Input"],

Cell["The exact distribution is given by the following integral", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[ScriptP]", "(", "\[Lambda]", ")"}], "=", 
        RowBox[{
          UnderoverscriptBox["\[Integral]", "0", "1"], 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "0", "1"], 
            RowBox[{
              UnderoverscriptBox["\[Integral]", "0", "1"], 
              RowBox[{
                UnderoverscriptBox["\[Integral]", 
                  RowBox[{" ", "0"}], "1"], 
                RowBox[{
                  RowBox[{"\[Delta]", "(", 
                    RowBox[{"\[Lambda]", "-", 
                      SqrtBox[
                        RowBox[{
                          SuperscriptBox[
                            RowBox[{"(", 
                              RowBox[{
                                SubscriptBox["x", "2"], "-", 
                                SubscriptBox["x", "1"]}], ")"}], "2"], "+", 
                          SuperscriptBox[
                            RowBox[{"(", 
                              RowBox[{
                                SubscriptBox["y", "2"], "-", 
                                SubscriptBox["y", "1"]}], ")"}], "2"]}]]}], 
                    ")"}], " ", "d", "\[InvisibleSpace]", 
                  SubscriptBox["y", "2"], "d", "\[InvisibleSpace]", 
                  SubscriptBox["y", "1"], "d", "\[InvisibleSpace]", 
                  SubscriptBox["x", "2"], "d", "\[InvisibleSpace]", 
                  SubscriptBox["x", "1"]}]}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " cannot carry out even the innermost integration symbolically."
}], "Text"],

Cell["\<\
\[ScriptD][{x1_, y1_}, {x2_, y2_}] := Sqrt[(x1 - x2)^2 + (y1 - \
y2)^2]\
\>", "Input"],

Cell["\<\
Integrate[DiracDelta[\[Lambda] - \[ScriptD][{x1, y1}, {x2, y2}]], \
{y1, 0, 1 - x1}]\
\>", "Input"],

Cell[TextData[{
  "So we will use the well known formula ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[Integral]", "\[ScriptCapitalI]"], 
            RowBox[{
              RowBox[{"\[Delta]", "(", 
                RowBox[{"y", "-", 
                  RowBox[{"f", "(", "x", ")"}]}], ")"}], "d", 
              "\[InvisibleSpace]", "x"}]}], "=", 
          RowBox[{
            SubscriptBox["\[Integral]", "\[ScriptCapitalI]"], 
            RowBox[{
              SubscriptBox["\[Sum]", "k"], 
              RowBox[{
                RowBox[{
                  RowBox[{"\[Delta]", "(", 
                    RowBox[{"y", "-", 
                      SubscriptBox["x", "k"]}], ")"}], "/", 
                  RowBox[{"\[LeftBracketingBar]", 
                    RowBox[{
                      SuperscriptBox["f", "\[Prime]"], "(", 
                      SubscriptBox["x", "k"], ")"}], 
                    "\[RightBracketingBar]"}]}], "d", "\[InvisibleSpace]", 
                "x"}]}]}]}], TraditionalForm]]],
  " where the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "k"], TraditionalForm]]],
  " are the zeros of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"f", "(", "x", ")"}], TraditionalForm]]],
  " in the interval ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalI]", TraditionalForm]]],
  ". For the integrand under consideration, we have up to two zeros."
}], "Text"],

Cell["\<\
sol = Solve[\[Lambda] - \[ScriptD][{x1, y1}, {x2, y2}] == 0, y2] // \
Simplify\
\>", "Input"],

Cell["\<\
The denominator absolute value is identical for the two \
roots.\
\>", "Text"],

Cell["\<\
{int1y2, int2y2} = (1/D[\[Lambda] - \[ScriptD][{x1, y1}, {x2, y2}], \
y2] /. # // 
                                  Simplify[#, \[Lambda] > 0]&)& /@ sol\
\>", \
"Input"],

Cell["inty2 = int1y2;", "Input"],

Cell[TextData[{
  "For carrying out the various integration, we subdivide the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "1"], TraditionalForm]]],
  "\[Hyphen]",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "2"], TraditionalForm]]],
  "\[Hyphen]",
  Cell[BoxData[
      FormBox[
        SubscriptBox["y", "1"], TraditionalForm]]],
  " space into regions of identical sign of the root expression (this \
automatically ensures the existence of the roots)."
}], "Text"],

Cell["\<\
cond1 = 0 < x1 < 1 && 0 < x2 < 1 && 0 < y1 < 1 &&
        0 < sol[[1, 1, 2]] < 1 && \[Lambda] > 0;\
\>", "Input"],

Cell["\<\
cad1 = CylindricalDecomposition[cond1, {\[Lambda], x1, x2, \
y1}];\
\>", "Input"],

Cell[TextData[{
  "We group the resulting regions with respect to the ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]domains."
}], "Text"],

Cell["\<\
expandCAD[cad_] := 
{#[[1, 1]], Rest /@ #}& /@ Split[List @@ #, #1[[1]] == #2[[1]]&]& @ 
  DeleteCases[cad  //. a_ && (b_ || c_) :> (a && b) || (a && c) /. 
                                                 LessEqual -> Less,
              _?(MemberQ[#, _Equal, Infinity]&)]\
\>", "Input"],

Cell["Here is the subdivision corresponding to the first root.", "Text"],

Cell["cad1R = expandCAD[cad1]", "Input"],

Cell["\<\
And here is the subdivision corresponding to the second root.\
\>", \
"Text"],

Cell["\<\
cond2 = 0 < x1 < 1 && 0 < x2 < 1 && 0 < y1 < 1 &&
        0 < sol[[2, 1, 2]] < 1 && \[Lambda] > 0;\
\>", "Input"],

Cell["\<\
cad2 = CylindricalDecomposition[cond2, {\[Lambda], x1, x2, y1}];
cad2R = expandCAD[cad2]\
\>", "Input"],

Cell[TextData[{
  "We have four ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]intervals."
}], "Text"],

Cell["{First /@ cad1R, First /@ cad2R}", "Input"],

Cell["\[Lambda]Intervals = %[[1]];", "Input"],

Cell[TextData[{
  "Now, we must carry out the remaining three integrations for the four ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]domains. The function ",
  StyleBox["x1x2y1Integration", "MR"],
  " iteratively forms the indefinite integral and then calculates the values \
at the upper and lower limit to obtain the value of the definite integral. We \
do the definite integration manually to avoid that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " spends time on checking the integration range for singularities and \
discontinuities; because the integration domains were constructed to ensure a \
smooth dependence in their inside, this is not needed."
}], "Text"],

Cell[TextData[{
  "x1x2y1Integration[cad_, startIntegrand_] :=\nModule[{\[ScriptCapitalD]\
\[ScriptCapitalL], \[ScriptV]2, x1L, x1U, \[ScriptV]3, x2L, x2U, \[ScriptV]4, \
y1L, y1U},\n",
  StyleBox[" (* form difference of integral at upper limit minus\n    \
integral at lower limit *)", "CodeComment"],
  "\n \[ScriptCapitalD]\[ScriptCapitalL] = (Limit[#1, #2[[1]] -> #2[[3]], \
Direction -> +1] - \n       Limit[#1, #2[[1]] -> #2[[2]], Direction -> -1])&; \
    \n ",
  StyleBox["(* integration regions *)", "CodeComment"],
  "\n {{\[ScriptV]2, x1L, x1U}, {\[ScriptV]3, x2L, x2U}, {\[ScriptV]4, y1L, \
y1U}} = \n            cad /. Inequality[a_, Less, b_, Less, c_] :>\n          \
                       {b, a, c} /. And -> List;\n ",
  StyleBox["(* carry out the three integrations *)", "CodeComment"],
  "\n Fold[\[ScriptCapitalD]\[ScriptCapitalL][Integrate[#1, #2[[1]]], #2]&, \
startIntegrand, \n      {{\[ScriptV]4, y1L, y1U}, {\[ScriptV]3, x2L, x2U}, {\
\[ScriptV]2, x1L, x1U}}]]"
}], "Input"],

Cell[TextData[{
  "Summing up the contributions for all ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "1"], TraditionalForm]]],
  "\[Hyphen]",
  Cell[BoxData[
      FormBox[
        SubscriptBox["x", "2"], TraditionalForm]]],
  "\[Hyphen]",
  Cell[BoxData[
      FormBox[
        SubscriptBox["y", "1"], TraditionalForm]]],
  "regions belonging to a given ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]domain gives the probability distribution we are looking for."
}], "Text"],

Cell["\<\
sumUp[\[Lambda]Range_] := 
  Simplify[Plus @@ #, \[Lambda]Range]& @ (x1x2y1Integration[#, inty2]& /@
   Flatten[Last /@ Cases[{cad1R, cad2R}, {\[Lambda]Range, _}, \
Infinity]])\
\>", "Input"],

Cell[TextData[{
  "The resulting distribution has different functional form in the two \
intervals ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0", ",", "1"}], "]"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"1", ",", 
            SuperscriptBox["2", 
              RowBox[{"1", "/", "2"}]]}], "]"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
{\[ScriptP][{0, 1/2}], \[ScriptP][{1/2, 1}], \[ScriptP][{1, \
Sqrt[5]/2}], \[ScriptP][{1, Sqrt[5]/2}]} = 
                                           sumUp /@ \[Lambda]Intervals\
\>", \
"Input"],

Cell[TextData[{
  "Here is a graphic of the resulting distribution. The earlier calculated \
numerical values agree excellently with the theoretical curve. The resulting \
curve is continuous differentiable at ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Lambda]", "=", "1"}], TraditionalForm]]],
  " (the second derivative is discontinuous)."
}], "Text"],

Cell["\<\
Plot[Which[0 < \[Lambda] < 1, \[ScriptP][{0, 1/2}], 1 < \[Lambda] < \
Sqrt[2], \[ScriptP][{1, Sqrt[5]/2}]], 
     {\[Lambda], 0, Sqrt[2]}, Prolog -> {PointSize[0.009], Hue[0],
                                 Cases[lcp, _Point, Infinity]},
     PlotStyle -> {{Thickness[0.002], GrayLevel[0.8]}}];\
\>", "Input"],

Cell["\<\
\[ScriptP]D[\[Lambda]_] := UnitStep[\[Lambda]] UnitStep[1 - \
\[Lambda]] 2 \[Lambda] (Pi + \[Lambda] (\[Lambda] - 4)) + 
          UnitStep[\[Lambda] - 1] UnitStep[Sqrt[2] - \[Lambda]]*
            (2 \[Lambda] (Pi - 2 - \[Lambda]^2 + 4 Sqrt[\[Lambda]^2 - 1] - 4 \
ArcTan[Sqrt[\[Lambda]^2 - 1]]))\
\>", "Input"],

Cell[TextData[{
  "By construction, the distribution is normalized to ",
  Cell[BoxData[
      FormBox["1", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Integrate[\[ScriptP][{0, 1/2}], {\[Lambda], 0, 1}] + Integrate[\
\[ScriptP][{1, Sqrt[5]/2}], {\[Lambda], 1, Sqrt[2]}]\
\>", "Input"],

Cell[TextData[{
  "The maximum occurs at ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["d", "max"], "\[TildeTilde]", "0.48"}], 
        TraditionalForm]]],
  ". Interestingly, the maximum of the distribution has nearly exactly the \
same distance from 0.5 as the expectation value (the maximum is slightly less \
than 0.5 and the maximum is slightly larger than 0.5.)"
}], "Text"],

Cell["\<\
{#, N @ #}& @ Min[\[Lambda] /. Solve[D[\[ScriptP][{0, 1/2}], \
\[Lambda]] == 0, \[Lambda]]]\
\>", "Input"],

Cell["\<\
{(2 + Sqrt[2] + 5 ArcSinh[1])/15 - 1/2, 
 1/2 -  (4 - Sqrt[16 - 3 Pi])/3} // N\
\>", "Input"],

Cell["\<\
We end by calculating once more the expectation value. Using the \
obtained form of the distribution directly results in a complicated \
expression containing hypergeometric functions for the expectation \
value.\
\>", "Text"],

Cell["\<\
av1 = Integrate[\[Lambda] S[{0, 1/2}], {\[Lambda], 0, 1}]\
\>", \
"Input"],

Cell["\<\
av2 = Integrate[\[Lambda] \[ScriptP][{1, Sqrt[5]/2}], {\[Lambda], \
1, Sqrt[2]}]\
\>", "Input"],

Cell["\<\
Calculating the last integral through the indefinite integral \
yields a result in elementary functions.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* form indefinite integral *)", "CodeComment"],
  "\nint\[Lambda] = Integrate[\[Lambda] \[ScriptP][{1, Sqrt[5]/2}], \
\[Lambda]]"
}], "Input"],

Cell["\<\
Forming the indefinite integral yields once more the result from \
solution 35a.\
\>", "Text"],

Cell["\<\
av2b = Limit[int\[Lambda], \[Lambda] -> Sqrt[2], Direction -> 1] - 
       Limit[int\[Lambda], \[Lambda] -> 1, Direction -> -1];\
\>", "Input"],

Cell["av1 + av2b // FullSimplify", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "15.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Dirichlet\[Dash]Neumann Boundary Condition Transition"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the 2D eigenvalue problem ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"-", "\[CapitalDelta]"}], " ", 
            RowBox[{
              SubscriptBox["u", "\[Lambda]"], "(", 
              RowBox[{"x", ",", "y"}], ")"}]}], "=", 
          RowBox[{"\[Lambda]", " ", 
            RowBox[{
              SubscriptBox["u", "\[Lambda]"], "(", 
              RowBox[{"x", ",", "y"}], ")"}]}]}], TraditionalForm]],
    GeneratedCell->False],
  " on a square ",
  Cell[BoxData[
      FormBox["S", TraditionalForm]]],
  ". The boundary conditions on two edges and the two adjacent half edges are \
homogeneous Dirichlet conditions, meaning ",
  Cell[BoxData[
      FormBox[
        RowBox[{" ", 
          RowBox[{
            RowBox[{
              RowBox[{
                SubscriptBox["u", "\[Lambda]"], "(", 
                RowBox[{"x", ",", "y"}], ")"}], 
              SubscriptBox["|", 
                RowBox[{
                  SubscriptBox["\[PartialD]", "D"], "S"}]]}], "=", "0"}]}], 
        TraditionalForm]],
    GeneratedCell->False],
  " (so\[Hyphen]called mixed or hybrid boundary conditions [",
  
  CounterBox["BibliographyCounter", "Sneddon66"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Sneddon66",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Azzam82"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Azzam82",
    ButtonStyle->"Hyperlink"],
  "]). On the remaining two half edges that meet at a vertex, the boundary \
condition is a homogeneous Robin condition ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{
              RowBox[{
                RowBox[{"(", 
                  RowBox[{"1", "-", "\[Alpha]"}], ")"}], 
                RowBox[{
                  RowBox[{"\[PartialD]", 
                    RowBox[{
                      SubscriptBox["u", "\[Lambda]"], "(", 
                      RowBox[{"x", ",", "y"}], ")"}]}], "/", 
                  RowBox[{"\[PartialD]", "n"}]}]}], "+", 
              RowBox[{"\[Alpha]", " ", 
                RowBox[{
                  SubscriptBox["u", "\[Lambda]"], "(", 
                  RowBox[{"x", ",", "y"}], ")"}]}]}], 
            SubscriptBox["|", 
              RowBox[{
                SubscriptBox["\[PartialD]", "D"], "S"}]]}], "=", "0"}], 
        TraditionalForm]]],
  ". Make an animation showing how some of the higher states change as ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " varies from 1 to 0 (meaning from homogeneous Dirichlet conditions of the \
half edge to homogeneous Neumann conditions). Use a finite element \
discretization to solve the 2D eigenvalue problem. "
}], "Text"],

Cell[CellGroupData[{

Cell["The weak form of the problem is", "SolutionSubgroup"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            RowBox[{
              UnderscriptBox["\[Integral]", "S"], 
              RowBox[{
                RowBox[{
                  RowBox[{"\[Del]", 
                    RowBox[{"u", "(", 
                      RowBox[{"x", ",", "y"}], ")"}]}], ".", 
                  RowBox[{"\[Del]", "v"}]}], " ", 
                RowBox[{"(", 
                  RowBox[{"x", ",", "y"}], ")"}], "d", "\[InvisibleSpace]", 
                "x", " ", "d", "\[InvisibleSpace]", "y"}]}], "+", 
            RowBox[{
              FractionBox["\[Alpha]", 
                RowBox[{"1", "-", "\[Alpha]"}]], 
              RowBox[{
                UnderscriptBox["\[Integral]", 
                  RowBox[{
                    SubscriptBox["\[PartialD]", "D"], "S"}]], " ", 
                RowBox[{
                  RowBox[{"u", "(", 
                    RowBox[{"x", ",", "y"}], ")"}], " ", 
                  RowBox[{"v", "(", 
                    RowBox[{"x", ",", "y"}], ")"}], " ", "d", 
                  "\[InvisibleSpace]", "s"}]}]}]}], "=", 
          RowBox[{
            UnderscriptBox[
              RowBox[{"\[Lambda]", "\[Integral]"}], "S"], " ", 
            RowBox[{"u", "(", 
              RowBox[{"x", ",", "y"}], ")"}], " ", 
            RowBox[{"v", "(", 
              RowBox[{"x", ",", "y"}], ")"}], " ", "d", "\[InvisibleSpace]", 
            "x", " ", "d", "\[InvisibleSpace]", "y"}]}], ","}], 
      TraditionalForm]], "DisplayFormula",
  GeneratedCell->False],

Cell["\<\
where we assume that the homogeneous Dirichlet conditions are \
strictly fulfilled.\
\>", "Text"],

Cell["\<\
A convenient discretization of the square is the subdivision into \
smaller squares. And a convenient shape function basis set are biquadratic \
polynomials with knot points at the vertices, the edge midpoints, and the \
center of a square.\
\>", "Text"],

Cell["\<\
Evaluate[Table[p[k], {k, 9}]] = 
           {{0, 0}, {2, 0}, {2, 2}, {0, 2}, {1, 0}, {2, 1}, {1, 2}, {0, 1}, \
{1, 1}}/2;\
\>", "Input"],

Cell["Here are the explicit forms of the nine shape functions.", "Text"],

Cell["\<\
Table[shapeFunction[m, {\[Xi]_, \[Eta]_}] =
 Factor[Sum[c[i, j] \[Xi]^i \[Eta]^j, {i, 0, 2}, {j, 0, 2}] /.
   Solve[Table[(Sum[c[i, j] \[Xi]^i \[Eta]^j, {i, 0, 2}, {j, 0, 2}] /. 
      Thread[{\[Xi], \[Eta]} -> p[k]]) == KroneckerDelta[m, k], {k, 9}],  
         Flatten[Table[c[i, j], {i, 0, 2}, {j, 0, 2}]]][[1]]], {m, 9}]\
\>", \
"Input"],

Cell["Here are the nine shape functions graphically hown.", "Text"],

Cell["\<\
Show[GraphicsArray[#]]& /@ Partition[
Table[Plot3D[Evaluate[shapeFunction[m, {\[Xi], \[Eta]}]], {\[Xi], 0, 1}, {\
\[Eta], 0, 1}, 
             PlotRange -> All, ColorFunction -> GrayLevel, Axes -> True,
             DisplayFunction -> Identity], {m, 9}], 3];\
\>", "Input"],

Cell[TextData[{
  "Next, we must calculate the mass matrix, the stiffness matrix, and the \
boundary line integral matrix for our nine shape functions. ",
  "Later, we will use subsquares of edge length ",
  Cell[BoxData[
      FormBox["\[Delta]", TraditionalForm]]],
  ", so the Jacobian is ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[Delta]", "2"], TraditionalForm]]],
  "."
}], "Text"],

Cell["\[ScriptCapitalJ] = \[Delta]^2;", "Input"],

Cell["Here is the mass matrix.", "Text"],

Cell["\<\
\[ScriptCapitalM]\[ScriptCapitalM] = \[ScriptCapitalJ] \
Table[Integrate[shapeFunction[m, {\[Xi], \[Eta]}] shapeFunction[n, {\[Xi], \
\[Eta]}],
                         {\[Xi], 0, 1}, {\[Eta], 0, 1}], {m, 9}, {n, \
9}];\
\>", "Input"],

Cell["\<\
The calculation of the stiffness matrix is straightforward \
too.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* unit square coordinates as a function of real coordinates *)\n\
", "CodeComment"],
  "\[Xi][{x_, y_}] := (x - x1)/\[Delta] ",
  StyleBox["(* with \[Delta]x = \[Delta] = (x2 - x1) *)", "CodeComment"],
  ";\n\[Eta][{x_, y_}] := (y - y1)/\[Delta] ",
  StyleBox["(* with \[Delta]y = \[Delta] = (y4 - y1) *)", "CodeComment"],
  ";\n\n",
  StyleBox["(* shape parameter values *)", "CodeComment"],
  "\n{\[ScriptCapitalA], \[ScriptCapitalC], \[ScriptCapitalB]} = \n\
{D[\[Xi][{x, y}], x]^2 + D[\[Xi][{x, y}], y]^2,\n D[\[Eta][{x, y}], x]^2 + D[\
\[Eta][{x, y}], y]^2,\n D[\[Xi][{x, y}], x] D[\[Eta][{x, y}], x] + \
D[\[Xi][{x, y}], y] D[\[Eta][{x, y}], y]} \[ScriptCapitalJ]"
}], "Input"],

Cell["\<\
\[ScriptCapitalS]\[ScriptCapitalM] = 
With[{sf = shapeFunction[#, {\[Xi], \[Eta]}]&},
 Table[\[ScriptCapitalA] Integrate[D[sf[m], \[Xi]] D[sf[n], \[Xi]], {\[Xi], \
0, 1}, {\[Eta], 0, 1}] +
       \[ScriptCapitalC] Integrate[D[sf[m], \[Eta]] D[sf[n], \[Eta]], {\[Xi], \
0, 1}, {\[Eta], 0, 1}],
        {m, 9}, {n, 9}]];\
\>", "Input",
  GeneratedCell->False],

Cell["And here is the matrix for the boundary line integrals.", "Text"],

Cell[TextData[{
  "\[ScriptCapitalB]\[ScriptCapitalM] = Table[0, {m, 9}, {n, 9}];\n\n\
Function[{\[Xi]\[Eta], args, nodes}, \
(\[ScriptCapitalB]\[ScriptCapitalM][[##]] = \n \[Delta] \
Integrate[shapeFunction[#1, args] shapeFunction[#2, args],\n                  \
       {\[Xi]\[Eta], 0, 1}])& @@@ \n  ",
  StyleBox["(* points that are connected *)", "CodeComment"],
  "\n  ({{#1, #1}, {#2, #2}, {#3, #3}, {#1, #2}, {#2, #1}, \n    {#1, #3}, \
{#3, #1}, {#2, #3}, {#3, #2}}& @@ nodes)] @@@\n    {{\[Xi], {\[Xi], 1}, {3, \
4, 7}}, {\[Xi], {\[Xi], 0}, {1, 5, 2}},\n     {\[Eta], {1, \[Eta]}, {2, 3, \
6}}, {\[Eta], {0, \[Eta]}, {1, 4, 8}}};"
}], "Input"],

Cell[TextData[{
  "Next, we subdivide our original square ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "1"}], ",", "1"}], "]"}], "\[Times]", 
          RowBox[{"[", 
            RowBox[{
              RowBox[{"-", "1"}], ",", "1"}], "]"}]}], TraditionalForm]]],
  " into subsquares of edge length ",
  Cell[BoxData[
      FormBox["\[Delta]", TraditionalForm]]],
  ". The function ",
  StyleBox["makeSubSquares", "MR"],
  " generates the subsquares and the function ",
  StyleBox["pointList", "MR"],
  " maps the knot points into the subsquares."
}], "Text"],

Cell["\<\
makeSubSquares[\[Delta]_] := 
 Table[Polygon[{{x, y}, {x + \[Delta], y}, {x + \[Delta], y + \[Delta]}, {x, \
y + \[Delta]}}],
        {x, -1, 1 - \[Delta], \[Delta]}, {y, -1, 1 - \[Delta], \[Delta]}] // \
Flatten[#, 1]&;

pointList[Polygon[{{x1_, y1_}, {x2_, y2_}, {x3_, y3_}, {x4_, y4_}}]] :=
             ({x1, y1} + {#1 (x2 - x1), #2 (y4 - y1)})& @@@ Array[p, 9]\
\>", \
"Input"],

Cell[TextData[{
  "Now, we classify all discretization points into interior, boundary, and \
Robin\[Hyphen]boundary points. The function ",
  StyleBox["makeVertexAssignments", "MR"],
  " subdivides the initial square with Robin boundary conditions according to \
the test ",
  StyleBox["robinPointQ", "MR"],
  " (each boundary point is subjected to this test) into ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[ScriptD]", "2"], TraditionalForm]]],
  " squares and generates list of vertices for the interior points, and the \
Robin\[Hyphen]boundary points. For later use, it makes various variable names \
globally visible. This allows to reuse them easily in various functions."
}], "Text"],

Cell[TextData[{
  "makeVertexAssignments[\[ScriptD]_, robinPointQ_] := \n\
Module[{subSquarePoints, allVertices, boundaryVertices},\n",
  StyleBox["(* global variables *)", "CodeComment"],
  "\nClear[subSquares, allNonDirichletVertices, dirichletVertices, \n      \
robinVertices, \[Lambda], \[Delta], nonDirichletVertexQ, robinVertexQ];\n\
\[Delta] = 2/\[ScriptD];\n",
  StyleBox["(* form subsquares and mapped points *)", "CodeComment"],
  "\nsubSquares = makeSubSquares[\[Delta]];\nsubSquarePoints = pointList /@ \
subSquares;\nallVertices = Union[Level[subSquarePoints, {-2}]];\n",
  StyleBox["(* all boundary vertices *)", "CodeComment"],
  "\nboundaryVertices = Cases[allVertices, {-1, _} | {+1, _} | {_, -1} | {_, \
+1}];\nrobinVertices = Select[boundaryVertices, robinPointQ];\n",
  StyleBox["(* make functions for Robin-boundary points *)", "CodeComment"],
  "\nDo[robinVertexQ[robinVertices[[j]]] = True,\n   {j, \
Length[robinVertices]}];\ndirichletVertices = Complement[boundaryVertices, \
robinVertices];\nallNonDirichletVertices = Complement[allVertices, \
dirichletVertices];\n\[Lambda] = Length[allNonDirichletVertices];\n",
  StyleBox["(* make functions for inner and Robin-boundary points *)", 
    "CodeComment"],
  "\nDo[nonDirichletVertexQ[allNonDirichletVertices[[j]]] = True;\n   \
coordinateVertex[j] = allNonDirichletVertices[[j]];\n   \
vertexNumber[allNonDirichletVertices[[j]]] = j, \n   {j, \[Lambda]}];\n\
Do[nonDirichletVertexQ[dirichletVertices[[j]]] = False;\n   coordinateVertex[\
\[Lambda] + j] = dirichletVertices[[j]];\n   \
vertexNumber[dirichletVertices[[j]]] = \[Lambda] + j, \n   {j, \
Length[dirichletVertices]}]]"
}], "Input"],

Cell["\<\
Here is graphic showing the Dirichlet boundary points in green, the \
Robin boundary points in red, and all non\[Hyphen]Dirichlet points in gray. \
The subsquares are bounded by blue lines.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* function to visualize point assignments *)", "CodeComment"],
  "\ndiscretizationGraphics[] := \nShow[Graphics[{\n {RGBColor[0, 0, 1], \
subSquares /. Polygon[l_] :> Line[Append[l, First[l]]]},\n {PointSize[0.02], \
RGBColor[0, 1, 0], Point /@ dirichletVertices},\n {PointSize[0.012], \
RGBColor[1, 0, 0], Point /@ robinVertices},\n {PointSize[0.006], \
GrayLevel[0.4], Point /@ allNonDirichletVertices}}], \n      PlotRange -> \
All, AspectRatio -> Automatic, Frame -> True];"
}], "Input"],

Cell["\<\
robinPointQ[{x_, y_}] := (0 < x <= 1 && y == 1) || 
                         (0 < y <= 1 && x == 1)
makeVertexAssignments[12, robinPointQ]\
\>", "Input"],

Cell["discretizationGraphics[]", "Input"],

Cell[TextData[{
  "For the solution of the eigenvalue problem through finite elements, we \
must assemble the global mass and stiffness matrices. The function ",
  StyleBox["makeSparseMatrix", "MR"],
  " generates the global mass matrix, stiffness matrix, and the boundary \
integral matrix arising from the Robin boundary conditions. To assemble the \
matrix, we use the global values of the functions ",
  StyleBox["subSquares", "MR"],
  ", ",
  StyleBox["vertexNumber", "MR"],
  ", ",
  StyleBox["nonDirichletVertexQ", "MR"],
  ", and ",
  StyleBox["robinVertexQ", "MR"],
  ". Because the resulting matrices are sparse and large, we generate them as \
sparse arrays."
}], "Text"],

Cell[TextData[{
  StyleBox["(* add elements *)", "CodeComment"],
  "\nmakeMatrix[values_] := ((List @@ #[[1, 1]]) -> (Plus @@ (Last /@ #)))& \
/@ \n                        Split[Sort[values], #1[[1]] == #2[[1]]&]"
}], "Input"],

Cell[TextData[{
  "makeSparseMatrix[criteria_, \[ScriptCapitalM]_] :=\nModule[{L = {}},\n ",
  StyleBox["(* loop over all subsquares *)", "CodeComment"],
  "\n Do[xyPoints = pointList[subSquares[[k]]];\n   ",
  StyleBox["(* loop over all nine points in a subsquare *)", "CodeComment"],
  "\n   Do[",
  StyleBox["(* for interior and Robin-boundary points, add contributions *)", 
    "CodeComment"],
  "\n      If[criteria[xyPoints[[a]]] && criteria[xyPoints[[b]]],\n         \
{i, j} = vertexNumber /@ xyPoints[[{a, b}]];\n         L = {L, C[i, j] -> \
\[ScriptCapitalM][[a, b]]}], {a, 9}, {b, 9}],\n     {k, Length[subSquares]}];\
\nSparseArray[makeMatrix @ Flatten[L], \[Lambda] {1, 1}, 0]]"
}], "Input"],

Cell[TextData[{
  "We unite the generation of the three matrices in the function ",
  StyleBox["sparseMatrixTriple", "MR"],
  "."
}], "Text"],

Cell["\<\
sparseMatrixTriple[] := makeSparseMatrix @@@
 {{nonDirichletVertexQ, \[ScriptCapitalS]\[ScriptCapitalM]}, \
{nonDirichletVertexQ, \[ScriptCapitalM]\[ScriptCapitalM]}, {robinVertexQ, \
\[ScriptCapitalB]\[ScriptCapitalM]}}\
\>", "Input"],

Cell["\<\
We obtain matrices of size 552\[Times]552 for the above \
discretization example.\
\>", "Text"],

Cell["Dimensions /@ sparseMatrixTriple[]", "Input"],

Cell[TextData[{
  "Next, we define some functions for the visualizations of the \
eigenfunctions. The function ",
  StyleBox["eigenFunctionListPlot3D", "MR"],
  " generates a 3D plot of the eigenfunction."
}], "Text"],

Cell[TextData[{
  StyleBox["(* z-coordinate for the 3D plot is eigenvector value *)", 
    "CodeComment"],
  "\nzCoordinate[{x_, y_}, evec_] := \n            If[nonDirichletVertexQ[{x, \
y}], evec[[vertexNumber[{x, y}]]], 0]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* array of z-coordinates *)", "CodeComment"],
  "\nvalueTable[evec_] := \nModule[{subsubSquarePoints = Table[{x, y}, {x, \
-1, 1, \[Delta]}, {y, -1, 1, \[Delta]}]},\n       Map[Append[#, \
zCoordinate[#, evec]]&, subsubSquarePoints, {-2}]]"
}], "Input"],

Cell[TextData[{
  "eigenFunctionListPlot3D[evec_] :=\nModule[{subsubSquarePolygons = \n       \
 Table[Polygon[{{x, y}, {x + \[Delta], y}, {x + \[Delta], y + \[Delta]}, {x, \
y + \[Delta]}}],\n        {x, -1, 1 - \[Delta], \[Delta]}, {y, -1, 1 - \
\[Delta], \[Delta]}] // Flatten[#, 1]&, polys},\n",
  StyleBox[" (* form four polygons for each subsquare *)", "CodeComment"],
  "\n polys = Map[{#[[1]], #[[2]], zCoordinate[#, evec]}&, \n             \
subsubSquarePolygons, {-2}];\n ",
  StyleBox[" (* make 3D graphics *)", "CodeComment"],
  "\n Graphics3D[{EdgeForm[], polys}, \n            PlotRange -> All, \
BoxRatios -> {1, 1, 0.4}]]"
}], "Input"],

Cell["\<\
For higher, more rapidly changing states, a contour plot is \
typically better suited for visualizations. This time, we show (by default) \
the absolute value of the eigenfunctions through gray levels and the nodal \
lines as thin red lines.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* values for cl homogeneously spaced contours *)", 
    "CodeComment"],
  "\nhomContours[data_, cl_] := \nWith[{\[Lambda] = Length[Flatten[data]]},\n \
   #[[Round[\[Lambda]/cl]]]& /@ Partition[Sort[Flatten[data]], \
Round[\[Lambda]/cl]]]"
}], "Input"],

Cell[TextData[{
  "eigenFunctionListContourPlot[evec_, f_:Abs] :=\nModule[{subsubSquarePoints \
= Table[{x, y}, {y, -1, 1, \[Delta]}, {x, -1, 1, \[Delta]}],\n        data1, \
data2, lcp1, lcp2},\n ",
  StyleBox["(* prepare data *)", "CodeComment"],
  "\n data1 =  Map[zCoordinate[#, evec]&, subsubSquarePoints, {-2}];\n data2 \
=  Map[f, data1, {2}];\n ",
  StyleBox["(* make graphics *)", "CodeComment"],
  "\n Block[{$DisplayFunction = Identity}, \n data1a = Take[data1, {2, -2}, \
{2, -2}];\n ",
  StyleBox["(* nodal lines *)", "CodeComment"],
  "\n lcp1 = ListContourPlot[data1a, PlotRange -> All, ContourLines -> True, \
\n                 ContourShading -> False, Contours -> {0},\n                \
 ContourStyle -> {Hue[0], Thickness[0.004]},\n                 MeshRange -> \
{{-1 + \[Delta], 1 - \[Delta]}, {-1 + \[Delta], 1 - \[Delta]}}];\n ",
  StyleBox["(* absolute value (or f of) the eigenfunctions *)", 
    "CodeComment"],
  "\n lcp2 = ListContourPlot[data2, PlotRange -> All, Frame -> True, \n       \
          ContourLines -> False, MeshRange -> {{-1, 1}, {-1, 1}},\n           \
      Contours -> homContours[data2, Round[Sqrt[Length[evec]]]],\n            \
     ContourStyle -> {Thickness[0.002]}];\n Show[{lcp2, lcp1, ",
  StyleBox["(* border *)", "CodeComment"],
  "\n       Graphics[{Thickness[0.01], RGBColor[0, 0, 1], \n                  \
Line[{{-1, -1}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}}]}]},\n      Frame -> \
False]]]"
}], "Input"],

Cell[TextData[{
  "Before implementing the animation, we visualize some example \
eigenfunctions for various parts of the square\[CloseCurlyQuote]s boundary \
having Robin boundary conditions. The function ",
  StyleBox["exampleBoundaryGraphics", "MR"],
  " generates the mass, stiffness, and boundary matrices, and solves the \
eigenvalue for the list of ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]values ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  StyleBox["s", "TI"],
  " for the lowest eigenvalues and for eigenvalues of approximate size ",
  StyleBox["shift", "TI"],
  ". The lowest eigenfunctions we display as 3D plots, and the higher ones as \
contour plots."
}], "Text"],

Cell[TextData[{
  "exampleBoundaryGraphics[robinCondition_, \[ScriptD]_, \[Alpha]s_, shift_] \
:=\nModule[{nEvs = 3, evOpts, A, B, Ar, evals, evecs},\n evOpts = \
Sequence[\"Arnoldi\", BasisSize -> 50, MaxIterations -> 10^4,\n               \
               Tolerance -> 10^-8];\n ",
  StyleBox["(* generate matrices *)", "CodeComment"],
  "\n makeVertexAssignments[\[ScriptD], robinCondition]; \n {A, B, Ar} = \
sparseMatrixTriple[];\n ",
  StyleBox["(* show problem discretized structure *)", "CodeComment"],
  "\n Show[Block[{$DisplayFunction = Identity}, discretizationGraphics[]],\n  \
    Frame -> False];\n ",
  StyleBox["(* show higher eigenfunctions for various \[Alpha]-values *)", 
    "CodeComment"],
  "\n Function[\[Alpha], Print[\"\[Alpha] = \", N @ \[Alpha]]; ABPair = N[{A \
+ \[Alpha]/(1 - \[Alpha]) Ar, B}];\n  ",
  StyleBox["(* calculate and show lowest eigenfunctions for various \
\[Alpha]-values *)", "CodeComment"],
  "\n  {evals, evecs} = Reverse /@ \n  Eigensystem[ABPair, 3, Method -> \
{evOpts, Shift -> 0}];\n  Show[GraphicsArray[eigenFunctionListPlot3D /@ \
evecs]];\n  ",
  StyleBox["(* calculate and show higher eigenfunctions for various \
\[Alpha]-values *)", "CodeComment"],
  "\n  {evals, evecs} = Reverse /@ \n  Eigensystem[ABPair, nEvs, Method -> \
{evOpts, Shift -> shift}];\n  Show[GraphicsArray[#]]& /@ \n      \
Partition[eigenFunctionListContourPlot[Abs[#]]& /@ evecs, 3]] /@ \[Alpha]s]"
}], "Input"],

Cell["\<\
In the first example, the middle third of one edge has Robin \
boundary conditions.\
\>", "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := y == 1 && -1/3 < x < 1/3;
exampleBoundaryGraphics[robinPointQ, 50, {0, 0.5, 0.99}, 200]\
\>", "Input"],

Cell["\<\
In the second example, one half of each edges has Robin boundary \
conditions. This time, we show higher states.\
\>", "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := x == -1 && y < 0 || x == +1 && y > 0 ||
                         y == -1 && x > 0 || y == +1 && x < 0;
exampleBoundaryGraphics[robinPointQ, 50, {0, 0.5, 0.99}, 600]\
\>", "Input"],

Cell["\<\
In the third example, two diagonally opposite half edge has Robin \
boundary conditions. \
\>", "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := x == -1 && y < 0 || x == +1 && y > 0;
exampleBoundaryGraphics[robinPointQ, 50, {0, 0.5, 0.99}, 600]\
\>", "Input"],

Cell["\<\
In the fourth example, the middle thirds of all four edges have \
Robin boundary conditions. \
\>", "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := 
     x == -1 && -1/3 < y < 1/3 || x == +1 && -1/3 < y < 1/3 ||
     y == -1 && -1/3 < x < 1/3 || y == +1 && -1/3 < x < 1/3;
exampleBoundaryGraphics[robinPointQ, 50, {0, 0.5, 0.99}, 600]\
\>", "Input"],

Cell[TextData[{
  "A typical feature of all of the last examples are the existence of \
relatively large areas of uniform patterns [",
  
  CounterBox["BibliographyCounter", "Bogomolny04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bogomolny04",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell["\<\
And in the last example, we assign the Robin boundary condition \
randomly to all vertices.\
\>", "Text"],

Cell[TextData[{
  "robinPointQ[{x_, y_}] := randomRobinValue[{x, y}];\n",
  StyleBox["(* remember which points are Robin-boundary points *)", 
    "CodeComment"],
  "\nrandomRobinValue[{x_, y_}] := \n      randomRobinValue[{x, y}] = \
Random[Integer] === 0\nexampleBoundaryGraphics[robinPointQ, 50, {0, 0.5, \
0.99}, 600]"
}], "Input"],

Cell[TextData[{
  "Now, we return to our animation problem. To get an idea where and how fast \
the transition from Dirichlet to Neumann boundary condition is reflected in \
the eigensystems, we use a relatively crude discretization and calculate and \
visualize the lowest eigenvalues. We parametrize ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  " through ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", 
          RowBox[{"1", "-", 
            SuperscriptBox["10", 
              SubscriptBox["\[Alpha]", "E"]]}]}], TraditionalForm]]],
  " to easily span a large range of ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]values."
}], "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := (0 < x <= 1 && y == 1) || 
                         (0 < y <= 1 && x == 1)
makeVertexAssignments[7, robinPointQ];
{A, B, Ar} = sparseMatrixTriple[];
Dimensions[A]\
\>", "Input"],

Cell["\<\
Show[Graphics[{PointSize[0.003],
Table[\[Alpha] = 1 - 10^\[Alpha]Exp;
     Point[{\[Alpha]Exp, #}]& /@ 
     (Take[Eigenvalues[N @ Normal[{A + \[Alpha]/(1 - \[Alpha]) Ar, B}]], \
-12]/Pi^2),  
      {\[Alpha]Exp, 0, -2.5, -1/200}]}], Frame -> True, PlotRange -> {-1, 5}]\
\
\>", "Input"],

Cell[TextData[{
  "We see that most of the transition happens for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"-", "2"}], "<", 
          SubscriptBox["\[Alpha]", "E"], "<", "0"}], TraditionalForm]]],
  ". For Neumann boundary conditions (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "0"}], TraditionalForm]]],
  "), all states are nondegenerate, for Dirichlet boundary conditions (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "\[Rule]", "1"}], TraditionalForm]]],
  "), states become degenerate. We also see level crossing (this is possible \
because it is a 2D problem)."
}], "Text"],

Cell[TextData[{
  "For the actual animation we will use ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["60", "2"], TraditionalForm]]],
  " subsquares. This results in matrices of size ",
  Cell[BoxData[
      FormBox[
        RowBox[{"14280", "\[Times]", "14280"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
robinPointQ[{x_, y_}] := (0 < x <= 1 && y == 1) || 
                         (0 < y <= 1 && x == 1)
makeVertexAssignments[60, robinPointQ];
{A, B, Ar} = sparseMatrixTriple[];
Dimensions[A]\
\>", "Input"],

Cell["Here are the points visualized.", "Text"],

Cell["discretizationGraphics[]", "Input"],

Cell[TextData[{
  "We will use states with energies (",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "\[Hyphen]values) around 1010. To make sure that the calculated \
eigensystems are reliable, we compare the calculate spectrum for the nearly\
\[Hyphen]Dirichlet case of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "0.999999999"}], TraditionalForm]]],
  ". The eigenvalues deviate about 0.1% from the exact values."
}], "Text"],

Cell["\<\
\[Alpha] = 1 - 10.^-9;
evals = Eigenvalues[N @ {A + \[Alpha]/(1 - \[Alpha]) Ar, B}, 12, Method -> \
{\"Arnoldi\",   
                                   BasisSize -> 240, MaxIterations -> 10^4,
                                   Tolerance -> 12, Shift -> 1010}]/(Pi^2/4) \
// Reverse\
\>", "Input"],

Cell["\<\
Select[Sort[Flatten[Table[k^2 + l^2, {k, 50}, {l, 50}]]], (Min[%] - \
3 < # < Max[%] + 3)&]\
\>", "Input"],

Cell[TextData[{
  "Now, we can implement the animation for varying ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ". For each ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", we calculate a few eigensystems. Because the eigenvalues of the states \
change with ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", we use a dynamically averaged value for the ",
  StyleBox["Shift", "MR"],
  " option of ",
  StyleBox["Eigensystem", "MR"],
  ". To select the \[OpenCurlyDoubleQuote]corresponding\
\[CloseCurlyDoubleQuote] eigenvectors, we cannot rely on the eigenvalues \
because they become degenerate. So, we form the overlap between the last \
eigenvector and the newly calculated eigenvectors for the next value of ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ". The state with the highest overlap is selected. We will show the ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]dependence for three states."
}], "Text"],

Cell["We start with the Neumann case.", "Text"],

Cell[TextData[{
  StyleBox["(* number of eigensystems to calculate for each value of \[Alpha] \
*)", "CodeComment"],
  " o = 25;\nABPair = {A, B};\neigensystem = Eigensystem[ABPair // N, o, \
Method -> {\"Arnoldi\",   \n                                   BasisSize -> \
240, MaxIterations -> 10^4,\n                                   Tolerance -> \
10^-8, Shift -> 1010}];\n                                   \ncurrentEvals = \
eigensystem[[1]][[{14, 13, 12}]];\ncurrentEvecs = eigensystem[[2]][[{14, 13, \
12}]];"
}], "Input"],

Cell[TextData[{
  "Next, we loop over the ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]values and store the resulting contour plots in the list ",
  StyleBox["animationFrames", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "animationFrames[framesToShow_] := \nWith[{allFrames = 60},\nModule[{l1 = \
Table[\[Alpha]Exp, {\[Alpha]Exp, 0, 3, 1/allFrames}], l2,\n        \
\[Alpha]ExpValuesToShow, overlaps, maxOverlapPositions},\n",
  StyleBox["(* which \[Alpha]-values to display *)", "CodeComment"],
  "\n\[Alpha]ExpValuesToShow = If[framesToShow === All, l1, \n    l2 = Table[\
\[Alpha]Exp, {\[Alpha]Exp, 0, 3, 3/framesToShow}];\n    Function[s, \
Sort[{N[Abs[s - #]], #}& /@ l1][[1, 2]]] /@ l2]; \nDo[\[Alpha] = 1 - 10^-\
\[Alpha]Exp;\n   ",
  StyleBox["(* calculate eigenvalues and eigenvectors *)", "CodeComment"],
  "\n   ABPair = {A + \[Alpha]/(1 - \[Alpha]) Ar, B};\n   currentShift = Plus \
@@ currentEvals/Length[currentEvals];\n   eigensystem = Eigensystem[ABPair // \
N, o, Method -> {\"Arnoldi\",   \n                                 BasisSize \
-> 240, MaxIterations -> 10^4,\n                                 Tolerance -> \
10^-8, Shift -> currentShift}];\n   ",
  StyleBox["(* form overlaps with last set of eigenvectors *)", 
    "CodeComment"],
  "\n   overlaps = Table[Abs[currentEvecs[[k]].#]& /@ eigensystem[[2]], {k, \
3}]; \n   ",
  StyleBox["(* select \[Alpha]-continued eigenvectors *)", "CodeComment"],
  "\n   maxOverlapPositions = Flatten[Position[#, Max[#]]& /@ overlaps];\n   \
{currentEvals, currentEvecs} = #[[maxOverlapPositions]]& /@ eigensystem;\n   \
",
  StyleBox["(* store eigenvalues and overlaps *)", "CodeComment"],
  "\n   evData[\[Alpha]Exp] = {currentEvals, currentEvecs};\n   overlapData[\
\[Alpha]Exp] = {overlaps, maxOverlapPositions};\n   ",
  StyleBox["(* make contour plots of eigenfunctions *)", "CodeComment"],
  "\n   If[MemberQ[\[Alpha]ExpValuesToShow, \[Alpha]Exp],\n    \
Show[GraphicsArray[eigenFunctionListContourPlot /@ currentEvecs],\n        \
PlotLabel -> N[\[Alpha]Exp]]],\n   {\[Alpha]Exp, 0, 3, 3/allFrames}]]];"
}], "Input"],

Cell["animationFrames[5]", "Input"],

Cell[TextData[{
  "Here are some of the eigenfunctions for various ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "     ",
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Show", " ", "Animation"}],
        ButtonData:>{
          FrontEnd`FileName[ {"Animations"}, "4_1_PolygonFolding.nb"], None},
        ButtonStyle->"ShowAnimationButton"]]]
}], "ProgramLabel"],

Cell["animationFrames[All]", "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "The following two graphics show the ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]dependence of the eigenvalues (left) and the  ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]dependence of the overlaps for the three selected states. Overall \
the overlap integrals are nearly 1, but show clear dips around ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "\[Hyphen]values where two eigenvalues become nearly degenerate."
}], "Text"],

Cell["\<\
With[{colors = {RGBColor[1, 0, 0], RGBColor[0, 1, 0], RGBColor[0, \
0, 1]}},
 Show[GraphicsArray[
 {Graphics[Transpose[{colors,
             Line /@ Transpose[Table[{\[Alpha]Exp, #}& /@ \
evData[\[Alpha]Exp][[1]],
                                     {\[Alpha]Exp, 0, 3, 3/60}]]}], Frame -> \
True],
  Graphics[Transpose[{colors,
            Line /@ Transpose[Table[{\[Alpha]Exp, #}& /@ \
(Table[#1[[j]][[#2[[j]]]], 
            {j, 3}]& @@ overlapData[\[Alpha]Exp]), {\[Alpha]Exp, 0, 2, \
3/60}]]}], 
           Frame -> True]}]]]\
\>", "Input"],

Cell[TextData[{
  "For the eigenfunctions of an equilateral triangle with Robin boundary \
conditions, see [",
  
  CounterBox["BibliographyCounter", "McCartin04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"McCartin04",
    ButtonStyle->"Hyperlink"],
  "]. For isospectral domains with mixed Dirichlet and Neumann boundary \
conditions, see [",
  
  CounterBox["BibliographyCounter", "Jakobson04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Jakobson04",
    ButtonStyle->"Hyperlink"],
  "]. For general considerations of the mixed boundary value case, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Dowker04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Dowker04",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "16.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Generalized WKB Approximation"
}], "ExerciseHeading"],

Cell[TextData[{
  "Recently a divergence\[Hyphen]free generalization of the classical WKB \
approximation was suggested [",
  
  CounterBox["BibliographyCounter", "Hyouguchi04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hyouguchi04",
    ButtonStyle->"Hyperlink"],
  "]. Starting from the classical Schr\[ODoubleDot]dinger equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"-", 
              RowBox[{
                SuperscriptBox["\[Psi]", "\[DoublePrime]"], "(", "x", ")"}]}],
             "+", 
            RowBox[{
              RowBox[{"V", "(", "x", ")"}], 
              RowBox[{"\[Psi]", "(", "x", ")"}]}]}], "=", 
          RowBox[{"\[CurlyEpsilon]", " ", 
            RowBox[{"\[Psi]", "(", "x", ")"}]}]}], TraditionalForm]]],
  ", one obtains after making the ansatz ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Psi]", "(", "x", ")"}], "~", 
          RowBox[{"exp", "(", 
            RowBox[{"\[CurlyPhi]", "(", "x", ")"}], ")"}]}], 
        TraditionalForm]]],
  " the Riccati equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{
              SuperscriptBox["\[CurlyPhi]", "\[DoublePrime]"], "(", "x", 
              ")"}], "+", 
            SuperscriptBox[
              RowBox[{
                SuperscriptBox["\[CurlyPhi]", "\[Prime]"], "(", "x", ")"}], 
              "2"]}], "=", 
          RowBox[{
            SubscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]"], "(", "x", 
            ")"}]}], TraditionalForm]]],
  ", where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]"], "(", "x", 
            ")"}], "=", 
          RowBox[{"\[CurlyEpsilon]", "-", 
            RowBox[{"V", "(", "x", ")"}]}]}], TraditionalForm]]],
  ". Differentiating this equation repeatedly and substituting the second \
derivatives back after each differentiation step yields an equation of the \
form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["\[CurlyPhi]", 
              RowBox[{"(", "N", ")"}]], "(", "x", ")"}], "+", 
          RowBox[{
            SubscriptBox["\[ScriptP]", "N"], "(", 
            RowBox[{
              RowBox[{
                SuperscriptBox["\[CurlyPhi]", "\[Prime]"], "(", "x", ")"}], 
              ",", 
              RowBox[{
                SubsuperscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]", 
                  RowBox[{"(", "k", ")"}]], "(", "x", ")"}]}], ")"}]}], 
        TraditionalForm]]],
  ".\nThe quantization condition of the ",
  Cell[BoxData[
      FormBox["N", TraditionalForm]]],
  "th order generalized WKB approximation is then"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          FractionBox["1", 
            RowBox[{"2", "\[Pi]", " ", "i"}]], 
          RowBox[{
            UnderscriptBox["\[ContourIntegral]", "\[ScriptCapitalC]"], 
            RowBox[{
              RowBox[{"y", "(", 
                RowBox[{
                  SubsuperscriptBox["\[ScriptCapitalK]", 
                    SubscriptBox["\[CurlyEpsilon]", "n"], 
                    RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}], "d", 
              "\[InvisibleSpace]", "x"}]}]}], "=", 
        RowBox[{"n", "+", "1", "-", 
          RowBox[{
            FractionBox["1", "2"], 
            SubscriptBox["\[Delta]", 
              RowBox[{"N", ",", "2"}]]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "where ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "(", 
          RowBox[{
            SubsuperscriptBox["\[ScriptCapitalK]", 
              SubscriptBox["\[CurlyEpsilon]", "n"], 
              RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}], 
        TraditionalForm]]],
  " is a solution of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[ScriptP]", "N"], "(", 
            RowBox[{
              RowBox[{"y", "(", 
                RowBox[{
                  SubsuperscriptBox["\[ScriptCapitalK]", 
                    SubscriptBox["\[CurlyEpsilon]", "n"], 
                    RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}], ",", 
              RowBox[{
                SubsuperscriptBox["\[ScriptCapitalK]", 
                  SubscriptBox["\[CurlyEpsilon]", "n"], 
                  RowBox[{"(", "k", ")"}]], "(", "x", ")"}]}], ")"}], "=", 
          "0"}], TraditionalForm]]],
  " and the ",
  Cell[BoxData[
      FormBox["N", TraditionalForm]]],
  "\[Hyphen]dependence of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyEpsilon]", "n"], TraditionalForm]]],
  " is not shown explicitly."
}], "Text"],

Cell[TextData[{
  "The integration path is enclosing two branch points along the real axis, \
and no other singularities of any kind and the sheet has to be chosen in such \
a way, that ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "=", 
          RowBox[{"y", "(", "x", ")"}]}], TraditionalForm]]],
  " is real\[Hyphen]valued as ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "\[Rule]", "\[Infinity]"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "For the harmonic oscillator ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]"], "(", "x", 
            ")"}], "=", 
          RowBox[{"\[CurlyEpsilon]", "-", 
            SuperscriptBox["x", "2"]}]}], TraditionalForm]]],
  ", check if the first eight quantization conditions result in the well\
\[Hyphen]known ground state eigenvalue ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", "0"], "=", "1"}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by constructing the multiple\[Hyphen]differentiated Schr\
\[ODoubleDot]dinger equation for the phase ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyPhi]", "(", "x", ")"}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell[TextData[{
  StyleBox["(* Riccati for of the Schr\[ODoubleDot]dinger equation *)", 
    "CodeComment"],
  "\neqSR = \[CurlyPhi]''[x] + \[CurlyPhi]'[x]^2 + \[ScriptCapitalK][x];\n",
  StyleBox["(* replace second derivative with first and \[ScriptCapitalK] *)",
     "CodeComment"],
  "\nrule = Solve[eqSR == 0, Derivative[2][\[CurlyPhi]][x]][[1]];\n",
  StyleBox["(* n-th order equation *)", "CodeComment"],
  "\neq[\[ScriptCapitalN]_] := Nest[(D[#, x] /. rule)&, eqSR, \
\[ScriptCapitalN] - 2] // Expand"
}], "Input"],

Cell["Here are the first few differential equations.", "Text"],

Cell["Table[eq[\[ScriptCapitalN]], {\[ScriptCapitalN], 2, 6}]", "Input"],

Cell["\<\
The integrand of the quantization condition is easily obtained from \
the last equations by ignoring the highest derivative and replacing the first \
derivative by a new variable.\
\>", "Text"],

Cell["\<\
ae[\[ScriptCapitalN]_] := Collect[(#/Coefficient[#, y[x], \
\[ScriptCapitalN]])&[
                  eq[\[ScriptCapitalN]]  /. {Derivative[\[ScriptCapitalN]][\
\[CurlyPhi]][x] -> 0, 
                  \[CurlyPhi]'[x] -> y[x]}], y[x], Factor]\
\>", "Input"],

Cell["Here are the first few integrands.", "Text"],

Cell["\<\
Table[ae[\[ScriptCapitalN]], {\[ScriptCapitalN], 2, 6}] /. y\
\[ScriptCapitalK]_[x] -> y\[ScriptCapitalK] \
\>", "Input"],

Cell[TextData[{
  "We now specialize to the harmonic oscillator potential. This is value of \
",
  Cell[BoxData[
      FormBox["\[ScriptCapitalK]", TraditionalForm]]],
  " for the harmonic oscillator expressed as a pure function."
}], "Text"],

Cell["\[ScriptCapitalK]Function[\[CurlyEpsilon]_, x_] := \[CurlyEpsilon] - \
x^2", "Input"],

Cell["\<\
These are the resulting harmonic oscillator quantization \
integrands.\
\>", "Text"],

Cell["\<\
ahoQC[\[ScriptCapitalN]_, \[CurlyEpsilon]_, {\[Xi]_, \[Eta]_}] := \
ae[\[ScriptCapitalN]] /. 
          \[ScriptCapitalK] -> Function[x, \
Evaluate[\[ScriptCapitalK]Function[\[CurlyEpsilon], x]]] /. {x -> \[Xi], y[x] \
-> \[Eta]}\
\>", "Input"],

Cell["\<\
Table[ahoQC[\[ScriptCapitalN], \[CurlyEpsilon], {x, y}], {\
\[ScriptCapitalN], 2, 6}]\
\>", "Input"],

Cell[TextData[{
  "For a given ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  ", we must calculate the branch points and other singularities in the \
complex ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]plane for a given quantization condition integrand of order ",
  Cell[BoxData[
      FormBox["N", TraditionalForm]]],
  " (which is just an algebraic curve). Two branch points are on the real \
axis and are needed for the contour integration. But we also need the \
locations of the other singularities to make sure that we do not enclose any \
of them in the contour. The function ",
  StyleBox["branchPointsAndPoles", "MR"],
  " calculates the branchpoints and other singularities for a given \
polynomial in ",
  Cell[BoxData[
      FormBox["w", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "branchPointsAndPoles[poly_, {w_, z_}] := \nModule[{bpSol, branchPoints, \
poly1, singularityCondition, singularities},\n ",
  StyleBox["(* branch points as multiple roots that connect sheets *)", 
    "CodeComment"],
  "\n bpSol = Solve[Resultant[poly, D[poly, w], w] == 0, z];\n branchPoints = \
N[#, 50]& @ If[bpSol == {}, {}, z /. bpSol];\n ",
  StyleBox["(* all singularities *)", "CodeComment"],
  "\n poly1 = poly /. w -> w[z];\n singularityCondition = \
Numerator[Together[(1/D[w[z], z] /. \n                          \
Solve[D[poly1, z] == 0, D[w[z], z]][[1]])]];\n sSol = \
Solve[Resultant[singularityCondition, poly1, w[z]] == 0, z];\n singularities \
= N[#, 50]& @ If[sSol == {}, {}, z /. sSol];\n ",
  StyleBox["(* poles are non-branch point singularities *)", "CodeComment"],
  "\n {N[branchPoints, 30], \n  Complement[N[singularities, 30], \
N[branchPoints, 30]]}]"
}], "Input"],

Cell[TextData[{
  "A quick look at the branch points in the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"Re", "(", "y", ")"}], TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox[
        RowBox[{"Im", "(", "y", ")"}], TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  "\[Hyphen]space. We see multiple branch points along the real axis for \
larger ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "Show[GraphicsArray[#]]& /@ Partition[\nTable[",
  StyleBox["(* complex x-planes as a function of \[CurlyEpsilon] vertically \
*)", "CodeComment"],
  "\nGraphics3D[Table[{Hue[0.8 \[CurlyEpsilon]/2], Point[{Re[#], Im[#], \
\[CurlyEpsilon]}]& /@ \n                  branchPointsAndPoles[ahoQC[\
\[ScriptCapitalN], \[CurlyEpsilon], {x, y}], {y, x}][[1]]},\n                 \
 {\[CurlyEpsilon], 0, 2, 1/50}], PlotRange -> All, BoxRatios -> {1, 1, 1},\n  \
        PlotLabel -> \" \[ScriptCapitalN] = \" <> \
ToString[\[ScriptCapitalN]]], {\[ScriptCapitalN], 2, 7}], 2]"
}], "Input"],

Cell[TextData[{
  "To calculate the contour integral ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[ScriptCapitalI]", "n"], "=", 
          RowBox[{
            SubscriptBox["\[ContourIntegral]", "\[ScriptCapitalC]"], 
            RowBox[{
              RowBox[{
                SubscriptBox["\[ScriptP]", "n"], "(", 
                RowBox[{"y", ",", 
                  RowBox[{
                    
                    SubsuperscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]", 
                      
                      RowBox[{"(", "k", ")"}]], "(", "x", ")"}]}], ")"}], "d",
               "\[InvisibleSpace]", "x"}]}]}], TraditionalForm]]],
  " efficiently, and to avoid any problems with crossing branch cuts, we will \
not use ",
  StyleBox["NIntegrate", "MR"],
  ", but instead solve the differential equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"\[PartialD]", 
              RowBox[{
                SubscriptBox["\[ScriptCapitalI]", "n"], "(", "t", ")"}]}], 
            RowBox[{"\[PartialD]", "t"}]}], "=", 
          RowBox[{"y", "(", 
            RowBox[{
              SubsuperscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]", 
                RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}]}], 
        TraditionalForm]]],
  " along the contour ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalC]", TraditionalForm]]],
  " parametrized by ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  ". Because the integrand is a solution of an algebraic equation (with ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " as the second variable and ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  " as a parameter), we calculate ",
  Cell[BoxData[
      FormBox[
        RowBox[{"y", "(", 
          RowBox[{
            SubsuperscriptBox["\[ScriptCapitalK]", "\[CurlyEpsilon]", 
              RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}], 
        TraditionalForm]]],
  " by solving the differential equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"\[PartialD]", 
              RowBox[{
                SubscriptBox["\[ScriptP]", "N"], "(", 
                RowBox[{
                  RowBox[{"y", "(", 
                    RowBox[{
                      SubsuperscriptBox["\[ScriptCapitalK]", 
                        SubscriptBox["\[CurlyEpsilon]", "n"], 
                        RowBox[{"(", "k", ")"}]], "(", "x", ")"}], ")"}], ",",
                   
                  RowBox[{
                    SubsuperscriptBox["\[ScriptCapitalK]", 
                      SubscriptBox["\[CurlyEpsilon]", "n"], 
                      RowBox[{"(", "k", ")"}]], "(", "x", ")"}]}], ")"}]}], 
            "/", 
            RowBox[{"\[PartialD]", "x"}]}], "=", "0"}], TraditionalForm]]],
  " along the curve ",
  Cell[BoxData[
      FormBox["\[ScriptCapitalC]", TraditionalForm]]],
  ". The two differential equations can be solved simultaneously. This \
ensures automatically that we are always on the same sheet. No branch cuts \
even exist in this approach, just branch points which have to be included or \
excluded in the contour. "
}], "Text"],

Cell[TextData[{
  "Now, we have to carry out integration numerically along an ellipse \
enclosing (the) two branch points on the real axis and having half axes ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["b", TraditionalForm]]],
  ". We start on the real axis with real argument for ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  ". There might be more than one choice for the ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  " values, as well for the branch points, so we try all possible ones. (The \
condition ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["y", "n"], "(", 
            RowBox[{"x", "\[Rule]", "\[Infinity]"}], ")"}], "\[Rule]", 
          "\[Infinity]"}], TraditionalForm]]],
  " does not uniquely sort out one sheet from the Riemann surface; this \
condition can be fulfilled on more than one sheet.) The function ",
  StyleBox["makeNDSolveInput", "MR"],
  " sets up the differential equations to be solved."
}], "Text"],

Cell[TextData[{
  StyleBox["(* select positive real solutions *)", "CodeComment"],
  "\npositivSolutions[poly_, y_] :=  \nSelect[y /. Solve[poly == 0, y], \
(Im[#] == 0 && Re[#] > 0)&]"
}], "Input"],

Cell[TextData[{
  "makeNDSolveInput[\[ScriptCapitalN]_, \[CurlyEpsilon]_, {t_, \[ScriptY]_, \
\[ScriptCapitalI]_}] :=\nModule[{(*branchPoints, poles, realLineBranchPoints, \
\n        smallestVerticalDistanceSingularity, bE, aEs, \[Xi], \
\[ScriptY]Ints, a, b*)},\n ",
  StyleBox["(* calculate branch points and potential poles *)", 
    "CodeComment"],
  "\n {branchPoints, poles} = branchPointsAndPoles[ahoQC[\[ScriptCapitalN], \
\[CurlyEpsilon], {x, y}], {y, x}];\n  realLineBranchPoints = \
Select[branchPoints, (Im[#] == 0 && Re[#] > 0)&]; \n  \
smallestVerticalDistanceSingularity = \n          \
Min[Abs[Select[Flatten[{branchPoints, poles}], Im[#] != 0&]]];\n",
  StyleBox[" (* ellipse parameters so that only the two branch points\n    on \
the real axis are enclosed *)", "CodeComment"],
  "\n bE =  If[smallestVerticalDistanceSingularity == Infinity, 1, \n         \
 smallestVerticalDistanceSingularity/10];\n aEs = Plus @@@ \
Partition[Append[realLineBranchPoints, \n                                 2 \
Max[realLineBranchPoints]], 2, 1]/2;\n \[Xi][\[Tau]_] := a Cos[\[Tau]] + I b \
Sin[\[Tau]];\n",
  StyleBox[" (* differential equations for y_N and quantization integral\n    \
along the ellipse *)", "CodeComment"],
  "\n odes = {D[\[ScriptCapitalI][x], x] == \[ScriptY][x], D[ahoQC[\
\[ScriptCapitalN], \[CurlyEpsilon], {x, \[ScriptY][x]}], x] == 0} /. \n       \
  Derivative[1][f_][x] :> 1/D[\[Xi][t], t] Derivative[1][f][t] /.\n         {\
\[ScriptY][x] -> \[ScriptY][t], \[ScriptCapitalI][x] -> \[ScriptCapitalI][t]} \
/. x -> \[Xi][t];\n ",
  StyleBox["(* add initial conditions so that y_N is real positive on the \
real axis *)", "CodeComment"],
  "\n NDSolveFirstArguments = Flatten[#, 1]& @ \n ",
  StyleBox["(* all possible ellipses *)", "CodeComment"],
  "\n Table[\[ScriptY]Ints = positivSolutions[ahoQC[\[ScriptCapitalN], \
\[CurlyEpsilon], {aEs[[k]], y}], y];\n       Table[print[\"{aE, y0} = \", \
{aEs[[k]], \[ScriptY]Ints[[i]]} // N];\n             Join[odes /. {a -> \
aEs[[k]], b -> bE}, \n                  {\[ScriptCapitalI][0] == 0, \
\[ScriptY][0] == \[ScriptY]Ints[[i]]}], {i, Length[\[ScriptY]Ints]}],\n       \
{k, Length[aEs]}]]"
}], "Input"],

Cell[TextData[{
  "Here is one of the resulting ODE systems for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"N", "=", "3"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["makeNDSolveInput[3, 1, {t, y1, I1}][[-1]] // N", "Input"],

Cell[TextData[{
  "It remains to carry out the numerical integration of the differential \
equations. For a given quantization order, and a given ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  ", we calculate the quantization integrals. We use high\[Hyphen]precision \
arithmetic to solve the differential equations to ensure the correctness of \
the result. Calculating the left\[Hyphen]hand side of the quantization \
conditions should, for the ground state ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", "0"], "=", "1"}], 
        TraditionalForm]]],
  ", yield the result ",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "/", "2"}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"N", "=", "2"}], TraditionalForm]]],
  ", and 1 else. (If we would not know the energies ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyEpsilon]", "n"], TraditionalForm]]],
  ", then we would have to carry out an additional root finding process.)"
}], "Text"],

Cell[TextData[{
  "contourIntegralValues[\[ScriptCapitalN]_, \[CurlyEpsilon]_] :=\n\
Module[{odes, ndsols, y1, I1},\n",
  StyleBox[" (* y_N and quantization integral ODEs *)", "CodeComment"],
  "\n odes = makeNDSolveInput[\[ScriptCapitalN], \[CurlyEpsilon], {t, y1, \
I1}];\n ",
  StyleBox["(* make sure numerical solution is reliable *)", "CodeComment"],
  "\n ndsols = NDSolve[#, {y1, I1}, {t, 0, -2Pi},\n                  \
PrecisionGoal -> 15, WorkingPrecision -> 25]& /@ odes;\n I1[-2Pi]/(2Pi I) /. \
ndsols]"
}], "Input"],

Cell["\<\
Here is the classical WKB case\[LongDash]we obtain the value 1/2.\
\
\>", "Text"],

Cell["contourIntegralValues[2, 1] // Chop[#, 10^-8]&", "Input"],

Cell[TextData[{
  "We obtain the value 1 for exactly one pair of branch points for the cases \
",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"N", "=", "3"}], ",", "4", ",", "5", ",", "6"}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["contourIntegralValues[3, 1] // Chop[#, 10^-8]&", "Input"],

Cell["contourIntegralValues[4, 1] // Chop[#, 10^-8]&", "Input"],

Cell["contourIntegralValues[5, 1] // Chop[#, 10^-8]&", "Input"],

Cell["contourIntegralValues[6, 1] // Chop[#, 10^-8]&", "Input"],

Cell[TextData[{
  "But the cases ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"N", "=", "7"}], ",", "8"}], TraditionalForm]]],
  " do not give a 1 for any of the contours. The \[OpenCurlyDoubleQuote]best\
\[CloseCurlyDoubleQuote] contours give a result that is off by a few \
percent."
}], "Text"],

Cell["contourIntegralValues[7, 1] // Chop[#, 10^-8]&", "Input"],

Cell["contourIntegralValues[8, 1] // Chop[#, 10^-8]&", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "17.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Multi\[Hyphen]Dimensional Integral"
}], "ExerciseHeading"],

Cell["Calculate the value of the integral", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        SubscriptBox["\[ScriptCapitalI]", "n"], "=", 
        RowBox[{
          StyleBox[
            UnderoverscriptBox["\[Integral]", "0", "1"],
            SpanMinSize->3,
            SpanMaxSize->3], 
          RowBox[{
            StyleBox[
              UnderoverscriptBox["\[Integral]", "0", "1"],
              SpanMinSize->3,
              SpanMaxSize->3], 
            RowBox[{
              StyleBox["\[Ellipsis]",
                SpanMinSize->3,
                SpanMaxSize->3], 
              RowBox[{
                StyleBox[
                  UnderoverscriptBox["\[Integral]", "0", "1"],
                  SpanMinSize->3,
                  SpanMaxSize->3], 
                RowBox[{
                  StyleBox[
                    UnderoverscriptBox["\[Integral]", "0", "1"],
                    SpanMinSize->3,
                    SpanMaxSize->3], 
                  RowBox[{
                    SuperscriptBox["e", 
                      RowBox[{"\[LeftBracketingBar]", 
                        RowBox[{"1", "-", 
                          SubscriptBox["x", "n"]}], 
                        "\[RightBracketingBar]"}]], 
                    SuperscriptBox["e", 
                      RowBox[{"\[LeftBracketingBar]", 
                        RowBox[{
                          SubscriptBox["x", "n"], "-", 
                          SubscriptBox["x", 
                            RowBox[{"n", "-", "1"}]]}], 
                        "\[RightBracketingBar]"}]], "\[Ellipsis]", " ", 
                    SuperscriptBox["e", 
                      RowBox[{"\[LeftBracketingBar]", 
                        RowBox[{
                          SubscriptBox["x", "3"], "-", 
                          SubscriptBox["x", "3"]}], 
                        "\[RightBracketingBar]"}]], " ", 
                    SuperscriptBox["e", 
                      RowBox[{"\[LeftBracketingBar]", 
                        RowBox[{
                          SubscriptBox["x", "2"], "-", 
                          SubscriptBox["x", "1"]}], 
                        "\[RightBracketingBar]"}]], 
                    SuperscriptBox["e", 
                      RowBox[{"\[LeftBracketingBar]", 
                        RowBox[{
                          SubscriptBox["x", "1"], "-", "0"}], 
                        "\[RightBracketingBar]"}]], "d", "\[InvisibleSpace]", 
                    
                    SubscriptBox["x", "n"], "d", "\[InvisibleSpace]", 
                    SubscriptBox["x", 
                      RowBox[{"n", "-", "1"}]], "\[Ellipsis]", " ", "d", 
                    "\[InvisibleSpace]", 
                    SubscriptBox["x", "2"], "d", "\[InvisibleSpace]", 
                    SubscriptBox["x", "1"]}]}]}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", "\[LessEqual]", "n", "\[LessEqual]", "10"}], 
        TraditionalForm]]],
  ". Is it possible to calculate ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "100"], TraditionalForm]]],
  "?"
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start by defining the integrand and the integration region iterators \
for a given value of ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "."
}], "ExerciseSubgroup"],

Cell["\<\
integrand[n_] := Product[Exp[Abs[x[k] - x[k - 1]]], {k, 1, n + 1}] \
/.
                                         {x[0] -> 0, x[n + 1] -> 1};
                                         
iterators[n_] := Table[{x[k], 0, 1}, {k, n}];\
\>", "Input"],

Cell[TextData[{
  "Here is the resulting integral for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "4"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["integrand[4]", "Input"],

Cell["\<\
(HoldForm[Integrate[##]]& @@ {integrand[6], Sequence @@ \
iterators[6]}) /.
                               x[k_] :> Subscript[x, k] // \
TraditionalForm\
\>", "Input"],

Cell[TextData[{
  "The built\[Hyphen]in ",
  StyleBox["Integrate", "MR"],
  " can do such integrals, but they are quite slow."
}], "Text"],

Cell["ReleaseHold[%] // Timing", "Input"],

Cell[TextData[{
  "The time required to calculate these integrals grows quite fast with ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ", so obtaining a value for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "10"}], TraditionalForm]]],
  " seems not possible through a direct call to ",
  StyleBox["Integrate", "MR"],
  ". So, we will implement our own integration routine for this special \
integral. We will split each absolute value into two parts that do not \
contain absolutes values anymore (the first and last exponents need no \
splitting, they have constant sign over the integration region ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0", ",", "1"}], "]"}], TraditionalForm]]],
  "). This gives us ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["2", 
          RowBox[{"n", "-", "1"}]], TraditionalForm]]],
  " ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "\[Hyphen]dimensional integrals."
}], "Text"],

Cell[TextData[{
  StyleBox["(* thread over sums *)", "CodeComment"],
  "\nremoveAbs[p_Plus, k_] := removeAbs[#, k]& /@ p\n\n",
  StyleBox["(* split integration region into two for each variable *)", 
    "CodeComment"],
  "\nremoveAbs[integrate[body_, iterators_], k_] :=\nWith[{",
  StyleBox["(* first and last exponent need only one region *)", 
    "CodeComment"],
  "\n      body1 = body /. {Abs[x[1]] -> x[1], \n              Abs[1 - \
x[Length[iterators]]] -> 1 - x[Length[iterators]]}},\n integrate[body1 /. \
Abs[x[k] - x[k - 1]] :> x[k - 1] - x[k], \n           MapAt[{x[k], 0, x[k - \
1]}&, iterators, k]] +\n integrate[body1 /. Abs[x[k] - x[k - 1]] :> x[k] - \
x[k - 1], \n           MapAt[{x[k], x[k - 1], 1}&, iterators, k]] ]"
}], "Input"],

Cell["\<\
splitIntegrals[n_] := Fold[removeAbs, integrate[integrand[n], \
iterators[n]], 
                           Range[2, n]] // ExpandAll;\
\>", "Input"],

Cell[TextData[{
  "Here are the eight abs\[Hyphen]free integrals for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "4"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["splitIntegrals[4]", "Input"],

Cell["\<\
We convert the multiple integrals into explicit iterated integrals.\
\
\>", "Text"],

Cell["\<\
splitIntegrals[6][[4]] /. integrate[integrand_, iterators_] :> 
                          FoldList[integrateInd, integrand, \
Reverse[iterators]]\
\>", "Input"],

Cell[TextData[{
  "To carry out a single integral of the multivariate integral, we define a \
function ",
  StyleBox["integrateInd", "MR"],
  ". Because the integrands are smooth and free of singularities, we can just \
evaluate the indefinite integral (which is fast) and substitute limits."
}], "Text"],

Cell[TextData[{
  "integrateInd[f_, {x_, x0_, x1_}] := \n     If[",
  StyleBox["(* integrand does not contain integration variable? *)", 
    "CodeComment"],
  "\n        FreeQ[f, x, Infinity], (x1 - x0) f, \n        ",
  StyleBox["(* avoid size swell by applying Together *)", "CodeComment"],
  "\n        Together[((# /. x -> x1) - (# /. x -> x0))&[Integrate[f, x]]]]"
}], "Input"],

Cell[TextData[{
  "integrateInd[f_, {x_, x0_, x1_}] := \n     If[",
  StyleBox["(* integrand does not contain integration variable? *)", 
    "CodeComment"],
  "\n        FreeQ[f, x, Infinity], Together[(x1 - x0) f], \n        ",
  StyleBox["(* avoid size swell by applying Together *)", "CodeComment"],
  "\n        Together[((# /. x -> x1) - (# /. x -> x0))&[Integrate[f, x]]]]"
}], "Input"],

Cell[TextData[{
  "Now we have all ingredients together to define the function ",
  StyleBox["absMultiIntegral", "MR"],
  " that calculates the original integral in dimension ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
absMultiIntegral[n_] := 
 splitIntegrals[n] /. integrate[integrand_, iterators_] :> 
     Fold[integrateInd, integrand, Reverse[iterators]] // Together\
\>", \
"Input"],

Cell[TextData[{
  "Now we can carry out the integrals much faster (although still with \
exponentially in ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " growing times)."
}], "Text"],

Cell["Table[{n, absMultiIntegral[n] // Timing}, {n, 2, 10}]", "Input"],

Cell[TextData[{
  "We can achive a further speed\[Hyphen]up by recognizing that we can write \
",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[ScriptCapitalI]", "n"], "=", 
          RowBox[{
            SubscriptBox[
              OverscriptBox["\[ScriptCapitalI]", "~"], "n"], "(", "1", 
            ")"}]}], TraditionalForm]]],
  ", where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            OverscriptBox["\[ScriptCapitalI]", "~"], "n"], "(", "1", ")"}], 
        TraditionalForm]]],
  " obeys the recursion relation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox[
              OverscriptBox["\[ScriptCapitalI]", "~"], "n"], "(", "x", ")"}], 
          " ", "=", 
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", "1"], 
            RowBox[{
              RowBox[{"exp", "(", 
                RowBox[{"\[LeftBracketingBar]", 
                  RowBox[{"x", "-", "y"}], "\[RightBracketingBar]"}], ")"}], 
              RowBox[{
                SubscriptBox[
                  OverscriptBox["\[ScriptCapitalI]", "~"], 
                  RowBox[{"n", "-", "1"}]], "(", "y", ")"}], " ", "d", 
              "\[InvisibleSpace]", "y"}]}]}], TraditionalForm]]],
  ". This allows to do only two integrals per integration variable. The next \
function ",
  StyleBox["intR", "MR"],
  " implements this recursive approach. At each stage, we keep ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox[
            OverscriptBox["\[ScriptCapitalI]", "~"], "n"], "(", "x", ")"}], 
        TraditionalForm]]],
  " fully expanded."
}], "Text"],

Cell[TextData[{
  StyleBox["(* save dynamic values for intR[n][x_] *)", "CodeComment"],
  "\nOff[RuleDelayed::rhs];\n\nintR[n_][x_] := intR[n][x_] = ",
  StyleBox["(* thread integration over sums and expand *)", "CodeComment"],
  "\nExpandAll[Exp[ x] ((# /. y -> x) - (# /. y -> 0))&[\n             \
Integrate[# Exp[-y], y]& /@  intR[n - 1][y]] +\n          Exp[-x] ((# /. y -> \
1) - (# /. y -> x))&[\n             Integrate[# Exp[+y], y]& /@  intR[n - \
1][y]]]\n\n",
  StyleBox["(* initial value *)", "CodeComment"],
  "\nintR[1][x_] := Exp[2 - x]/2 - Exp[x]/2 + x Exp[x]"
}], "Input"],

Cell[TextData[{
  "The recursive approach allows to calculate ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "10"], TraditionalForm]]],
  " in about one second."
}], "Text"],

Cell[TextData[{
  StyleBox["(* do recursion step by step *)", "CodeComment"],
  "\n(Do[intR[n][x], {n, 2, 10}]; Together[intR[10][1]]) // Timing"
}], "Input"],

Cell[TextData[{
  "And in a approximately an hour it is now possible to calculate ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "100"], TraditionalForm]]],
  ". Assumping that the calculation time ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  " depends on ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"c", " ", 
          SuperscriptBox["n", "\[Alpha]"]}], TraditionalForm]]],
  ", we can estimate the time needed to calculate ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "100"], TraditionalForm]]],
  "by extrapolating from the quickly computable first 30 values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "n"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* calculation times as a function of n *)", "CodeComment"],
  "\ntimeData = Table[{n, Timing[intR[n][x]][[1, 1]]}, {n, 11, 30}];\n",
  StyleBox["(* parameter fitting an assumed timing of the form t[\[Alpha]] = \
Exp[c] n^\[Alpha] *)", "CodeComment"],
  "\n{c, \[Alpha]} = CoefficientList[Fit[Log @ timeData, {1, n}, n], n];\n\
Sum[Exp[c] n^\[Alpha], {n, 100}] Second"
}], "Input"],

Cell[TextData[{
  "This means that in approximately an hour it is now possible to calculate \
",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptCapitalI]", "100"], TraditionalForm]]],
  ". "
}], "Text"],

Cell[TextData[{
  Cell[BoxData[
      ButtonBox[
        RowBox[{"Make", " ", "Input"}],
        ButtonStyle->"ProgramButton"]]],
  "    "
}], "ProgramLabel"],

Cell[TextData[{
  "Do[",
  StyleBox["(* to see some progress *)", "CodeComment"],
  "\n   Print[{k, Timing[Length[intR[k][x]]]}], {k, 31, 100}] // Timing;\n   \
\nintR[100][1]   "
}], "Program"],

Cell["", "ProgramBottom"],

Cell[TextData[{
  "Here are the leading terms in ",
  Cell[BoxData[
      FormBox["e", TraditionalForm]]],
  " of the result for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[ScriptCapitalI]", "100"], "=", 
          RowBox[{
            StyleBox["2.2825",
              ZeroWidthTimes->True], 
            StyleBox["\[Ellipsis]",
              ZeroWidthTimes->True], " ", 
            SuperscriptBox["10", "16"]}]}], TraditionalForm]]],
  ":\n",
  StyleBox[" 1/2^100 E^101 + 97/2^100 E^99+ ", "MR"],
  "3533",
  StyleBox["/(2^98 3) E^97 + ", "MR"],
  "103745",
  StyleBox["/(2^96 3^2) E^95 +\n ", "MR"],
  "240415611",
  StyleBox["/(2^100 5 7) E^93 + \[Ellipsis]", "MR"]
}], "Text",
  ParagraphSpacing->{0, 0}]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "18.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Alterative Lagrangian"
}], "ExerciseHeading"],

Cell[TextData[{
  "Given a 1D holonomic mechanical system with a conserved quantity ",
  Cell[BoxData[
      FormBox[
        RowBox[{"K", "(", 
          RowBox[{
            RowBox[{"x", "(", "t", ")"}], ",", " ", 
            RowBox[{"v", "(", "t", ")"}]}], ")"}], TraditionalForm]]],
  ", (",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"v", "(", "t", ")"}], "=", 
          RowBox[{
            SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}]}], 
        TraditionalForm]]],
  "), the Kobussen\[Dash]Leubner\[Dash]Lopez [",
  
  CounterBox["BibliographyCounter", "Lopez91"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lopez91",
    ButtonStyle->"Hyperlink"],
  "] formula allows for the construction of a Lagrangian ",
  Cell[BoxData[
      FormBox[
        RowBox[{"L", "(", 
          RowBox[{"x", ",", "v"}], ")"}], TraditionalForm]]],
  " through ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"L", "(", 
            RowBox[{"x", ",", "v"}], ")"}], "=", 
          RowBox[{"v", " ", 
            RowBox[{"\[Integral]", 
              RowBox[{
                RowBox[{
                  RowBox[{"K", "(", 
                    RowBox[{"x", ",", "v"}], ")"}], "/", 
                  SuperscriptBox["v", "2"]}], "d", "\[InvisibleSpace]", 
                "v"}]}]}]}], TraditionalForm]]],
  ". (Given a Lagrangian, unique equations of motion follow, but given the \
equations of motion, the Lagrangian is nonunique [",
  
  CounterBox["BibliographyCounter", "Lopuszanski99"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lopuszanski99",
    ButtonStyle->"Hyperlink"],
  "].) For a one\[Hyphen]dimensional harmonic oscillator, the energy ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", 
          RowBox[{
            RowBox[{"m", " ", 
              RowBox[{
                SuperscriptBox["v", "2"], "/", "2"}]}], "+", 
            RowBox[{"m", " ", 
              SuperscriptBox["\[Omega]", "2"], 
              RowBox[{
                SuperscriptBox["x", "2"], "/", "2"}]}]}]}], 
        TraditionalForm]]],
  " is a conserved quantity. Using the Kobussen\[Dash]Leubner\[Dash]Lopez \
formula for powers of the energy ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[CurlyEpsilon]", "n"], TraditionalForm]]],
  " (",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "\[Element]", 
          SuperscriptBox["\[DoubleStruckCapitalN]", "+"]}], 
        TraditionalForm]]],
  ") yields the Lagrangian [",
  
  CounterBox["BibliographyCounter", "Lopez02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lopez02",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["L", "n"], "(", 
          RowBox[{"x", ",", "v"}], ")"}], "=", 
        RowBox[{
          FractionBox["m", "2"], 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", "0"}], "n"], 
            RowBox[{
              FractionBox["1", 
                RowBox[{
                  RowBox[{"2", "k"}], "-", "1"}]], 
              TagBox[
                RowBox[{"(", GridBox[{
                      {
                        TagBox["n",
                          Identity,
                          Editable->True]},
                      {
                        TagBox["k",
                          Identity,
                          Editable->True]}
                      }], ")"}],
                InterpretTemplate[ Binomial[ #, #2]&],
                Editable->False], 
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{
                    SuperscriptBox["\[Omega]", "2"], 
                    SuperscriptBox["x", "2"]}], ")"}], 
                RowBox[{"n", "-", "k"}]], 
              RowBox[{
                SuperscriptBox["v", 
                  RowBox[{"2", "k"}]], "."}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "The solution of the Euler\[Dash]Lagrange equations of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["L", "n"], "(", 
          RowBox[{"x", ",", "v"}], ")"}], TraditionalForm]]],
  " are the well known harmonic oscillations of the one\[Hyphen]dimensional \
harmonic oscillator. But the phase space trajectories derived from the \
Hamiltonian ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["H", "n"], "(", 
          RowBox[{"x", ",", "p"}], ")"}], TraditionalForm]]],
  ", where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["H", "n"], "(", 
            RowBox[{"x", ",", "p"}], ")"}], "=", 
          SuperscriptBox[
            RowBox[{"\[CurlyEpsilon]", "(", 
              RowBox[{"x", ",", " ", 
                RowBox[{"v", "(", 
                  RowBox[{"x", ",", "p"}], ")"}]}], ")"}], "n"]}], 
        TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "=", 
          RowBox[{
            RowBox[{"\[PartialD]", "L"}], "/", 
            RowBox[{"\[PartialD]", "v"}]}]}], TraditionalForm]]],
  " are for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", ">", "1"}], TraditionalForm]]],
  " different curves than the well\[Hyphen]known circles of the \
one\[Hyphen]dimensional harmonic oscillator [",
  
  CounterBox["BibliographyCounter", "Lopez02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lopez02",
    ButtonStyle->"Hyperlink"],
  "]. For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", ">", "1"}], TraditionalForm]]],
  ", calculate and visualize some of the phase space trajectories following \
from ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["H", "n"], "(", 
          RowBox[{"x", ",", "p"}], ")"}], TraditionalForm]]],
  " via ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}], "=", 
          RowBox[{
            RowBox[{"\[PartialD]", 
              RowBox[{"H", "(", 
                RowBox[{
                  RowBox[{"x", "(", "t", ")"}], ",", 
                  RowBox[{"p", "(", "t", ")"}]}], ")"}]}], "/", 
            RowBox[{"\[PartialD]", 
              RowBox[{"p", "(", "t", ")"}]}]}]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["p", "\[Prime]"], "(", "t", ")"}], "=", 
          RowBox[{
            RowBox[{"-", 
              RowBox[{"\[PartialD]", 
                RowBox[{"H", "(", 
                  RowBox[{
                    RowBox[{"x", "(", "t", ")"}], ",", 
                    RowBox[{"p", "(", "t", ")"}]}], ")"}]}]}], "/", 
            RowBox[{"\[PartialD]", 
              RowBox[{"x", "(", "t", ")"}]}]}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "To derive the derivatives of the Hamiltonian ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["H", "n"], "(", 
          RowBox[{"x", ",", "p"}], ")"}], TraditionalForm]]],
  " with respect to ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "t", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "t", ")"}], TraditionalForm]]],
  ", we do not need the Hamiltonian ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["H", "n"], "(", 
          RowBox[{"x", ",", "p"}], ")"}], TraditionalForm]]],
  " in explicit form. This would be difficult because ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[PartialD]", "L"}], "/", 
          RowBox[{"\[PartialD]", "v"}]}], TraditionalForm]]],
  " will be a higher order polynomial in ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["v", TraditionalForm]]],
  " and inverting with respect to ",
  Cell[BoxData[
      FormBox["v", TraditionalForm]]],
  " would give radicals or ",
  StyleBox["Root\[Hyphen]", "MR"],
  "objects. But it is straightforward to eliminate the velocity ",
  Cell[BoxData[
      FormBox["v", TraditionalForm]]],
  " from ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["H", "n"], "(", 
            RowBox[{"x", ",", "p"}], ")"}], "=", 
          SuperscriptBox[
            RowBox[{"\[CurlyEpsilon]", "(", 
              RowBox[{"x", ",", " ", 
                RowBox[{"v", "(", 
                  RowBox[{"x", ",", "p"}], ")"}]}], ")"}], "n"]}], 
        TraditionalForm]]],
  "and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "=", 
          RowBox[{
            RowBox[{"\[PartialD]", 
              SubscriptBox["L", "n"]}], "/", 
            RowBox[{"\[PartialD]", "v", " "}]}]}], TraditionalForm]]],
  " to obtain an implicit polynomial equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[ScriptP]", "n"], "(", 
            RowBox[{"p", ",", "H"}], ")"}], "=", "0"}], TraditionalForm]]],
  ". This polynomial ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[ScriptP]", "n"], TraditionalForm]]],
  " we can differentiate implicitly to obtain the equations of motion for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "t", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "t", ")"}], TraditionalForm]]],
  ". We obtain valid starting values ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "0", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "0", ")"}], TraditionalForm]]],
  " from fulfilling the polynomial equation of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[ScriptP]", "n"], "(", 
            RowBox[{
              RowBox[{"x", "(", "0", ")"}], ",", 
              RowBox[{"p", "(", "0", ")"}], ",", "H"}], ")"}], "=", "0"}], 
        TraditionalForm]]]
}], "ExerciseSubgroup"],

Cell[TextData[{
  "The function ",
  StyleBox["implicitHamiltonianEquation", "MR"],
  " calculates the implicit equation for the Hamiltonian. (We set ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", 
          RowBox[{"\[Omega]", "=", "1"}]}], TraditionalForm]]],
  " in the following.)"
}], "Text"],

Cell[TextData[{
  "implicitHamiltonianEquation[n_, H_, {x_, p_}] := \nWith[{L = 1/2 \
Sum[Binomial[n, k] (x^2)^(n - k) v^(2k)/(2k - 1), {k, 0, n}]},\n     ",
  StyleBox["(* eliminate v *)", "CodeComment"],
  "\n     Resultant[H - (1/2)^n (v^2 + x^2)^n, p - D[L, v], v] // \n          \
                                   Together // Factor // Numerator]"
}], "Input"],

Cell[TextData[{
  "Here are the first three polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[ScriptP]", "n"], "(", 
          RowBox[{"x", ",", "p", ",", "H"}], ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["Table[implicitHamiltonianEquation[n, H, {x, p}], {n, 3}]", "Input"],

Cell["\<\
As described, the equations of motions are obtained from implicit \
differentiation.\
\>", "Text"],

Cell[TextData[{
  "HamiltonianEquationsOfMotion[n_, H_, {x_, p_}, t_] :=\nWith[{\[ScriptP] = \
implicitHamiltonianEquation[n, H[x[t], p[t]], {x[t], p[t]}]},\n     ",
  StyleBox["(* differentiate implicitly, then solve for derivatives of H *)", 
    "CodeComment"],
  "\n     {x'[t] == +Solve[D[\[ScriptP], p[t]] == 0, D[H[x[t], p[t]], \
p[t]]][[1, 1, 2]],\n      p'[t] == -Solve[D[\[ScriptP], x[t]] == 0, D[H[x[t], \
p[t]], x[t]]][[1, 1, 2]]}]  "
}], "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "1"}], TraditionalForm]]],
  ", we recover the well\[Hyphen]known equations of motion for the harmonic \
oscillator."
}], "Text"],

Cell["HamiltonianEquationsOfMotion[1, H, {x, p}, t]", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "2"}], TraditionalForm]]],
  ", we obtain considerably more complicated equations. They contain the \
Hamiltonian ",
  Cell[BoxData[
      FormBox["H", TraditionalForm]]],
  ", a conserved quantity."
}], "Text"],

Cell["HamiltonianEquationsOfMotion[2, H, {x, p}, t]", "Input"],

Cell[TextData[{
  "Now, we must deal with the initial conditions for ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["p", TraditionalForm]]],
  ". We will prescribe values for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "0", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "0", ")"}], TraditionalForm]]],
  ". This fixes the value of ",
  Cell[BoxData[
      FormBox["H", TraditionalForm]]],
  ", but not necessary uniquely, because ",
  Cell[BoxData[
      FormBox["H", TraditionalForm]]],
  " appears in ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["p", "n"], TraditionalForm]]],
  " nonlinearly. We use high\[Hyphen]precision arithmetic to calculate the \
starting values and to solve the differential equaion to obtain numerically \
reliable solutions."
}], "Text"],

Cell[TextData[{
  "HValues[n_, {x0_, p0_}, wp_: 30] :=\nModule[{H, NHs, x, p, t, x0E = \
Rationalize[x0, 0], \n        p0E = Rationalize[p0, 0],dens}, \n       ",
  StyleBox["(* numerically solve for H *)", "CodeComment"],
  "\n       NHs = N[Solve[implicitHamiltonianEquation[n, H, {x0E, p0E}] == 0, \
H], wp];\n       ",
  StyleBox["(* eliminate potential zeros in the denominators of the \
derivatives of H *)", "CodeComment"],
  "\n       dens = Denominator[Last /@ HamiltonianEquationsOfMotion[n, H, {x, \
p}, t]] //.\n                   \[Xi]_[t] :> \[Xi] /. _H :> H;      \n       \
",
  StyleBox["(* esort in such a manner that real solutiosn come first *)", 
    "CodeComment"],
  "\n       Sort[#[[1, 2]]& /@ Select[NHs, FreeQ[dens /. # /. {x -> x0E, p -> \
p0E},\n                                       _?(# == 0&)]&], Abs[Im[#1]] < \
Abs[Im[#2]]&]]"
}], "Input"],

Cell[TextData[{
  "Generically, for real ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "0", ")"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "0", ")"}], TraditionalForm]]],
  ", we have one real value for ",
  Cell[BoxData[
      FormBox["H", TraditionalForm]]],
  ". Here is an example."
}], "Text"],

Cell["HValues[4, {2, 2}] // N", "Input"],

Cell["\<\
Now, we are ready to solve the equations of motion \
numerically.\
\>", "Text"],

Cell[TextData[{
  "Clear[nDSolveHO];\nnDSolveHO[n_, {x_, p_}, {x0_, p0_}, T_, k_:All, wp_:20] \
:=\nModule[{hs},\n       ",
  StyleBox["(* starting values *)", "CodeComment"],
  "\n       hs = HValues[n, {x0, p0}, wp + 10];\n       ",
  StyleBox["(* solve equations of motion for all starting values *)", 
    "CodeComment"],
  "\n       NDSolve[Join[HamiltonianEquationsOfMotion[n, H, {x, p}, t] /. \
H[__] -> #,\n                    {x[0] == x0, p[0] == p0}],\n               \
{x, p}, {t, 0, T}, WorkingPrecision -> wp, MaxSteps -> 10^5,\n               \
PrecisionGoal -> 10, AccuracyGoal -> 10]& /@ Take[hs, k]]"
}], "Input"],

Cell[TextData[{
  "To visualize the phase space trajectories, we use the function ",
  StyleBox["phaseSpaceTrajectories", "MR"],
  ". It generates graphics of the real and imaginary parts of the phase space \
trajectories."
}], "Text"],

Cell[TextData[{
  "phaseSpaceTrajectories[n_, {x0_, p0_}, T_, k_:All, wp_:20] := \n\
Module[{ndsols = nDSolveHO[n, {x, p}, {x0, p0}, T, k, wp]},\n        \
\[Lambda] = Length[ndsols]; \n       GraphicsArray[Function[reIm, \n          \
 ",
  StyleBox["(* plot real and imaginary parts of the parametrized trajectories \
*)", "CodeComment"],
  "\n           ParametricPlot[Evaluate[reIm @ {x[t], p[t]} /. ndsols],\n     \
                     {t, 0, T}, PlotRange -> All, \n                          \
PlotPoints -> Round[T 100], AspectRatio -> 1,\n                          \
DisplayFunction -> Identity, PlotLabel -> reIm,\n                          \
Frame -> True, Axes -> False,\n                          PlotStyle -> \
Table[Hue[0.8 j/\[Lambda]], \n                                                \
 {j, 0, \[Lambda] - 1}]]] /@ {Re, Im}]]"
}], "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "1"}], TraditionalForm]]],
  ", we have just one possible phase space trajectory, a circle (an \
ellipse)."
}], "Text"],

Cell["Show @ phaseSpaceTrajectories[1, {2, 2}, 2Pi]", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "2"}], TraditionalForm]]],
  ", we have three trajectories, one real one, and two coinciding complex \
one. The real one is displayed in red. The period is now doubled. The complex \
trajectory is more complicated."
}], "Text"],

Cell["Show @ phaseSpaceTrajectories[2, {2, 2}, 4Pi]", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "2"}], TraditionalForm]]],
  ", we have five trajectories, one real one, and two pairs of coinciding \
complex one. The real one is again displayed in red. The period is four times \
the one from the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "1"}], TraditionalForm]]],
  " case.  Again, the complex trajectories are more complicated."
}], "Text"],

Cell["Show @ phaseSpaceTrajectories[3, {2, 2}, 8Pi]", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "3"}], TraditionalForm]]],
  ", we have seven trajectories, one real one, and three pairs of coinciding \
complex one. The real one is again displayed in red. The period is eight \
times the one from the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "1"}], TraditionalForm]]],
  " case. And again, the complex trajectories are more complicated."
}], "Text"],

Cell["Show @ phaseSpaceTrajectories[4, {2, 2}, 16Pi]", "Input"],

Cell[TextData[{
  "We end here with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "4"}], TraditionalForm]]],
  ". Higher order complex trajectories become more and more complicated."
}], "Text"],

Cell[TextData[{
  "We end with displaying the phase space trajectories corresponding to the \
real trajectories for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"n", "=", "1"}], ",", "2", ",", "3"}], TraditionalForm]]],
  " in one graphic. The different shape and size of the trajectories is \
clearly visible."
}], "Text"],

Cell[TextData[{
  "Show[Table[phaseSpaceTrajectories[n, {1/100, 1}, 2^n 2Pi, 1][[1, 1]] /. \n \
                         ",
  StyleBox["(* recolor to red (n = 1) to blue (n = 4) *)", "CodeComment"],
  " \n                                  Hue[0] :> Hue[(n - 1)/4], {n, 1, 4}],\
\n     DisplayFunction -> $DisplayFunction, PlotRange -> All]"
}], "Input"],

Cell[TextData[{
  "We could now continue and use complex starting values for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"x", "(", "0", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"p", "(", "0", ")"}], TraditionalForm]]],
  " and solve the equations of motion in the complex ",
  Cell[BoxData[
      FormBox["t", TraditionalForm]]],
  "\[Hyphen]plane to obtain still more complicated trajectories."
}], "Text"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Symbolics Volume, Chapter 2", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " H\[EAcute]non\[Dash]Heiles Eigenfunctions"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the following H\[EAcute]non\[Dash]Heiles\[Hyphen]type potential \
(compared to the classical H\[EAcute]non\[Dash]Heiles\[Hyphen]type potential, \
the additional ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["r", "4"], TraditionalForm]]],
  " term guarantees confinement of the quantum mechanical problem)"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"V", "(", 
          RowBox[{"x", ",", "y"}], ")"}], "=", 
        RowBox[{
          RowBox[{
            RowBox[{"\[Alpha]", " ", 
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{
                    SuperscriptBox["x", "2"], "+", 
                    SuperscriptBox["y", "2"]}], ")"}], "2"]}], "+", 
            RowBox[{"\[Beta]", " ", 
              RowBox[{"(", 
                RowBox[{
                  SuperscriptBox["x", "2"], "+", 
                  SuperscriptBox["y", "2"]}], ")"}]}], "+", 
            RowBox[{"\[Gamma]", " ", 
              RowBox[{"(", 
                RowBox[{
                  SuperscriptBox["x", "3"], "-", 
                  RowBox[{"3", "x", " ", 
                    SuperscriptBox["y", "2"]}]}], ")"}]}]}], "=", 
          RowBox[{
            RowBox[{"\[Alpha]", " ", 
              SuperscriptBox["r", "4"]}], "+", 
            RowBox[{"\[Beta]", " ", 
              SuperscriptBox["r", "2"]}], "+", 
            RowBox[{"\[Gamma]", " ", 
              RowBox[{"cos", "(", 
                RowBox[{"3", "\[CurlyPhi]"}], ")"}], 
              RowBox[{
                SuperscriptBox["r", "3"], "."}]}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For some values of the parameters ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["\[Beta]", TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  ", and various initial conditions, calculate some of the classical \
trajectories. Visualize these trajectories and construct the corresponding \
Poincar\[EAcute] plots."
}], "Text"],

Cell[TextData[{
  "Also, calculate and visualize [",
  
  CounterBox["BibliographyCounter", "Berezovoj03a"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Berezovoj03a",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Kalhous04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kalhous04",
    ButtonStyle->"Hyperlink"],
  "]",
  " some of the energy eigenfunctions of the corresponding \
time\[Hyphen]independent Schr\[ODoubleDot]dinger equation [",
  
  CounterBox["BibliographyCounter", "Ballentine98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Ballentine98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Pattanayak92"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Pattanayak92",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"(", 
            RowBox[{
              RowBox[{
                RowBox[{"-", 
                  FractionBox[
                    SuperscriptBox["\[HBar]", "2"], 
                    RowBox[{"2", "M"}]]}], 
                SubscriptBox["\[CapitalDelta]", 
                  RowBox[{"x", ",", "y"}]]}], "+", 
              RowBox[{"V", "(", 
                RowBox[{"x", ",", " ", "y"}], ")"}]}], ")"}], 
          RowBox[{
            SubscriptBox["\[CapitalPsi]", "\[Mu]"], "(", 
            RowBox[{"x", ",", " ", "y"}], ")"}]}], "=", 
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", "\[Mu]"], 
          RowBox[{
            SubscriptBox["\[CapitalPsi]", "\[Mu]"], "(", 
            RowBox[{"x", ",", " ", "y"}], ")"}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "by expanding the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[CapitalPsi]", "\[Mu]"], "(", 
            RowBox[{"x", ",", " ", "y"}], ")"}], "=", 
          RowBox[{
            UnderscriptBox["\[Sum]", 
              RowBox[{"m", ",", "n"}]], 
            RowBox[{
              SubsuperscriptBox["c", 
                RowBox[{"m", ",", "n"}], 
                RowBox[{"(", "\[Mu]", ")"}]], 
              RowBox[{
                SubscriptBox["\[Psi]", 
                  RowBox[{"n", ",", "m"}]], "(", 
                RowBox[{"x", ",", " ", "y"}], ")"}]}]}]}], 
        TraditionalForm]]],
  " into the eigenfunctions ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Psi]", 
          RowBox[{"n", ",", "m"}]], TraditionalForm]]],
  " of the 2D harmonic oscillator"
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"(", 
            RowBox[{
              RowBox[{
                RowBox[{"-", 
                  FractionBox[
                    SuperscriptBox["\[HBar]", "2"], 
                    RowBox[{"2", "M"}]]}], 
                SubscriptBox["\[CapitalDelta]", 
                  StyleBox["r",
                    FontWeight->"Bold",
                    FontSlant->"Plain"]]}], "+", 
              RowBox[{
                FractionBox["M", "2"], "\[Omega]", " ", 
                SuperscriptBox[
                  RowBox[{"\[LeftBracketingBar]", 
                    StyleBox["r",
                      FontWeight->"Bold",
                      FontSlant->"Plain"], "\[RightBracketingBar]"}], 
                  "2"]}]}], ")"}], 
          RowBox[{
            SubscriptBox["\[Psi]", 
              RowBox[{"n", ",", "m"}]], "(", 
            RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}]}], "=", 
        RowBox[{
          RowBox[{"(", 
            RowBox[{
              RowBox[{
                RowBox[{"-", 
                  FractionBox[
                    SuperscriptBox["\[HBar]", "2"], 
                    RowBox[{"2", "M"}]]}], 
                RowBox[{"(", 
                  RowBox[{
                    RowBox[{
                      FractionBox["1", "r"], 
                      FractionBox["\[PartialD]", 
                        RowBox[{"\[PartialD]", "r"}],
                        MultilineFunction->None], 
                      RowBox[{"(", 
                        RowBox[{"r", " ", 
                          FractionBox["\[PartialD]", 
                            RowBox[{"\[PartialD]", "r"}],
                            MultilineFunction->None]}], ")"}]}], "+", 
                    RowBox[{
                      FractionBox["1", 
                        SuperscriptBox["r", "2"]], 
                      FractionBox[
                        SuperscriptBox["\[PartialD]", "2"], 
                        RowBox[{"\[PartialD]", 
                          SuperscriptBox["\[CurlyPhi]", "2"]}],
                        MultilineFunction->None]}]}], ")"}]}], "+", 
              RowBox[{
                FractionBox["M", "2"], "\[Omega]", " ", 
                SuperscriptBox["r", "2"]}]}], ")"}], 
          RowBox[{
            SubscriptBox["\[Psi]", 
              RowBox[{"n", ",", "m"}]], "(", 
            RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{"=", 
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", 
            RowBox[{"n", ",", "m"}]], 
          RowBox[{
            SubscriptBox["\[Psi]", 
              RowBox[{"n", ",", "m"}]], "(", 
            RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}]}]}], 
      TraditionalForm]}], "DisplayFormula"],

Cell[TextData[{
  "for some values of the parameters ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["\[Beta]", TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  ". The normalized eigenfunctions of the 2D harmonic oscillator in polar \
coordinates are (here ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          SubscriptBox[
            RowBox[{
              RowBox[{
                RowBox[{"|", "n"}], ",", "m"}], "\[RightAngleBracket]"}], 
            "r"],
          AutoStyleOptions->{"UnmatchedBracketStyle"->None}], 
        TraditionalForm]]],
  " denotes the radial eigenfunctions with quantum numbers ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        StyleBox[
          SubscriptBox[
            RowBox[{
              RowBox[{"|", "m"}], "\[RightAngleBracket]"}], "\[CurlyPhi]"],
          AutoStyleOptions->{"UnmatchedBracketStyle"->None}], 
        TraditionalForm]]],
  " denotes the azimuthal eigenfunction with quantum number ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ")."
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{"r", ",", 
            RowBox[{"\[CurlyPhi]", "|", "n"}], ",", "m"}], 
          "\[RightAngleBracket]"}], "=", 
        RowBox[{
          RowBox[{
            SubscriptBox[
              RowBox[{"\[LeftAngleBracket]", 
                RowBox[{"\[CurlyPhi]", "|", "m"}], "\[RightAngleBracket]"}], 
              "\[CurlyPhi]"], 
            SubscriptBox[
              RowBox[{"\[LeftAngleBracket]", 
                RowBox[{
                  RowBox[{"r", "|", "n"}], ",", "m"}], 
                "\[RightAngleBracket]"}], "r"]}], "=", 
          RowBox[{
            RowBox[{
              SubscriptBox["\[Psi]", 
                RowBox[{"n", ",", "m"}]], "(", 
              RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}], "=", 
            RowBox[{
              RowBox[{
                SubscriptBox["\[CapitalPhi]", "m"], "(", "\[CurlyPhi]", ")"}],
               
              RowBox[{
                SubscriptBox["R", 
                  RowBox[{"n", ",", "m"}]], "(", "r", ")"}]}]}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["\[CapitalPhi]", "m"], "(", "\[CurlyPhi]", ")"}], "=", 
        
        RowBox[{
          SubscriptBox[
            RowBox[{"\[LeftAngleBracket]", 
              RowBox[{"\[CurlyPhi]", "|", "m"}], "\[RightAngleBracket]"}], 
            "\[CurlyPhi]"], "=", 
          RowBox[{
            FractionBox["1", 
              SqrtBox[
                RowBox[{"2", "\[Pi]"}]]], 
            SuperscriptBox["e", 
              RowBox[{"i", " ", "m", " ", "\[CurlyPhi]"}]]}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{
          SubscriptBox["R", 
            RowBox[{"n", ",", "m"}]], "(", "r", ")"}], "=", 
        RowBox[{
          SubscriptBox[
            RowBox[{"\[LeftAngleBracket]", 
              RowBox[{
                RowBox[{"r", "|", "n"}], ",", "m"}], "\[RightAngleBracket]"}],
             "r"], "=", 
          RowBox[{
            FractionBox[
              SqrtBox["2"], "L"], 
            SqrtBox[
              FractionBox[
                RowBox[{"n", "!"}], 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{"n", "+", 
                      RowBox[{
                      "\[LeftBracketingBar]", "m", 
                        "\[RightBracketingBar]"}]}], ")"}], "!"}]]], " ", 
            SuperscriptBox[
              RowBox[{"(", 
                FractionBox["r", "L"], ")"}], 
              RowBox[{"\[LeftBracketingBar]", "m", "\[RightBracketingBar]"}]],
             " ", 
            SuperscriptBox["e", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["1", "2"]}], " ", 
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{"r", "/", "L"}], ")"}], "2"]}]], " ", 
            RowBox[{
              SubsuperscriptBox["L", "n", 
                RowBox[{
                "\[LeftBracketingBar]", "m", "\[RightBracketingBar]"}]], "(", 
              
              SuperscriptBox[
                RowBox[{"(", 
                  FractionBox["r", "L"], ")"}], "2"], ")"}]}]}]}], 
      TraditionalForm]}], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{
            SubscriptBox["n", "2"], ",", 
            RowBox[{
              SubscriptBox["m", "2"], "|", 
              SubscriptBox["n", "1"]}], ",", 
            SubscriptBox["m", "1"]}], "\[RightAngleBracket]"}], "=", 
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", 
              RowBox[{"2", "\[Pi]"}]], 
            RowBox[{
              SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[Psi]", 
                    RowBox[{
                      SubscriptBox["n", "1"], ",", 
                      SubscriptBox["m", "1"]}]], "(", 
                  RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}], 
                OverscriptBox[
                  RowBox[{
                    SubscriptBox["\[Psi]", 
                      RowBox[{
                        SubscriptBox["n", "2"], ",", 
                        SubscriptBox["m", "2"]}]], "(", 
                    RowBox[{"r", ",", "\[CurlyPhi]"}], ")"}], "_"], "r", " ", 
                "d", "\[InvisibleSpace]", "r"}]}]}], "=", "1"}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "and the eigenvalues are ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", 
            RowBox[{"n", ",", "m"}]], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{"2", " ", "n"}], "+", 
                RowBox[{
                "\[LeftBracketingBar]", "m", "\[RightBracketingBar]"}], "+", 
                "1"}], ")"}], " ", "\[HBar]", " ", "\[Omega]"}]}], 
        TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "ChaosCador04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"ChaosCador04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"n", "=", "0"}], ",", "1", ",", "\[Ellipsis]"}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"m", "=", "\[Ellipsis]"}], ",", 
          RowBox[{"-", "2"}], ",", 
          RowBox[{"-", "1"}], ",", "0", ",", "1", ",", "2", ",", 
          "\[Ellipsis]"}], TraditionalForm]]],
  ". and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"L", "=", 
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{"\[HBar]", "/", 
                RowBox[{"(", 
                  RowBox[{"M", " ", "\[Omega]"}], ")"}]}], ")"}], 
            RowBox[{"1", "/", "2"}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "First, we have a quick view of the potential. The potential has a \
threefold rotational symmetry around the origin, and, for appropriate \
parameters, three valleys. The left graphic shows a contour plot of the \
potential for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Beta]", "=", 
          RowBox[{"-", "6"}]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", "=", 
          RowBox[{"-", "4"}]}], TraditionalForm]]],
  ". The right graphic shows the contour lines ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"V", "(", 
            RowBox[{"x", ",", "y"}], ")"}], "=", "0"}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Beta]", " ", "=", 
          RowBox[{"-", "6"}]}], TraditionalForm]]],
  " for various values of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", " "}], TraditionalForm]]],
  "."
}], "SolutionSubgroup"],

Cell[TextData[{
  StyleBox["(* the generalized H\[EAcute]non-Heiles potential *)", 
    "CodeComment"],
  "\nV[{x_, y_}, {\[Alpha]_, \[Beta]_, \[Gamma]_}] := \[Alpha] Sqrt[x^2 + \
y^2]^4 +\n            \[Beta] Sqrt[x^2 + y^2]^2 + \[Gamma] (x^3 - 3 x y^2)"
}], "Input"],

Cell[TextData[{
  "Show[GraphicsArray[\nBlock[{L1 = 6, L2 = 8, $DisplayFunction = Identity}, \
\n{",
  StyleBox["(* contour plot of a concrete potential realization *)", 
    "CodeComment"],
  "\n ContourPlot[Evaluate[V[{x, y}, {1, -6, -4}]], \n            {x, -L1, \
L1}, {y, -L1, L1}, PlotPoints -> 240, \n            Contours -> 60, \
ContourLines -> True, \n           ",
  StyleBox[" (* inner contours more pronounced *)", "CodeComment"],
  "\n            ContourStyle -> Table[{GrayLevel[x]}, {x, 0, 1, 1/60}],\n    \
        ColorFunction -> (GrayLevel[ArcCos[#]/(Pi/2)]&)],\n ",
  StyleBox["(* V(x,y) == 0 curves of the potential *)", "CodeComment"],
  "\n Show[Table[\n ContourPlot[Evaluate[V[{x, y}, {1, -6, \[Gamma]}]], \n    \
         {x, -L2, L2}, {y, -L2, L2},\n             PlotPoints -> 240, \
Contours -> {0},\n             ContourStyle -> {{Hue[0.78 (\[Gamma] + \
8)/16]}}, \n             ContourShading -> False], {\[Gamma], -8, 8}]]}]]]"
}], "Input"],

Cell[TextData[{
  "Next, we visualize some of the classical trajectories. The function ",
  StyleBox["path", "MR"],
  " calculates the path (trajectory) ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "(", "t", ")"}], ",", 
            RowBox[{"y", "(", "t", ")"}]}], "}"}], TraditionalForm]]],
  " of a point particle in the potential ",
  Cell[BoxData[
      FormBox[
        RowBox[{"V", "(", 
          RowBox[{"x", ",", "y"}], ")"}], TraditionalForm]]],
  " with initial conditions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"{", 
            RowBox[{
              RowBox[{"x", "(", "t", ")"}], ",", 
              RowBox[{"y", "(", "t", ")"}]}], "}"}], "=", 
          RowBox[{"{", 
            RowBox[{
              StyleBox["x0",
                "TI"], ",", 
              StyleBox["y0",
                "TI"]}], "}"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"{", 
            RowBox[{
              RowBox[{
                SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}], ",", 
              RowBox[{
                SuperscriptBox["y", "\[Prime]"], "(", "t", ")"}]}], "}"}], 
          "=", 
          RowBox[{"{", 
            RowBox[{
              StyleBox["vx0",
                "TI"], ",", 
              StyleBox["vy0",
                "TI"]}], "}"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "path[{x0_, y0_}, {vx0_, vy0_}, {\[Alpha]_, \[Beta]_, \[Gamma]_}, T_] :=\n  \
 NDSolve[",
  StyleBox["(* equations of motion *)", "CodeComment"],
  "\n   {x'[t] == vx[t], vx'[t] == -D[V[{x[t], y[t]}, {\[Alpha], \[Beta], \
\[Gamma]}], x[t]],\n    y'[t] == vy[t], vy'[t] == -D[V[{x[t], y[t]}, \
{\[Alpha], \[Beta], \[Gamma]}], y[t]],\n    x[0] == x0, y[0] == y0, vx[0] == \
vx0, vy[0] == vy0},\n   {x, y, vx, vy}, {t, 0, T}, MaxSteps -> 10^6]"
}], "Input"],

Cell[TextData[{
  "We visualize the path using the function ",
  StyleBox["pathPlots", "MR"],
  ". For a given path ",
  StyleBox["pathSol", "TI"],
  " (returned from the function ",
  StyleBox["path", "MR"],
  "), this function generates the four parametric plots ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}], ",", 
            RowBox[{
              SuperscriptBox["y", "\[Prime]"], "(", "t", ")"}]}], "}"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "(", "t", ")"}], ",", 
            RowBox[{
              SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}]}], "}"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"y", "(", "t", ")"}], ",", 
            RowBox[{
              SuperscriptBox["y", "\[Prime]"], "(", "t", ")"}]}], "}"}], 
        TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}], ",", 
            RowBox[{
              SuperscriptBox["y", "\[Prime]"], "(", "t", ")"}]}], "}"}], 
        TraditionalForm]]],
  ","
}], "Text"],

Cell[TextData[{
  "pathPlots[pathSol_] :=\nModule[{X, Y, VX, VY},\n  ",
  StyleBox["(* extract value lists for positions and velocities *)", 
    "CodeComment"],
  "\n  {X, Y, VX, VY} = \n      Transpose[Partition[#[[2, 4, 2]], 2]][[1]]& \
/@ pathSol[[1]];\nShow[GraphicsArray[\n  ListPlot[Transpose[#], PlotJoined -> \
True,\n         PlotStyle -> {Thickness[0.002], GrayLevel[0]},\n         \
PlotRange -> All, ",
  StyleBox["(* for uniformity *)", "CodeComment"],
  " AspectRatio -> 1,\n         DisplayFunction -> Identity, FrameTicks -> \
False,\n         Frame -> True, PlotLabel -> #2, Axes -> False]& @@@ \n       \
  ",
  StyleBox["(* the four pairs of functions for the parametric plots *)", 
    "CodeComment"],
  "\n         {{{X, Y}, {x, y}}, {{X, VX}, {x, Subscript[v, x]}},\n          \
{{Y, VY}, {y, Subscript[v, y]}},\n          {{VX, VY}, {Subscript[v, y], \
Subscript[v, xy]}}}]]]"
}], "Input"],

Cell["\<\
Here are some of the trajectories and their phase plots \
shown.\
\>", "Text"],

Cell[TextData[{
  "v\[Beta]\[Delta]Data =\n",
  StyleBox["(* parameter sets for various types of classical motion *)", 
    "CodeComment"],
  "\n{{{-1475/496,    66/041}, {   19/003, - 326/221}},\n {{ 5043/515,   \
906/235}, {-1200/157, -3576/569}},\n {{ 2923/321,  1517/404}, { 1690/317, -  \
23/021}},\n {{- 524/147,  2272/567}, {-  58/043,     9/035}},\n {{ 6097/823, \
-2230/233}, {- 648/271, -   1/107}},\n {{ 2305/634, - 221/133}, { 5874/959,  \
1287/458}},\n {{  753/106,   349/150}, {- 665/624, -5509/732}}};"
}], "Input"],

Cell["\<\
pathPlots[path[{0, 0}, #2, {1, Sequence @@ #1}, 50]]& @@@ v\[Beta]\
\[Delta]Data\
\>", "Input"],

Cell[TextData[{
  "Here are 3D plots of some of the trajectories in ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox[
        SubscriptBox["v", "x"], TraditionalForm]]],
  "\[Hyphen]space."
}], "Text"],

Cell[TextData[{
  "pathPlot3D[pathSol_] :=\nModule[{X, Y, VX, VY, trajectory, \[Lambda]},\n  \
",
  StyleBox["(* extract value lists for positions and velocities *)", 
    "CodeComment"],
  "\n  {X, Y, VX, VY} = \n      Transpose[Partition[#[[2, 4, 2]], 2]][[1]]& \
/@ pathSol[[1]];\n  ",
  StyleBox["(* path in x,y,vx-space *)", "CodeComment"],
  " \n  xyvxPath = Transpose[{X, Y, VX}]; \[Lambda] = Length[xyvxPath];    \n\
Show[Graphics3D[{Thickness[0.002],\n       ",
  StyleBox["(* color path from red to blue *)", "CodeComment"],
  "\n       MapIndexed[{Hue[0.78 #2[[1]]/\[Lambda]], Line[#1]}&, \n           \
        Partition[xyvxPath, 2, 1]]}],\n     BoxRatios -> {1, 1, 1}, Axes -> \
True,\n     AxesLabel -> {\"x\", \"y\", Subscript[v, x]}]]"
}], "Input"],

Cell["\<\
Show[GraphicsArray[
Block[{$DisplayFunction = Identity}, 
pathPlot3D[path[{0, 0}, #2, {1, Sequence @@ #1}, 100]]& @@@ 
                                    v\[Beta]\[Delta]Data[[{1, 6, \
7}]]]]]\
\>", "Input"],

Cell[TextData[{
  "Some of the trajectories look regular, and some look chaotic [",
  
  CounterBox["BibliographyCounter", "Kokubun98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Kokubun98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Aguirre01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Aguirre01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "MoralesRuiz01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"MoralesRuiz01",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Chatteraj04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Chatteraj04",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Displaying their Poincar\[EAcute] plots confirms this [",
  
  CounterBox["BibliographyCounter", "Brack98"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Brack98",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "CerrutiSola96"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"CerrutiSola96",
    ButtonStyle->"Hyperlink"],
  "]. For a given ",
  StyleBox["pathSol", "TI"],
  " returned from the function ",
  StyleBox["path", "MR"],
  ", the function ",
  StyleBox["poincareSection", "MR"],
  " generates the Poincar\[EAcute] plot of the variables ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"\[Xi]", ",", "\[Eta]"}], "}"}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Zeta]", "(", "t", ")"}], "=", "0"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "poincareSection[pathSol_, {\[Xi]_, \[Eta]_}, \[Zeta]_] :=\n\
Module[{\[Zeta]L, tL, t\[Zeta]L, t\[Zeta]LPairs, ts, points}, \n ",
  StyleBox["(* find times where \[Zeta] vanishes *)", "CodeComment"],
  "\n \[Zeta]L = Transpose[Partition[(\[Zeta] /. pathSol[[1]])[[4, 2]], \
2]][[1]];\n tL = (\[Zeta] /. pathSol[[1]])[[3, 1]];\n t\[Zeta]L = \
Transpose[Partition[#, 2, 1]& /@ {tL, \[Zeta]L}];\n t\[Zeta]LPairs = Select[t\
\[Zeta]L, (#[[2, 1]] #[[2, 2]] < 0)&];\n ",
  StyleBox["(* use linear interpolation *)", "CodeComment"],
  "\n ts = (#1[[1]] + #2[[1]]/(#2[[1]] - #2[[2]])*\n       (#1[[2]] - \
#1[[1]]))& @@@ t\[Zeta]LPairs;\n ",
  StyleBox["(* {\[Xi], \[Eta]} at the times ts *)", "CodeComment"],
  "\n points = ({\[Xi][#], \[Eta][#]}& /@ ts) /. pathSol[[1]];\n ",
  StyleBox["(* form Poincare plot graphics *)", "CodeComment"],
  "\n Graphics[{PointSize[0.003], Point /@ points},\n       PlotRange -> All, \
AspectRatio -> 1, Frame -> True, \n       FrameTicks -> False, PlotLabel -> {\
\[Xi], \[Eta]}, Axes -> False]]"
}], "Input"],

Cell[TextData[{
  "For a given path, the function ",
  StyleBox["poincarePlots", "MR"],
  " shows the four Poincar\[EAcute] plots ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}], TraditionalForm]]],
  " at ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["x", "\[Prime]"], "(", "t", ")"}], "=", "0"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"x", ",", "y"}], "}"}], TraditionalForm]]],
  " at ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SuperscriptBox["y", "\[Prime]"], "(", "t", ")"}], "=", "0"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SuperscriptBox["x", "\[Prime]"], ",", 
            SuperscriptBox["y", "\[Prime]"]}], "}"}], TraditionalForm]]],
  " at ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"x", "(", "t", ")"}], "=", "0"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SuperscriptBox["x", "\[Prime]"], ",", 
            SuperscriptBox["y", "\[Prime]"]}], "}"}], TraditionalForm]]],
  " at ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"x", "(", "t", ")"}], "=", "0"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
poincarePlots[pathSol_] := 
Show[GraphicsArray[poincareSection[pathSol, #1, #2]& @@@
{{{x, y}, vx}, {{x, y}, vy}, {{vx, vy}, x}, {{vx, vy}, y}}]]\
\>", "Input"],

Cell[TextData[{
  "Here are the Poincar\[EAcute] plots corresponding to the above parametric \
and phase plots. To obtain enough intersections of the coordinate planes with \
the trajectory, we now propagate to the much larger time ",
  Cell[BoxData[
      FormBox[
        RowBox[{"t", "=", "5000"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
poincarePlots[path[{0, 0}, #2, 
                   {1, Sequence @@ #1}, 5000]]& @@@ \
v\[Beta]\[Delta]Data\
\>", "Input"],

Cell[TextData[{
  "(For closed\[Hyphen]form solutions of the classical \
H\[EAcute]non\[Dash]Heiles potential, see [",
  
  CounterBox["BibliographyCounter", "Vernov02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Vernov02",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Vernov03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Vernov03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "VigoAguiar03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"VigoAguiar03",
    ButtonStyle->"Hyperlink"],
  "].)"
}], "Text"],

Cell[TextData[{
  "We continue with the quantum mechanical treatment of the generalized H\
\[EAcute]non\[Dash]Heiles potential. To calculate the quantum mechanical \
eigenfunctions, we have to diagonalize the Hamiltonian corresponding to ",
  Cell[BoxData[
      FormBox[
        RowBox[{"V", "(", 
          RowBox[{"x", ",", "y"}], ")"}], TraditionalForm]]],
  " in a truncated 2D harmonic oscillator basis. We write the matrix elements \
as a sum of the harmonic oscillator diagonal terms and perturbation terms. \
(This avoids the need for the explicit calculation of the matrix elements of \
the kinetic part in exchange for the \
anyway\[Hyphen]to\[Hyphen]be\[Hyphen]calculated matrix element of the ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["r", "2"], TraditionalForm]]],
  " term.) So we have (using the notations ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["H", "0"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["V", "0"], TraditionalForm]]],
  " for the Hamiltonian and the potential of the 2D harmonic oscillator) the \
following expression for a generic matrix element:"
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{
            SubscriptBox["n", "1"], ",", 
            RowBox[{
              SubscriptBox["m", "1"], "|", 
              RowBox[{
                RowBox[{
                  RowBox[{"-", 
                    FractionBox[
                      SuperscriptBox["\[HBar]", "2"], 
                      RowBox[{"2", "M"}]]}], "\[CapitalDelta]"}], "+", "V"}], 
              "|", 
              SubscriptBox["n", "2"]}], ",", 
            SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], "=", 
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{
            SubscriptBox["n", "1"], ",", 
            RowBox[{
              SubscriptBox["m", "1"], "|", 
              RowBox[{
                SubscriptBox["H", "0"], "+", "V", "-", 
                SubscriptBox["V", "0"]}], "|", 
              SubscriptBox["n", "2"]}], ",", 
            SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{"=", 
        RowBox[{
          RowBox[{
            RowBox[{
              RowBox[{"(", 
                RowBox[{
                  RowBox[{"2", 
                    SubscriptBox["n", "1"]}], "+", 
                  SubscriptBox["m", "1"], "+", "1"}], ")"}], 
              SubscriptBox["\[Delta]", 
                RowBox[{
                  SubscriptBox["m", "1"], ",", 
                  SubscriptBox["m", "2"]}]], 
              SubscriptBox["\[Delta]", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", 
                  SubscriptBox["n", "2"]}]], "\[HBar]", " ", "\[Omega]"}], 
            "+", 
            RowBox[{"\[LeftAngleBracket]", 
              RowBox[{
                SubscriptBox["n", "1"], ",", 
                RowBox[{
                  SubscriptBox["m", "1"], "|", 
                  RowBox[{"V", "-", 
                    RowBox[{
                      FractionBox[
                        RowBox[{"M", " "}], "2"], 
                      SuperscriptBox["\[Omega]", "2"], 
                      SuperscriptBox["r", "2"]}]}], "|", 
                  SubscriptBox["n", "2"]}], ",", 
                SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}]}], "=", 
          "\[IndentingNewLine]", 
          RowBox[{
            RowBox[{
              RowBox[{"(", 
                RowBox[{
                  RowBox[{"2", 
                    SubscriptBox["n", "1"]}], "+", "m", "+", "1"}], ")"}], 
              SubscriptBox["\[Delta]", 
                RowBox[{
                  SubscriptBox["m", "1"], ",", 
                  SubscriptBox["m", "2"]}]], 
              SubscriptBox["\[Delta]", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", 
                  SubscriptBox["n", "2"]}]], "\[HBar]", " ", "\[Omega]"}], 
            "+", " ", 
            RowBox[{"\[LeftAngleBracket]", 
              RowBox[{
                SubscriptBox["n", "1"], ",", 
                RowBox[{
                  SubscriptBox["m", "1"], "|", 
                  RowBox[{
                    RowBox[{"\[Alpha]", " ", 
                      SuperscriptBox["r", "4"]}], "+", 
                    RowBox[{"\[Beta]", " ", 
                      SuperscriptBox["r", "2"]}], "-", 
                    RowBox[{
                      FractionBox[
                        RowBox[{"M", " "}], "2"], 
                      SuperscriptBox["\[Omega]", "2"], 
                      SuperscriptBox["r", "2"]}]}], "|", 
                  SubscriptBox["n", "2"]}], ",", 
                SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], "+", 
            "\[IndentingNewLine]", 
            RowBox[{
              RowBox[{"\[LeftAngleBracket]", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", 
                  RowBox[{
                    SubscriptBox["m", "1"], "|", 
                    RowBox[{"\[Gamma]", " ", 
                      RowBox[{"cos", "(", 
                        RowBox[{"3", "\[CurlyPhi]"}], ")"}], 
                      SuperscriptBox["r", "3"]}], "|", 
                    SubscriptBox["n", "2"]}], ",", 
                  SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], 
              "."}]}]}]}], TraditionalForm]}], "DisplayFormula",
  SpanMaxSize->Infinity],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]independent potential term is diagonal in the angular quantum \
numbers ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "2"], TraditionalForm]]],
  ". "
}], "Text",
  SpanMaxSize->Infinity],

Cell[BoxData[
    FormBox[
      RowBox[{
        StyleBox[" ",
          SpanMaxSize->1], 
        RowBox[{
          StyleBox[
            RowBox[{"\[LeftAngleBracket]", 
              RowBox[{
                SubscriptBox["n", "1"], ",", 
                RowBox[{
                  SubscriptBox["m", "1"], "|", 
                  RowBox[{
                    RowBox[{"\[Alpha]", " ", 
                      SuperscriptBox["r", "4"]}], "+", 
                    RowBox[{"\[Beta]", " ", 
                      SuperscriptBox["r", "2"]}], "-", 
                    RowBox[{
                      FractionBox[
                        RowBox[{"M", " "}], "2"], 
                      SuperscriptBox["\[Omega]", "2"], 
                      SuperscriptBox["r", "2"]}]}], "|", 
                  SubscriptBox["n", "2"]}], ",", 
                SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}],
            SpanMaxSize->1], 
          StyleBox["=",
            SpanMaxSize->1], 
          StyleBox[" ",
            SpanMaxSize->1], 
          RowBox[{
            StyleBox[
              SubscriptBox[
                RowBox[{
                  SubscriptBox["\[Delta]", 
                    RowBox[{
                      SubscriptBox["m", "1"], ",", 
                      SubscriptBox["m", "2"]}]], " \[InvisibleSpace]"}], 
                RowBox[{"r", "\[NegativeThinSpace]"}]],
              SpanMaxSize->1], 
            RowBox[{
              SubscriptBox[
                RowBox[{"\[LeftAngleBracket]", 
                  RowBox[{
                    SubscriptBox["n", "1"], ",", 
                    RowBox[{
                      SubscriptBox["m", "1"], "|", 
                      RowBox[{
                        RowBox[{"\[Alpha]", " ", 
                          SuperscriptBox["r", "4"]}], "+", 
                        RowBox[{"\[Beta]", " ", 
                          SuperscriptBox["r", "2"]}], "-", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"M", " "}], "2"], 
                          SuperscriptBox["\[Omega]", "2"], 
                          SuperscriptBox["r", "2"]}]}], 
                      "\[InvisibleSpace]\[NegativeThinSpace]", "|", 
                      SubscriptBox["n", "2"]}], ",", 
                    SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], "r"], 
              "."}]}]}]}], TraditionalForm]], "DisplayFormula",
  SpanMaxSize->Infinity],

Cell[TextData[{
  "The ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]dependent potential term factors into an angular and an radial \
part."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{
            SubscriptBox["n", "1"], ",", 
            RowBox[{
              SubscriptBox["m", "1"], "|", 
              RowBox[{
                RowBox[{"cos", "(", 
                  RowBox[{"3", "\[CurlyPhi]"}], ")"}], 
                SuperscriptBox["r", "3"]}], "|", 
              SubscriptBox["n", "2"]}], ",", 
            SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], " ", "=", 
        RowBox[{
          SubscriptBox["\<\"\[InvisiblePrefixScriptBase]\"\>", 
            RowBox[{"\[CurlyPhi]", "\[NegativeThinSpace]"}]], 
          SubscriptBox[
            RowBox[{
              SubscriptBox[
                RowBox[{"\[LeftAngleBracket]", 
                  RowBox[{
                    SubscriptBox["m", "1"], "|", 
                    RowBox[{"cos", "(", 
                      RowBox[{"3", "\[CurlyPhi]"}], ")"}], 
                    "\[InvisibleSpace]\[NegativeThinSpace]", "|", 
                    SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], 
                "\[CurlyPhi]"], 
              "  \[InvisibleSpace]\[InvisibleSpace] \[InvisibleSpace]"}], 
            RowBox[{"r", "\[NegativeThinSpace]"}]], 
          RowBox[{
            SubscriptBox[
              RowBox[{"\[LeftAngleBracket]", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", 
                  RowBox[{
                    SubscriptBox["m", "1"], "|", 
                    RowBox[{"\[Gamma]", " ", 
                      SuperscriptBox["r", "3"]}], "\[InvisibleSpace]", "|", 
                    SubscriptBox["n", "2"]}], ",", 
                  SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], "r"], 
            "."}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "We anticipate (from the corresponding 1D examples of Chapter 2) needing a \
few hundred angular and a few hundred radial basis states of the harmonic \
oscillator. This means we will have in the order of a few ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "4"], TraditionalForm]]],
  " product basis states and the resulting Hill matrix will have in the order \
",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "9"], TraditionalForm]]],
  " matrix elements. Calculating (or storing and manipulating) ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "9"], TraditionalForm]]],
  " matrix elements individually is, of course, hopeless. However, being an \
exercise, we anticipate that for a given set of quantum numbers ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ", only finitely many states ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"|", 
              SubscriptBox["n", "2"]}], ",", 
            SubscriptBox["m", "2"]}], "\[RightAngleBracket]"}], 
        TraditionalForm]],
    AutoStyleOptions->{"UnmatchedBracketStyle"->None}],
  " will have nontrivial matrix elements with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"V", "(", 
          RowBox[{"x", ",", "y"}], ")"}], TraditionalForm]]],
  ". These nonvanishing matrix elements we will use to create and diagonalize \
a sparse matrix. Calculating explicit forms of these matrix elements is the \
next step."
}], "Text"],

Cell[TextData[{
  "Instead of using the complex\[Hyphen]valued eigenfunctions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{
            RowBox[{"\[PlusMinus]", "i"}], " ", "m", " ", "\[CurlyPhi]"}], 
          ")"}], TraditionalForm]]],
  ", we will use the real\[Hyphen]valued ones ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cos", " ", 
          RowBox[{"(", 
            RowBox[{"m", " ", "\[CurlyPhi]"}], ")"}]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sin", "(", 
          RowBox[{"m", " ", "\[CurlyPhi]"}], ")"}], TraditionalForm]]],
  ". While this slightly complicates some of the following calculations, we \
gain two advantages: a) Because the potential ",
  Cell[BoxData[
      FormBox[
        RowBox[{"V", "(", 
          RowBox[{"x", ",", " ", "y"}], ")"}], TraditionalForm]]],
  " is mirror symmetric with respect to the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis, so will be the eigenfunctions. This means in the \
eigenfunction expansions we can use a smaller matrix size to take a fixed \
number of basis states into account. b) All arithmetic needed will only \
operate on real numbers, which is considerably faster than complex number \
calculations. An additional small benefit of the division in even and odd \
states is the possibility to optimize the graphics constructions later when \
we visualize the eigenfunctions."
}], "Text"],

Cell["The basic angular orthogonality integrals are", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", 
              RowBox[{"2", "\[Pi]"}]], 
            RowBox[{
              RowBox[{"cos", "(", 
                RowBox[{
                  SubscriptBox["m", "1"], "\[CurlyPhi]"}], ")"}], 
              RowBox[{"cos", "(", 
                RowBox[{
                  SubscriptBox["m", "2"], "\[CurlyPhi]"}], ")"}], "d", 
              "\[InvisibleSpace]", "\[CurlyPhi]"}]}], "=", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"1", "+", 
                SubscriptBox[
                  InterpretationBox["\[Delta]",
                    KroneckerDelta,
                    Editable->False,
                    Selectable->False], 
                  RowBox[{
                    SubscriptBox["m", "1"], ",", "0"}]]}], ")"}], 
            SubscriptBox[
              InterpretationBox["\[Delta]",
                KroneckerDelta,
                Editable->False,
                Selectable->False], 
              RowBox[{
                SubscriptBox["m", "1"], ",", 
                SubscriptBox["m", "2"]}]], "\[Pi]", "     ", "for", " ", 
            SubscriptBox["m", "1"]}]}], ",", " ", 
        RowBox[{
          SubscriptBox["m", "2"], "=", "0"}], ",", "1", ",", "2", ",", 
        "\[Ellipsis]"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", 
              RowBox[{"2", "\[Pi]"}]], 
            RowBox[{
              RowBox[{"sin", "(", 
                RowBox[{
                  SubscriptBox["m", "1"], "\[CurlyPhi]"}], ")"}], 
              RowBox[{"sin", "(", 
                RowBox[{
                  SubscriptBox["m", "2"], "\[CurlyPhi]"}], ")"}], "d", 
              "\[InvisibleSpace]", "\[CurlyPhi]"}]}], "=", 
          RowBox[{
            SubscriptBox[
              InterpretationBox["\[Delta]",
                KroneckerDelta,
                Editable->False,
                Selectable->False], 
              RowBox[{
                SubscriptBox["m", "1"], ",", 
                SubscriptBox["m", "2"]}]], "\[Pi]", "     ", "for", " ", 
            SubscriptBox["m", "1"]}]}], ",", " ", 
        RowBox[{
          SubscriptBox["m", "2"], "=", "1"}], ",", "2", ",", "\[Ellipsis]"}], 
      TraditionalForm]], "DisplayFormula"],

Cell["and the basic radial orthogonality integral is", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
          RowBox[{
            SuperscriptBox["t", "\[Lambda]"], " ", 
            SuperscriptBox["e", 
              RowBox[{"-", "t"}]], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                SubscriptBox["n", "1"], "\[Lambda]"], "(", "t", ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                SubscriptBox["n", "2"], "\[Lambda]"], "(", "t", ")"}], "d", 
            "\[InvisibleSpace]", "t"}]}], "=", 
        RowBox[{
          FractionBox[
            RowBox[{
              RowBox[{
                RowBox[{"(", 
                  RowBox[{
                    SubscriptBox["n", "1"], "+", "\[Lambda]", "+", "1"}], 
                  ")"}], "!"}], " "}], 
            RowBox[{
              SubscriptBox["n", "1"], "!"}]], 
          RowBox[{
            SubscriptBox[
              InterpretationBox["\[Delta]",
                KroneckerDelta,
                Editable->False,
                Selectable->False], 
              RowBox[{
                SubscriptBox["n", "1"], ",", 
                SubscriptBox["n", "2"]}]], "."}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "To reduce products of powers of ",
  Cell[BoxData[
      FormBox["r", TraditionalForm]]],
  " with the Laguerre polynomials to this standard form, we make use of the \
following two recursion relations for associated Laguerre polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}], 
        TraditionalForm]]],
  " [",
  
  CounterBox["BibliographyCounter", "Cardeso03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Cardeso03",
    ButtonStyle->"Hyperlink"],
  "]:"
}], "Text"],

Cell[BoxData[{
    FormBox[
      RowBox[{
        RowBox[{"z", " ", 
          RowBox[{
            SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}]}], "=", 
        
        RowBox[{
          RowBox[{
            RowBox[{"-", 
              RowBox[{"(", 
                RowBox[{"n", "+", "\[Lambda]"}], ")"}]}], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                RowBox[{"n", "-", "1"}], "\[Lambda]"], "(", "z", ")"}]}], "+",
           
          RowBox[{
            RowBox[{"(", 
              RowBox[{
                RowBox[{"2", " ", "n"}], "+", "\[Lambda]", "+", "1"}], ")"}], 
            " ", 
            RowBox[{
              SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}]}], 
          "-", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"n", "+", "1"}], ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                RowBox[{"n", "+", "1"}], "\[Lambda]"], "(", "z", ")"}]}]}]}], 
      TraditionalForm], "\[IndentingNewLine]", 
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["L", "n", 
            RowBox[{"\[Lambda]", "+", "1"}]], "(", "z", ")"}], "=", 
        RowBox[{
          RowBox[{
            RowBox[{"(", 
              RowBox[{"\[Lambda]", "+", "n"}], ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                RowBox[{"n", "-", "1"}], "\[Lambda]"], "(", "z", ")"}]}], "+",
           
          RowBox[{
            RowBox[{"(", 
              RowBox[{"z", "-", "n"}], ")"}], " ", 
            RowBox[{
              RowBox[{
                SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}], 
              "."}]}]}]}], TraditionalForm]}], "DisplayFormula"],

Cell["Off[General::spell1]; Off[General::spell1]; ", "Input"],

Cell[TextData[{
  "Here are the even and odd eigenfunctions of the 2D harmonic oscillator. \
Because later we will set ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[HBar]", "=", 
          RowBox[{"M", "=", "1"}]}], TraditionalForm]]],
  ", we do not include these variables as arguments in the left\[Hyphen]hand \
sides of the corresponding function definitions for ",
  StyleBox["R", "MR"],
  ", ",
  StyleBox["\[Psi]Even", "MR"],
  ", and ",
  StyleBox["\[Psi]Odd", "MR"],
  ". We will set a value for ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " later globally (to avoid a cluttered notation we also do not use ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " as an explicit argument)."
}], "Text"],

Cell[TextData[{
  StyleBox["(* natural length scale *)", "CodeComment"],
  "\nL = Sqrt[\[HBar]/(M \[Omega])];\n\n",
  StyleBox["(* angular momentum eigenfunctions *)", "CodeComment"],
  "\n\[CapitalPhi]Odd[m_, \[CurlyPhi]_] = 1/Sqrt[Pi] Sin[m \[CurlyPhi]];\n",
  StyleBox["(* normalization for even states with m = 0 is special *)", 
    "CodeComment"],
  "\n\[CapitalPhi]Even[m_, \[CurlyPhi]_] = (1 - (1 - 1/Sqrt[2])  \
KroneckerDelta[m]) *\n                1/Sqrt[Pi] Cos[m \[CurlyPhi]];\n\n",
  StyleBox["(* radial momentum eigenfunctions *)", "CodeComment"],
  "\nR[n_, m_, r_] := Sqrt[2]/L Sqrt[n!/(n + m)!] (r/L)^m*\n                 \
Exp[-(r/L)^2/2] LaguerreL[n, m, (r/L)^2];\n    \n",
  StyleBox["(* 2D eigenfunctions *)", "CodeComment"],
  "\n\[Psi]Odd[n_, m_, r_, \[CurlyPhi]_] := \[CapitalPhi]Odd[m, \[CurlyPhi]] \
R[n, m, r];\n\[Psi]Even[n_, m_, r_, \[CurlyPhi]_] := \[CapitalPhi]Even[m, \
\[CurlyPhi]] R[n, m, r];"
}], "Input"],

Cell[TextData[{
  "Without loss of generality, we can later set ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[HBar]", "=", 
          RowBox[{"M", "=", "1"}]}], TraditionalForm]]],
  ". While the eigenfunctions are complete for every values of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ", we will not set ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " to a specific value, but rather keep it as a parameter that will allow to \
radially expand and contract the basis."
}], "Text"],

Cell["\<\
Here is a quick check of the correctness and normalization of the \
eigenfunctions.\
\>", "Text"],

Cell["\<\
Schr\[ODoubleDot]dingerOperatorHO2D[\[Psi]_, {r_, \[CurlyPhi]_}] :=
-\[HBar]^2/(2 M) (1/r D[r D[\[Psi], r], r] + 1/r^2 D[\[Psi], \[CurlyPhi], \
\[CurlyPhi]]) + 1/2 M \[Omega]^2 r^2 \[Psi]\
\>", "Input"],

Cell[TextData[{
  "Block[{psi},\nTable[psi = \[Psi]Even[n, m, r, \[CurlyPhi]]; \n      ",
  StyleBox["(* check if Schr\[ODoubleDot]dinger equation is fulfilled *)", 
    "CodeComment"],
  "\n      Expand[Schr\[ODoubleDot]dingerOperatorHO2D[psi, {r, \[CurlyPhi]}] \
- \n      (2n + Abs[m] + 1) \[HBar] \[Omega] psi] == 0, {n, 0, 2}, {m, 0, \
2}]] //\n                                                Flatten // Union"
}], "Input"],

Cell[TextData[{
  "Block[{\[HBar] = 1, M = 1, \[Omega] = 1},\nTable[",
  StyleBox["(* check normalization of eigenfunctions *)", "CodeComment"],
  "\n      Integrate[\[Psi]Even[n1, m1, r, \[CurlyPhi]] \[Psi]Even[n2, m2, r, \
\[CurlyPhi]] r, \n                {\[CurlyPhi], 0, 2Pi}, {r, 0, Infinity}] ==\
\n      KroneckerDelta[n1, n2] KroneckerDelta[m1, m2],\n      {n1, 0, 2}, \
{m1, 0, 2}, {n2, 0, n1}, {m2, 0, m1}]] //\n                                   \
            Flatten // Union"
}], "Input"],

Cell[TextData[{
  "As a side step, let us have a quick look at the radial eigenfunctions. For \
increasing ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ", the eigenfunctions extend further radially outwards."
}], "Text"],

Cell[TextData[{
  "Block[{M = 1, \[HBar] = 1, \[Omega] = 1},\n Show[Graphics3D[\n      \
Table[{Hue[0.8 m/(3 n)], \n             Line[Table[Evaluate[{r, n, R[n, m, \
r]^2}], \n                        {r, 0, 10, 1/10}]]},\n            {n, 0, \
8}, {m, ",
  StyleBox["(* odd states *)", "CodeComment"],
  " 1, 3 n}]],\n            BoxRatios -> {2.4, 1, 1}, PlotRange -> All,\n     \
       Axes -> True, AxesLabel -> {\"r\", \"n\", \[Psi]^2}]]"
}], "Input"],

Cell[TextData[{
  "The next graphic shows the position of the maxima of ",
  StyleBox["R[", "MR"],
  StyleBox["n", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["m", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["r", "TI"],
  StyleBox["]", "MR"],
  " for a fixed ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "12"}], TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
radialMaxima[n_, m_, rMax_] :=
Block[{M = 1, \[HBar] = 1, \[Omega] = 1},
Point[{#[[2, 1]], Log[#[[2, 2]]]}]& /@ 
Select[Partition[Plot[Evaluate[R[n, m, r]^2], {r, 0, rMax},
                      PlotPoints -> 20,
                      DisplayFunction -> Identity][[1, 1, 1, 1]], 
                 3, 1], (#[[1, 2]] < #[[2, 2]] > #[[3, 2]])&]]\
\>", "Input"],

Cell["\<\
Block[{n = 12},
Show[Graphics[
      Table[{Hue[0.8 m/(8n)], radialMaxima[n, m, 16]},
            {m, 1, 8n, 4}]], PlotRange -> {0, -5}, Axes -> True]]\
\>", \
"Input"],

Cell[TextData[{
  "We have to decide which harmonic oscillator eigenfunctions to include in \
the truncated basis. We have a doubly infinite set of eigenfunctions. The \
above graphics showed that for an increasing ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ", the eigenfunctions expand increasingly radially outwards. The \
generalized H\[EAcute]non\[Dash]Heiles potential is bounded in asymptotically \
increasing in every direction due to the ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["r", "4"], TraditionalForm]]],
  " term. This means, all the energy eigenfunctions will be well localized in \
the corresponding classically allowed region. So we fix an energy ",
  StyleBox["\[CurlyEpsilon]", "TI",
    FontSlant->"Plain"],
  StyleBox["o", "TI"],
  ", and take all eigenfunctions having an energy less than or equal to ",
  StyleBox["\[CurlyEpsilon]", "TI",
    FontSlant->"Plain"],
  StyleBox["o", "TI"],
  " into account. We sort these selected eigenfunctions by energy, and in \
case of degeneracy, by increasing ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ". The functions ",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " and ",
  StyleBox["numberOddBasisFunctions", "MR"],
  " carry out this selection and ordering process. They create the globally \
visible functions ",
  StyleBox["efNumber", "MR"],
  " and ",
  StyleBox["nmNumbers", "MR"],
  " and the variable ",
  StyleBox["dim", "MR"],
  ". For a given pair of quantum numbers ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ", the function ",
  StyleBox["efNumber", "MR"],
  " returns the position of this state in the basis. For a given position 1, \
2, \[Ellipsis], in the basis state, the function ",
  StyleBox["nmNumbers", "MR"],
  " returns the pair of quantum numbers ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ". ",
  StyleBox["dim", "TI"],
  " is the dimension of the basis. (For a cleaner, \[OpenCurlyDoubleQuote] \
production code\[CloseCurlyDoubleQuote] quality programming one could export \
pure functions with a dispatched rule table in the body for ",
  StyleBox["efNumber", "MR"],
  ", to keep all parts modular and well separated. But for the purpose of \
visualizing some eigenstates, which is the sole goal of this exercise, the \
current approach is appropriate.)"
}], "Text"],

Cell[TextData[{
  "numberEvenBasisFunctions[\[CurlyEpsilon]o_] :=\n\
Module[{energyOrderedQuantumNumbers, nmPairs},\n ",
  StyleBox["(* order pairs of quantum numbers {n, m} by energy *)", 
    "CodeComment"],
  "\n energyOrderedQuantumNumbers = \n  {#[[1, 2]], Sort[First /@ #]}& /@ \
Split[Sort[Select[Flatten[\n  Table[{{n, m}, 2 n + m + 1}, \n        {n, 0, \
\[CurlyEpsilon]o/2}, {m, 0, \[CurlyEpsilon]o}], 1], #[[-1]] <= \
\[CurlyEpsilon]o&],\n        #1[[-1]] < #2[[-1]]&], #1[[-1]] == #2[[-1]]&];\n \
",
  StyleBox["(* export the functions efNumber and nmNumbers the number dim *)",
     "CodeComment"],
  "\n Clear[efNumber, nmNumbers]; \n (efNumber[#1] = #2; nmNumbers[#2] = #1)& \
@@@\n MapIndexed[{#1, #2[[1]]}&, nmPairs =\n            Flatten[Last /@ \
energyOrderedQuantumNumbers, 1]];\n dim = Length[nmPairs]]"
}], "Input"],

Cell[TextData[{
  StyleBox["(* no m == 0 states in the odd functions *)", "CodeComment"],
  "\nDownValues[numberOddBasisFunctions] =\n \
DownValues[numberEvenBasisFunctions] /.\n  {numberEvenBasisFunctions -> \
numberOddBasisFunctions,\n   HoldPattern[{m, 0, \[CurlyEpsilon]o}] :> {m, 1, \
\[CurlyEpsilon]o}};"
}], "Input"],

Cell[TextData[{
  "Here is an example of the ordered ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " quantum numbers up to energy ",
  Cell[BoxData[
      FormBox[
        RowBox[{"12", "\[HBar]\[Omega]"}], TraditionalForm]]],
  ". The odd basis misses the states with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", "0"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
numberEvenBasisFunctions[12];
nmNumbers /@ Range[dim]\
\>", "Input"],

Cell["\<\
numberOddBasisFunctions[12];
nmNumbers /@ Range[dim]\
\>", "Input"],

Cell[TextData[{
  "The number of basis states grows quadratically with the energy \
\[CurlyEpsilon]",
  StyleBox["o", "TI"],
  ". With energies in the few hundreds, we have a few ten thousand basis \
states."
}], "Text"],

Cell[TextData[{
  StyleBox["(* count even and odd  basis sizes as a function of \
\[CurlyEpsilon]o *)", "CodeComment"],
  "\nFunction[\[CurlyEpsilon]o, {\[CurlyEpsilon]o, numberEvenBasisFunctions[\
\[CurlyEpsilon]o]; dim,\n                  numberOddBasisFunctions[\
\[CurlyEpsilon]o]; dim}] /@\n                      {1, 5, 10, 50, 100, 200, \
250, 500}"
}], "Input"],

Cell[TextData[{
  "Because of the virial theorem, the average squared distance of the state \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[LeftAngleBracket]", 
          RowBox[{"r", ",", 
            RowBox[{"\[CurlyPhi]", "|", "n"}], ",", "m"}], 
          "\[RightAngleBracket]"}], TraditionalForm]]],
  " is proportional to the energy ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[CurlyEpsilon]", 
          RowBox[{"n", ",", "m"}]], TraditionalForm]]],
  ". This means that the ordering of the states carried out by the functions \
",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " and ",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " can model states efficiently with an approximately known spatial \
extension."
}], "Text"],

Cell[TextData[{
  "rSquareMean[{n_, m_}] := \nBlock[{M = 1, \[HBar] = 1, \[Omega] = 1},\n     \
 ",
  StyleBox["(* mean square spatial extension *)", "CodeComment"],
  "\n      Integrate[r^2 R[n, m, r]^2 r, {r, 0, Infinity}]]"
}], "Input"],

Cell["\<\
numberEvenBasisFunctions[12];
rSquareMean /@ (nmNumbers /@ Range[dim])\
\>", "Input"],

Cell[TextData[{
  "We use the sorted\[Hyphen]by\[Hyphen]energy states for making one more \
graphic\[LongDash]the integrated local density of states as a function of the \
radius and the energy up to ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyEpsilon]", "max"], "=", "36"}], 
        TraditionalForm]]],
  ". The left graphic shows the integrated (over the energy) local density of \
states. The emergence of the classical limit is clearly visible. The right \
graphic shows the oscillations (due to the oscillating nature of the Laguerre \
polynomials) of the density of states better by subtracting the \
nonoscillating Thomas\[Dash]Fermi contribution (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Tilde]", 
          RowBox[{
            RowBox[{"(", 
              RowBox[{"\[CurlyEpsilon]", "-", 
                RowBox[{"V", "(", 
                  StyleBox["r",
                    FontWeight->"Bold",
                    FontSlant->"Plain"], ")"}]}], ")"}], 
            RowBox[{"\[Theta]", "(", 
              RowBox[{"\[CurlyEpsilon]", "-", 
                RowBox[{"V", "(", 
                  StyleBox["r",
                    FontWeight->"Bold",
                    FontSlant->"Plain"], ")"}]}], ")"}]}]}], 
        TraditionalForm]]],
  ") [",
  
  CounterBox["BibliographyCounter", "Brack93"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Brack93",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "Block[{\[CurlyEpsilon]Max = 36, rMax = 10, ",
  StyleBox["(* avoid 0^0 *)", "CodeComment"],
  " rMin = 10^-6, \n       ppr = 160, \[HBar] = 1, M = 1, \[Omega] = 1,\n     \
  nmGroups, \[Psi]Data, ldos, polysH, polysV, opts},\n ",
  StyleBox["(* the eigenfunctions up to energy \[CurlyEpsilon]Max *)", 
    "CodeComment"],
  "\n numberEvenBasisFunctions[\[CurlyEpsilon]Max];\n nmGroups = Map[Last, \
Split[{2#1 + #2 + 1, {##}}& @@@ \n                (nmNumbers /@ Range[dim]), \
#1[[1]] === #2[[1]]&], {2}];\n ",
  StyleBox["(* summed squared eigenfunctions times r *)", "CodeComment"],
  "\n \[Psi]Data = FoldList[Plus, Table[0, {r, rMin, rMax, (rMax - \
rMin)/ppr}],  \n          ",
  StyleBox["(* sum eigenfunctions for a fixed energy *)", "CodeComment"],
  " Plus @@@ \n           Apply[Table[If[#2 === 0, 1/2, 1] R[#1, #2, N[r]]^2, \
\n                 {r, rMin, rMax, (rMax - rMin)/ppr}]&, nmGroups, {2}]];\n \
",
  StyleBox["(* local density of states *)", "CodeComment"],
  "\n ldos = MapIndexed[{rMin + (#2[[2]] - 1)/ppr (rMax - rMin), \n           \
         #2[[1]] - 1, #1}&, \[Psi]Data, {2}]; LD = ldos;\n polysH = ",
  StyleBox["(* horizontal polygons *)", "CodeComment"],
  "\n Table[Polygon[{ldos[[k, i]], ldos[[k, i + 1]],\n                \
ldos[[k, i + 1]] + {0, 1, 0},\n                ldos[[k, i]] + {0, 1, 0}}], \n \
      {k, Length[ldos]}, {i, Length[ldos[[k]]] - 1}];\n polysV = ",
  StyleBox["(* vertical polygons *)", "CodeComment"],
  "\n Table[Polygon[{ldos[[k, i]], ldos[[k, i + 1]],\n                ldos[[k \
+ 1, i + 1]], ldos[[k + 1, i]]}], \n       {k, Length[ldos] - 1}, {i, \
Length[ldos[[k]]] - 1}];\n ",
  StyleBox["(* graphics of the local density of states *)\n ", 
    "CodeComment"],
  "opts = Sequence[PlotRange -> All, Axes -> True, \n                 \
BoxRatios -> {2, 2, 1}];\n Show[GraphicsArray[\n {",
  StyleBox["(* total integrated density of states *)", "CodeComment"],
  "\n  Graphics3D[{EdgeForm[], polysH, polysV}, \n             AxesLabel -> {\
\"r\", \"\[CurlyEpsilon]\", \"\[ScriptCapitalD]\"}, opts],\n  ",
  StyleBox["(* oscillating part of the total integrated density of states *)",
     "CodeComment"],
  "\n  Graphics3D[{EdgeForm[], polysH, polysV} /. \n   Polygon[l_] :> \
Polygon[Function[{r, \[CurlyEpsilon], \[ScriptCapitalD]}, \n    ",
  StyleBox["(* with subtracted Thomas-Fermi contribution *)", "CodeComment"],
  "\n    {r, \[CurlyEpsilon], \[ScriptCapitalD] - 1/2 (\[CurlyEpsilon] - \
r^2/2) UnitStep[\[CurlyEpsilon] - r^2/2]}] @@@ l], \n             AxesLabel \
-> {\"r\", \"\[CurlyEpsilon]\", \"\[Delta]\[ScriptCapitalD]\"}, opts]}]]]"
}], "Input"],

Cell[TextData[{
  "Next, we calculate the actual matrix elements. We start by calculating the \
matrix elements arising from the azimuthal eigenfunctions. For the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]independent parts of the potential the matrix elements are \
obviously ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{
            SubscriptBox["m", "1"], ",", 
            SubscriptBox["m", "2"]}]], TraditionalForm]]],
  ". For the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]dependent part, the function ",
  StyleBox["\[CurlyPhi]MatrixElement", "MR"],
  " calculates matrix elements in the form of Kronecker delta functions."
}], "Text"],

Cell[TextData[{
  "\[CurlyPhi]MatrixElement[{\[CapitalPhi]1_, \[CapitalPhi]2_}, {m1_, m2_}, \
\[CurlyPhi]Part_, \[CurlyPhi]_] := \n   TrigReduce[\[CapitalPhi]1 \
\[CurlyPhi]Part \[CapitalPhi]2] /. ",
  StyleBox["(* emulate integration *)\n   (* argument of Cos must vanish for \
nonvanishing integral *)", "CodeComment"],
  "\n   Cos[x_] :> With[{\[ScriptM]2 = m2 /. Solve[x == 0, m2][[1]]},\n       \
             2 Pi KroneckerDelta[m2, \[ScriptM]2]] // Expand"
}], "Input"],

Cell[TextData[{
  "For the odd\[Hyphen]odd matrix elements, we see nonvanishing terms of the \
form ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{
            SubscriptBox["m", "1"], ",", 
            RowBox[{
              SubscriptBox["m", "1"], "\[PlusMinus]", "3"}]}]], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{"1", ",", "2"}]], TraditionalForm]]],
  " and, because of symmetry ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{"2", ",", " ", "1"}]], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
\[CurlyPhi]MatrixElement[{\[CapitalPhi]Odd[m1, \[CurlyPhi]], \
\[CapitalPhi]Odd[m2, \[CurlyPhi]]}, {m1, m2}, Cos[3 \[CurlyPhi]], \
\[CurlyPhi]]\
\>", "Input"],

Cell[TextData[{
  "For a specific value of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ", the function ",
  StyleBox["MEOdd\[CurlyPhi]List", "MR"],
  " returns a list of the values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "2"], TraditionalForm]]],
  " so that we have a nonvanishing matrix element and its value."
}], "Text"],

Cell["\<\
MEOdd\[CurlyPhi]List[m1_?Positive] :=
Cases[{{3 - m1, -1/2}, {m1 + 3, 1/2}, {m1 - 3, 1/2}}, {_?Positive, _}]\
\>", \
"Input"],

Cell[TextData[{
  "The even\[Hyphen]even matrix elements have a similar structure. Because ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[CapitalPhi]", "0", 
            RowBox[{"(", "e", ")"}]], "(", "\[CurlyPhi]", ")"}], 
        TraditionalForm]]],
  " is now nonvanishing, we have also terms of the form ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{"0", ",", "3"}]], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{"3", ",", "0"}]], TraditionalForm]]],
  " (which, because of the different normalization for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", "0"}], TraditionalForm]]],
  ", are slightly different from ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Delta]", 
          RowBox[{
            SubscriptBox["m", "1"], ",", 
            RowBox[{
              SubscriptBox["m", "1"], "\[PlusMinus]", "3"}]}]], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
\[CurlyPhi]MatrixElement[{\[CapitalPhi]Even[m1, \[CurlyPhi]], \
\[CapitalPhi]Even[m2, \[CurlyPhi]]}, {m1, m2}, 
               Cos[3 \[CurlyPhi]], \[CurlyPhi]] // Simplify\
\>", "Input"],

Cell[TextData[{
  "For a specific value of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ", the function ",
  StyleBox["MEEven\[CurlyPhi]List", "MR"],
  " returns a list of the values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "2"], TraditionalForm]]],
  " so that we have a nonvanishing matrix element and its value."
}], "Text"],

Cell["\<\
MEEven\[CurlyPhi]List[m1_?NonNegative] :=
Cases[{If[m1 == 0, {3, 1/Sqrt[2]}, {}],
       If[m1 == 3, Sequence @@ {{0, 1/Sqrt[2]}, {m1 + 3, 1/2}}, {}],
       If[m1 != 0 && m1 != 3, 
          Sequence @@ {{3 - m1, 1/2}, {m1 + 3, 1/2}, {m1 - 3, 1/2}}, {}]},
      {_?NonNegative, _}]\
\>", "Input"],

Cell[TextData[{
  "The matrix elements between the even and the odd states vanish for the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cos", "(", 
          RowBox[{"3", "\[CurlyPhi]"}], ")"}], TraditionalForm]]],
  " potential part."
}], "Text"],

Cell["\<\
TrigReduce[\[CapitalPhi]Even[m1, \[CurlyPhi]] Cos[3 \[CurlyPhi]] \
\[CapitalPhi]Odd[m2, \[CurlyPhi]]] /. _Sin -> 0\
\>", "Input"],

Cell[TextData[{
  "Next, we calculate the integrals arising from the radial part of the \
matrix elements of the potential. For the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]independent potential part (meaning ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "1"], "=", 
          RowBox[{
            SubscriptBox["m", "2"], "=", "m"}]}], TraditionalForm]]],
  "), we have the two integrals ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
          RowBox[{
            SuperscriptBox["r", "\[CurlyEpsilon]"], 
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", "m"}]], "(", "r", ")"}], "  ", 
            
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "2"], ",", "m"}]], "(", "r", ")"}], " ", 
            "r", " ", "d", "\[InvisibleSpace]", "r"}]}], TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", "2"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", "4"}], TraditionalForm]]],
  ". After a change of variables ",
  Cell[BoxData[
      FormBox[
        RowBox[{"r", "\[Rule]", 
          RowBox[{"L", " ", 
            SuperscriptBox["z", 
              RowBox[{"1", "/", "2"}]]}]}], TraditionalForm]]],
  " these reduce to the following type integral [",
  
  CounterBox["BibliographyCounter", "Bell70"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Bell70",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Joshi75"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Joshi75",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Integral]", "0", 
            RowBox[{"\[Infinity]", " "}]], 
          RowBox[{
            SuperscriptBox["r", "\[CurlyEpsilon]"], 
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", "m"}]], "(", "r", ")"}], "  ", 
            
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "2"], ",", "m"}]], "(", "r", ")"}], " ", 
            "r", " ", "d", "\[InvisibleSpace]", "r"}]}], "=", 
        RowBox[{
          SuperscriptBox["L", "\[CurlyEpsilon]"], 
          SqrtBox[
            FractionBox[
              RowBox[{
                RowBox[{
                  SubscriptBox["n", "1"], "!"}], 
                RowBox[{
                  SubscriptBox["n", "2"], "!"}]}], 
              RowBox[{
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{
                      SubscriptBox["n", "1"], "+", 
                      RowBox[{
                      "\[LeftBracketingBar]", "m", 
                        "\[RightBracketingBar]"}]}], ")"}], "!"}], 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{
                      SubscriptBox["n", "2"], "+", 
                      RowBox[{
                      "\[LeftBracketingBar]", "m", 
                        "\[RightBracketingBar]"}]}], ")"}], "!"}]}]]], " ", 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "0", 
              RowBox[{"\[Infinity]", " "}]], 
            RowBox[{
              SuperscriptBox["z", 
                FractionBox["\[CurlyEpsilon]", "2"]], 
              SuperscriptBox["e", 
                RowBox[{"-", " ", 
                  SuperscriptBox["z", "2"]}]], " ", 
              SuperscriptBox["z", "m"], 
              RowBox[{
                SubsuperscriptBox["L", 
                  SubscriptBox["n", "1"], "m"], "(", "z", ")"}], 
              RowBox[{
                SubsuperscriptBox["L", 
                  SubscriptBox["n", "2"], "m"], "(", "z", ")"}], " ", "d", 
              "\[InvisibleSpace]", 
              RowBox[{"z", "."}]}]}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For the ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  "\[Hyphen]dependent potential part (meaning ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "\[PlusMinus]", "3"}]}], 
        TraditionalForm]]],
  " or ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "\[PlusMinus]", "1"}]}], 
        TraditionalForm]]],
  "), we have the two integral ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
          RowBox[{
            SuperscriptBox["r", "3"], 
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", "m"}]], "(", "r", ")"}], "  ", 
            
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "2"], ",", 
                  RowBox[{"m", "\[PlusMinus]", "\[Mu]"}]}]], "(", "r", ")"}], 
            " ", "r", " ", "d", "\[InvisibleSpace]", "r"}]}], 
        TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Mu]", "=", "3"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Mu]", "=", "1"}], TraditionalForm]]],
  " (for some special states ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["n", 
              RowBox[{"1", ",", "2"}]], "=", "1"}], ",", "2"}], 
        TraditionalForm]]],
  "). Carrying out again the change of variables ",
  Cell[BoxData[
      FormBox[
        RowBox[{"r", "\[Rule]", 
          RowBox[{"L", " ", 
            SuperscriptBox["z", 
              RowBox[{"1", "/", "2"}]]}]}], TraditionalForm]]],
  " these integrals reduces to the following (shown are only the cases of \
positive ",
  Cell[BoxData[
      FormBox["\[Mu]", TraditionalForm]]],
  ", the cases of negative ",
  Cell[BoxData[
      FormBox["\[Mu]", TraditionalForm]]],
  " follow from a simple shift in ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  ")."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Integral]", "0", 
            RowBox[{"\[Infinity]", " "}]], 
          RowBox[{
            SuperscriptBox["r", "3"], 
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "1"], ",", "m"}]], "(", "r", ")"}], "  ", 
            
            RowBox[{
              SubscriptBox["R", 
                RowBox[{
                  SubscriptBox["n", "2"], ",", 
                  RowBox[{"m", "+", "\[Mu]"}]}]], "(", "r", ")"}], " ", "r", 
            " ", "d", "\[InvisibleSpace]", "r"}]}], "=", 
        RowBox[{
          SuperscriptBox["L", 
            FractionBox[
              RowBox[{"3", "+", "\[Mu]"}], "2"]], 
          SqrtBox[
            FractionBox[
              RowBox[{
                RowBox[{
                  SubscriptBox["n", "1"], "!"}], 
                RowBox[{
                  SubscriptBox["n", "2"], "!"}]}], 
              RowBox[{
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{
                      SubscriptBox["n", "1"], "+", "m"}], ")"}], "!"}], 
                RowBox[{
                  RowBox[{"(", 
                    RowBox[{
                      SubscriptBox["n", "2"], "+", "m", "+", "\[Mu]"}], ")"}],
                   "!"}]}]]], " ", 
          RowBox[{
            UnderoverscriptBox["\[Integral]", "0", 
              RowBox[{"\[Infinity]", " "}]], 
            RowBox[{
              SuperscriptBox["z", 
                FractionBox[
                  RowBox[{"3", "+", "\[Mu]"}], "2"]], 
              SuperscriptBox["e", 
                RowBox[{"-", " ", 
                  SuperscriptBox["z", "2"]}]], " ", 
              SuperscriptBox["z", "m"], 
              RowBox[{
                SubsuperscriptBox["L", 
                  SubscriptBox["n", "1"], "m"], "(", "z", ")"}], 
              RowBox[{
                SubsuperscriptBox["L", 
                  SubscriptBox["n", "2"], 
                  RowBox[{"m", "+", "\[Mu]"}]], "(", "z", ")"}], " ", "d", 
              "\[InvisibleSpace]", "z"}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Using the above recursion relations for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", " ", 
          RowBox[{
            SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}]}], 
        TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["L", "n", 
            RowBox[{"\[Lambda]", "+", "1"}]], "(", "z", ")"}], 
        TraditionalForm]]],
  " repeatedly, we now reduce the last two integrals to standard integrals of \
the orthogonality type ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
            RowBox[{
              SuperscriptBox["t", "\[Lambda]"], " ", 
              SuperscriptBox["e", 
                RowBox[{"-", "t"}]], " ", 
              RowBox[{
                SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "t", ")"}], 
              " ", 
              RowBox[{
                SubsuperscriptBox["L", "p", "\[Lambda]"], "(", "t", ")"}], 
              "d", "\[InvisibleSpace]", "t"}]}], "\[Tilde]", 
          SubscriptBox[
            InterpretationBox["\[Delta]",
              KroneckerDelta,
              Editable->False,
              Selectable->False], 
            RowBox[{"n", ",", "p"}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "The two functions ",
  StyleBox["LaguerreReduceRule1", "MR"],
  " and ",
  StyleBox["LaguerreReduceRule2", "MR"],
  " apply the two recursion relations repeatedly."
}], "Text"],

Cell[TextData[{
  StyleBox["(* remove power prefactor by shifting Laguerre order *)", 
    "CodeComment"],
  "\nLaguerreReduceRule1 = z^(\[Mu]_ + k_Integer) LaguerreL[n_, \[Mu]_, z] :> \
\n  -(n + \[Mu]) z^(\[Mu] + k - 1) LaguerreL[n - 1, \[Mu], z] +  \n   (1 + 2 \
n + \[Mu]) z^(\[Mu] + k - 1) LaguerreL[n, \[Mu], z] -\n   (n + 1) z^(\[Mu] + \
k - 1) LaguerreL[n + 1, \[Mu], z];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* remove shifted parameter by shifting Laguerre order *)", 
    "CodeComment"],
  "\nLaguerreReduceRule2 = LaguerreL[n_, \[Mu]_ + i_Integer, z] :> \n   (n + \
(\[Mu] + i - 1))/z LaguerreL[n - 1, \[Mu] + i - 1, z] + \n   (z - n)/z \
LaguerreL[n, \[Mu] + i - 1, z];"
}], "Input"],

Cell[TextData[{
  "Here is an example showing the two functions at work. We canonicalize the \
expression ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["z", 
            RowBox[{"m", "+", "4"}]], 
          SubsuperscriptBox["L", "n", 
            RowBox[{"m", "+", "2"}]]}], TraditionalForm]]],
  ". The summands after expansion all have the desired form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox["z", "m"], 
          RowBox[{
            SubsuperscriptBox["L", "\[Nu]", "m"], "(", "z", ")"}]}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Collect[Expand[z^(m + 4) LaguerreL[n, m + 2, z] //. 
                      LaguerreReduceRule2] //. LaguerreReduceRule1,
        _LaguerreL, Factor]\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["LaguerreOverlapIntegral", "MR"],
  " forms the actual overlap integral ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
          RowBox[{
            StyleBox["zrPart",
              FontSlant->"Italic"], " ", 
            SuperscriptBox["e", 
              RowBox[{"-", "z"}]], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                SubscriptBox["n", "1"], "m"], "(", "z", ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["L", 
                SubscriptBox["n", "2"], 
                RowBox[{"m", "+", "i"}]], "(", "z", ")"}], "d", 
            "\[InvisibleSpace]", "z"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "LaguerreOverlapIntegral[{{n1_, m_}, {n2_, m_ + i_.}}, zrPart_] := \n\
Collect[",
  StyleBox["(* apply the two recursion relations *)", "CodeComment"],
  "\n        Expand[Expand[zrPart LaguerreL[n2, m + i, z] //. \n              \
        LaguerreReduceRule2] //. LaguerreReduceRule1],\n        _LaguerreL, \
Factor] /. \n        ",
  StyleBox["(* use basic orthogonality integral *)", "CodeComment"],
  "\n        z^\[Mu]_ LaguerreL[n_, \[Mu]_, z] :> \n         (n1 + \
\[Mu])!/n1! KroneckerDelta[n1, n] /. \[Mu] -> m"
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["\[Delta]Rule", "MR"],
  " finally expresses ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "2"], TraditionalForm]]],
  " as a function of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  " in the Kronecker symbols. This allows, for a given ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  ", to explicitly list all nonvanishing matrix elements."
}], "Text"],

Cell["\<\
\[Delta]Rule[expr_] := (List @@ Collect[Expand[expr], 
                                 _KroneckerDelta, Factor]) /.
 a_ KroneckerDelta[n1_, \[Nu]_] :> ({n2, a} /. Solve[n1 == \[Nu], \
n2][[1]]);\
\>", "Input"],

Cell[TextData[{
  "Now, we have all tools together to efficiently evaluate the radial matrix \
elements of the potential. The function ",
  StyleBox["MEr", "MR"],
  " calculates the radial integrals belonging to the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Alpha]", " ", 
            SuperscriptBox["r", "4"]}], "+", 
          RowBox[{"\[Beta]", " ", 
            SuperscriptBox["r", "2"]}]}], TraditionalForm]]],
  " potential part."
}], "Text"],

Cell["\<\
MEr[n1_, n2_, m_, rPart_] := 
Sqrt[n1!/(n1 + m)!] Sqrt[n2!/(n2 + m)!]*
 L^(Exponent[rPart, r]) LaguerreOverlapIntegral[{{n1, m}, {n2, m}}, 
                                         z^m z^(Exponent[rPart, r]/2)]\
\>", \
"Input"],

Cell[TextData[{
  "For later use in the construction of the sparse global Hill matrix, we \
write all nonvanishing matrix elements in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SubscriptBox["n", "2"], "(", 
              SubscriptBox["n", "1"], ")"}], ",", " ", 
            RowBox[{"value", "(", 
              SubscriptBox["n", "1"], ")"}]}], "}"}], TraditionalForm]]],
  ". These are the corresponding matrix elements for the quadratic potential \
term."
}], "Text"],

Cell["\<\
MErList1[{n1_, m_}] = 
   \[Delta]Rule[(-M/2 \[Omega]^2 + \[Beta]) MEr[n1, n2, m, r^2]] // \
PowerExpand\
\>", "Input"],

Cell["Here are the matrix elements for the quartic potential term.", "Text"],

Cell["\<\
MErList2[{n1_, m_}] = \[Delta]Rule[\[Alpha] MEr[n1, n2, m, r^4]] // \
PowerExpand\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["MEr3", "MR"],
  " calculates the nonvanishing radial overlap integrals for the potential \
part ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", " ", 
          SuperscriptBox["r", "3"]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "\[PlusMinus]", "3"}]}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
MEr3[n1_, n2_, m_, rPart_] := 
Sqrt[n1!/(n1 + m)!] Sqrt[n2!/(n2 + m + 3)!]*
 L^(Exponent[rPart, r] - 3)*
    LaguerreOverlapIntegral[{{n1, m}, {n2, m + 3}}, 
                            z^m z^(Exponent[rPart, r]/2)]\
\>", "Input"],

Cell["Here are these nonvanishing matrix elements.", "Text"],

Cell["\<\
MErListP3[{n1_, m_}] = \[Delta]Rule[\[Gamma] MEr3[n1, n2, m, r^6] ] \
// PowerExpand\
\>", "Input"],

Cell[TextData[{
  "After some changes of variables, the case ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "-", "3"}]}], TraditionalForm]]],
  " reduces to the case ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "+", "3"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
MErListM3[{n1_, m_}] = \[Delta]Rule[\[Gamma] MEr3[n1, n2, m, r^6] \
/.
               {n1 -> n2, n2 -> n1, m -> m - 3}] // PowerExpand\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["MEr12", "MR"],
  " finally calculates the nonvanishing radial overlap integrals for the \
potential part ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", " ", 
          SuperscriptBox["r", "3"]}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["m", "2"], "=", 
          RowBox[{
            SubscriptBox["m", "1"], "\[PlusMinus]", "1"}]}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
MEr12[n1_, n2_, m_, rPart_] := 
Sqrt[n1!/(n1 + m)!] Sqrt[n2!/(n2 + m + 1)!]*
 L^(Exponent[rPart, r] - 1)*
    LaguerreOverlapIntegral[{{n1, m}, {n2, m + 1}}, 
                                         z^m z^(Exponent[rPart, r]/2)]\
\>", \
"Input"],

Cell["Here are these nonvanishing matrix elements.", "Text"],

Cell["\<\
MErListP12[{n1_, m_}] = \[Delta]Rule[\[Gamma] MEr12[n1, n2, m, r^4] \
] // PowerExpand\
\>", "Input"],

Cell["\<\
MErListM12[{n1_, m_}] = \[Delta]Rule[\[Gamma] MEr12[n1, n2, m, r^4] \
/.
               {n1 -> n2, n2 -> n1, m -> m - 1}] // PowerExpand\
\>", "Input"],

Cell[TextData[{
  "Now, we join the last results, and incorporate the values of the angular \
overlap integrals. For given quantum numbers ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ", the functions ",
  StyleBox["nonvanishingOddMatrixElements", "MR"],
  " and ",
  StyleBox["nonvanishingOddMatrixElements", "MR"],
  " return a list of all nonvanishing matrix elements of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{
                RowBox[{
                  SubscriptBox["n", "2"], "(", 
                  SubscriptBox["n", "1"], ")"}], ",", " ", 
                RowBox[{
                  SubscriptBox["m", "2"], "(", 
                  SubscriptBox["n", "1"], ")"}]}], "}"}], ",", " ", 
            StyleBox["matrixElement",
              FontSlant->"Italic"]}], "}"}], TraditionalForm]]],
  ". We now set ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[HBar]", "=", 
          RowBox[{"M", "=", "1"}]}], TraditionalForm]]],
  ", but keep ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " still as a symbolic parameter. Because the even and odd case have similar \
structures, we define an intermediate function ",
  StyleBox["nonvanishingMatrixElements", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* treat even and odd case uniformly *)", "CodeComment"],
  "\nnonvanishingMatrixElements[{n1_, m1_}, {\[ScriptF]1_, \[ScriptF]2_, \
\[ScriptG]_, \[ScriptH]_}, \n                           {\[Alpha]_, \[Beta]_, \
\[Gamma]_}, \[Omega]_] =\n ",
  StyleBox["(* incorporate \[CurlyPhi]-matrix element values as prefactors \
*)", "CodeComment"],
  "\n Join[",
  StyleBox["(* return in the form {n2(n1, m1), m2(m1)}, matrixElement} *)", 
    "CodeComment"],
  "\n {",
  StyleBox["(* harmonic oscillator part *)", "CodeComment"],
  "\n  {{n1, m1}, (2 n1 + m1 + 1) \[HBar] \[Omega]}},\n   ",
  StyleBox["(* r-dependent potential parts *)", "CodeComment"],
  "\n   If[#1 >= 0, {{#1, m1}, #2}, {}]& @@@ MErList1[{n1, m1}], \n   If[#1 \
>= 0, {{#1, m1}, #2}, {}]& @@@ MErList2[{n1, m1}], \n   ",
  StyleBox["(* cos(3\[CurlyPhi]) potential part *)", "CodeComment"],
  "\n   If[#1 >= 0, {{#1, m1 + 3}, \[ScriptF]1 #2}, {}]& @@@ MErListP3[{n1, \
m1}], \n   If[#1 >= 0 && (m1 ~ \[ScriptH] ~ 3), {{#1, m1 - 3}, \[ScriptF]2 \
#2}, {}]& @@@ \n                                              MErListM3[{n1, \
m1}],\n   If[m1 == 1 && #1 >= 0, {{#1, 2}, \[ScriptG] #2}, {}]& @@@ \n        \
                                      MErListP12[{n1, m1}],\n   If[m1 == 2 && \
#1 >= 0, {{#1, 1}, \[ScriptG] #2}, {}]& @@@ \n                                \
              MErListM12[{n1, m1}]] /. \n                                     \
               {M -> 1, \[HBar] -> 1};"
}], "Input"],

Cell[TextData[{
  "The differences between the even and the odd cases are the \
inclusion/exclusion of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", "0"}], TraditionalForm]]],
  " case and different signs of the angular momentum matrix elements."
}], "Text"],

Cell[TextData[{
  StyleBox["(* even case *)", "CodeComment"],
  "\nnonvanishingEvenMatrixElements[{n1_, m1_}, {\[Alpha]_, \[Beta]_, \
\[Gamma]_}, \[Omega]_] =\n nonvanishingMatrixElements[{n1, m1}, ",
  StyleBox["(* special rule for m == 0 *)", "CodeComment"],
  "\n             {If[m1 == 0, 1/Sqrt[2], 1/2], \n              If[m1 == 3, \
1/Sqrt[2], 1/2], 1/2,\n              GreaterEqual}, {\[Alpha], \[Beta], \
\[Gamma]}, \[Omega]];"
}], "Input"],

Cell[TextData[{
  StyleBox["(* odd case *)", "CodeComment"],
  "\nnonvanishingOddMatrixElements[{n1_, m1_}, {\[Alpha]_, \[Beta]_, \
\[Gamma]_}, \[Omega]_] =\n nonvanishingMatrixElements[\n             {n1, \
m1}, {1/2, 1/2, -1/2, Greater}, {\[Alpha], \[Beta], \[Gamma]}, \[Omega]];"
}], "Input"],

Cell[TextData[{
  "Here is a shortened form of the function ",
  StyleBox["nonvanishingEvenMatrixElements", "MR"],
  "."
}], "Text"],

Cell["\<\
nonvanishingEvenMatrixElements[{n1, m1}, {\[Alpha], \[Beta], \
\[Gamma]}, \[Omega]] //
                                            Short[#, 12]&\
\>", "Input"],

Cell[TextData[{
  "For explicitly given values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ", the test in ",
  StyleBox["nonvanishingMatrixElements", "MR"],
  " can completely be carried out. As a result, we can add all nonvanishing \
matrix element values belonging to identical ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["n", "2"], ",", 
            SubscriptBox["m", "2"]}], "}"}], TraditionalForm]]],
  " pairs. The function ",
  StyleBox["uniteElements", "MR"],
  " does this. The two function ",
  StyleBox["allNonvanishingOddMatrixElements", "MR"],
  " and ",
  StyleBox["allNonvanishingOddMatrixElements", "MR"],
  " are the final functions used to construct the Hill matrices. "
}], "Text"],

Cell[TextData[{
  "uniteElements[l_] := ",
  StyleBox["(* sum right-hand side of rules *)", "CodeComment"],
  "\nIf[Length[#] === 1, Rule @@ First[#], \n   #[[1, 1]] -> (Plus @@ (Last \
/@ #))]& /@ \n     Split[Sort[DeleteCases[l, {}]], #1[[1]] === #2[[1]]&]"
}], "Input"],

Cell["\<\
allNonvanishingEvenMatrixElements[{n1_Integer, m1_Integer}, 
                                  {\[Alpha]_, \[Beta]_, \[Gamma]_}, \
\[Omega]_] := 
uniteElements @ nonvanishingEvenMatrixElements[{n1, m1}, {\[Alpha], \[Beta], \
\[Gamma]}, \[Omega]]\
\>", "Input"],

Cell["\<\
allNonvanishingOddMatrixElements[{n1_Integer, m1_Integer}, 
                                 {\[Alpha]_, \[Beta]_, \[Gamma]_}, \[Omega]_] \
:= 
uniteElements @ nonvanishingOddMatrixElements[{n1, m1}, {\[Alpha], \[Beta], \
\[Gamma]}, \[Omega]]\
\>", "Input"],

Cell[TextData[{
  "Here is a quick check of the just\[Hyphen]calculated nonvanishing matrix \
elements. We compare them with the values of the matrix elements calculated \
by straightforward integration for explicit values of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  ". To check that we did not miss any nonvanishing matrix elements, we \
calculate explicitly all matrix elements in the extended convex hull of the \
nonvanishing ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"n", ",", "m"}], "}"}], TraditionalForm]]],
  " points."
}], "Text"],

Cell[TextData[{
  StyleBox["(* generalized H\[EAcute]non-Heiles Hamiltonian *)", 
    "CodeComment"],
  "\n\[ScriptCapitalH]Op[r_, \[CurlyPhi]_] = (-\[HBar]^2/(2 M) (1/r D[r D[#, \
r], r] + 1/r^2 D[#, \[CurlyPhi], \[CurlyPhi]]) + \n               (\[Alpha] \
r^4 + \[Beta] r^2 + \[Gamma] r^3 Cos[3 \[CurlyPhi]]) #)&;"
}], "Input"],

Cell[TextData[{
  "checkMatrixElements[{n1_Integer, m1_Integer}, evenOdd: (Even | Odd)] :=\n\
Module[{mF, \[Psi], m0, mEsS, mEsE},\n",
  StyleBox["(* even or odd? *)", "CodeComment"],
  "\nWhich[evenOdd === Even, \n       mF = allNonvanishingEvenMatrixElements; \
\[Psi] = \[Psi]Even; m0 = 0,\n       evenOdd === Odd,  \n       mF = \
allNonvanishingOddMatrixElements; \[Psi] = \[Psi]Odd; m0 = 1];\n ",
  StyleBox["(* symbolically calculated nonvanishing matrix elements *)", 
    "CodeComment"],
  "\n mEsS = Factor //@ Together //@ mF[{n1, m1}, {\[Alpha], \[Beta], \
\[Gamma]}, \[Omega]];\n ",
  StyleBox["(* explicitly calculated nonvanishing matrix elements *)", 
    "CodeComment"],
  "\n mEsE = Block[{\[HBar] = 1, M = 1}, Factor //@ Together //@ \n  \
(Function[{n2, m2}, {n2, m2} -> \n    Integrate[\[Psi][n1, m1, r, \
\[CurlyPhi]] (\[ScriptCapitalH]Op[r, \[CurlyPhi]] @ \[Psi][n2, m2, r, \
\[CurlyPhi]]) r,\n               {\[CurlyPhi], 0, 2Pi}, {r, 0, Infinity}, \
Assumptions -> \[Omega] > 0]] @@@\n (Flatten[",
  StyleBox["(* all n and m values covering nonvanishing mEsS values *)", 
    "CodeComment"],
  "\n Table[{n, m}, {n, Max[0 , #1[[1]] - 1], #1[[2]] + 1}, \n               \
{m, Max[m0, #2[[1]] - 1], #2[[2]] + 1}]& @@\n         ({Min[#], Max[#]}& /@ \
Transpose[First /@ mEsS]), 1]))];     \n ",
  StyleBox["(* are nonvanishing elements identical? *)", "CodeComment"],
  "\n Sort[mEsS] === Sort[DeleteCases[mEsE, _ -> 0]]]"
}], "Input"],

Cell["\<\
checkMatrixElements @@@ 
            {{{0, 3}, Even}, {{1, 1}, Even}, {{2, 2}, Odd}}\
\>", "Input"],

Cell[TextData[{
  "After having evaluated the function ",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " (or ",
  StyleBox["numberOddBasisFunctions", "MR"],
  " respectively), the variable ",
  StyleBox["dim", "MR"],
  " has a value and the function ",
  StyleBox["nmNumbers", "MR"],
  " has downvalues. The function ",
  StyleBox["HillMatrixElements", "MR"],
  " generates a list of all nonvanishing Hill matrix elements for the \
currently (through ",
  StyleBox["nmNumbers", "MR"],
  ") active quantum numbers ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "1"], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "1"], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "HillMatrixElements[{\[Alpha]_, \[Beta]_, \[Gamma]_}, \[Omega]_] := \n\
With[{",
  StyleBox["(* even or odd basis? *)", "CodeComment"],
  "\n      anme = If[nmNumbers[1] === {0, 0}, \n                \
allNonvanishingEvenMatrixElements,\n                \
allNonvanishingOddMatrixElements]},\n",
  StyleBox["(* all nonvanishing matrix elements *)", "CodeComment"],
  "\nDeleteCases[Flatten[\nTable[({k, efNumber[#1]} -> #2)& @@@ \
anme[nmNumbers[k], {\[Alpha], \[Beta], \[Gamma]}, \[Omega]],\n                \
       {k, dim}]], {_, _efNumber} -> _]];"
}], "Input"],

Cell[TextData[{
  "At this point we also change the origin of the potential minimum. We will \
set the potential minimum to have the value zero. We do this to make sure \
that all eigenvalues are strictly positive, so that the function ",
  StyleBox["Eigenvalues", "MR"],
  " with a negative integer second argument applied to the resulting sparse \
array will always yield the lowest eigenvalues."
}], "Text"],

Cell[TextData[{
  StyleBox["(* change diagonal matrix elements so that the \n   potential \
minimum has value zero *)", "CodeComment"],
  "\ngaugePotentialMinimum[sa_, {\[Alpha]_, \[Beta]_, \[Gamma]_}] :=\n\
Module[{Vmin},\n       ",
  StyleBox["(* global minimum of the potential *)", "CodeComment"],
  "\n       Vmin = Minimize[{\[Alpha] (x^2 + y^2)^2 + \[Beta] (x^2 + y^2) + \n\
                        \[Gamma] (x^3 - x y^2)}, {x, y}][[1]] // \n           \
                          N[#, Precision[sa]]&;\n       ",
  StyleBox["(* global gauge transformation to zero potential minimum *)", 
    "CodeComment"],
  "\n       sa + SparseArray[Table[{i, i} -> -Vmin, {i, Length[sa]}]]]"
}], "Input"],

Cell["\<\
SparseHillMatrix[{\[Alpha]_, \[Beta]_, \[Gamma]_}, \[Omega]_] := 
      gaugePotentialMinimum[#, {\[Alpha], \[Beta], \[Gamma]}]& @
           SparseArray[HillMatrixElements[{\[Alpha], \[Beta], \[Gamma]}, \
\[Omega]]]\
\>", "Input"],

Cell[TextData[{
  "To visualize the sparse Hill matrix, we implement a function ",
  StyleBox["sparseArrayGraphics", "MR"],
  " that displays the nonvanishing matrix values. Small values are shown in \
red, and large values are shown in blue."
}], "Text"],

Cell[TextData[{
  "sparseArrayGraphics[sa_, opts___] :=\nModule[{",
  StyleBox["(* absolutely scaled matrix elements *)", "CodeComment"],
  "\n        ars = (#1 -> ArcTan[Abs[#2]]/(Pi/2))& @@@ \n                     \
    Most[ArrayRules[sa]], min, max},\n       ",
  StyleBox["(* scale matrix elements relative *)", "CodeComment"],
  "\n       {min, max} = {Min[#], Max[#]}& @ (Last /@ ars);\n       \
Graphics[{RGBColor[min/#2, 0, #2/max], \n                 Rectangle[#1 - 1/2, \
#1 + 1/2]}& @@@ ars, \n       Frame -> True, PlotRange -> All, AspectRatio -> \
Automatic]]"
}], "Input"],

Cell[TextData[{
  "The next input just reproduces the 2D harmonic oscillator eigenvalues (",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", 
          RowBox[{"\[Gamma]", "=", "0"}]}], TraditionalForm]]],
  ")."
}], "Text"],

Cell["\<\
numberEvenBasisFunctions[10];
SA = With[{\[Omega] = 1.}, SparseHillMatrix[{0, \[Omega]^2/2, 0.}, \
\[Omega]]];
SA // Eigenvalues // Reverse\
\>", "Input"],

Cell[TextData[{
  "The next graphic shows the nonvanishing matrix elements for the genuine \
anharmonic case ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", 
          RowBox[{"\[Gamma]", "=", "1"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
numberEvenBasisFunctions[20];
SA = With[{\[Omega] = 1}, SparseHillMatrix[{1, \[Omega]^2/2, 1}, \[Omega]]];
Show[sparseArrayGraphics[SA]]\
\>", "Input"],

Cell["By construction, the resulting matrix is symmetric.", "Text"],

Cell["SA - Transpose[SA] // Normal // Flatten // Union", "Input"],

Cell["\<\
We have a quick qualitative look at the eigenvectors at this point. \
We diagonalize the just\[Hyphen]visualized matrix with high precision.\
\>", \
"Text"],

Cell["evecs = Eigenvectors[N[SA, 60]];", "Input"],

Cell[TextData[{
  "The following are the angular momentum quantum numbers ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " of the basis states having a nonvanishing contribution to the resulting \
eigenstate. We see that in addition to the already above used symmetry, we \
could further split the states into two subgroups (corresponding to their \
parity with respect to the rays in the directions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"cos", "(", 
              RowBox[{"2", " ", 
                RowBox[{"\[Pi]", "/", "3"}]}], ")"}], ",", " ", 
            RowBox[{"\[PlusMinus]", 
              RowBox[{"sin", "(", 
                RowBox[{"2", " ", 
                  RowBox[{"\[Pi]", "/", "3"}]}], ")"}]}]}], "}"}], 
        TraditionalForm]]],
  "). One subgroup contains all states with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", 
          RowBox[{"3", "k"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "\[Element]", "\[DoubleStruckCapitalN]"}], 
        TraditionalForm]]],
  ", the other the remaining states [",
  
  CounterBox["BibliographyCounter", "Pullen81"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Pullen81",
    ButtonStyle->"Hyperlink"],
  "]. This would allow to use still smaller matrix sizes to obtain the same\
\[Hyphen]quality solution. Doing this is straightforward and will not do it \
here."
}], "Text"],

Cell["\<\
(First /@ Cases[#, {_, 1}])&  /@ 
MapIndexed[{nmNumbers[#2[[2]]][[2]], If[Abs[#1] < 10^-30, 1, 0]}&, 
           Take[#, 24]& /@ Take[evecs, -12], {2}]\
\>", "Input"],

Cell[TextData[{
  "The next graphic shows the dependence of the ten lowest eigenvalues on ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ". In this concrete example, the eigenvalues are nearly independent of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  " over a relatively broad range of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  "\[Hyphen]values ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"1", "/", "2"}], "\[LessTilde]", "\[Omega]", "\[LessTilde]",
           
          RowBox[{"7", "/", "2"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* prepare matrix *)", "CodeComment"],
  "\nnumberEvenBasisFunctions[30];\nSA\[Omega][\[Omega]_] = N @ \
SparseHillMatrix[{1, -2, -3}, \[Omega]];\nSA\[Omega]N[\[Omega]_] = Normal[SA\
\[Omega][\[Omega]]];\n",
  StyleBox["(* show eigenvalue dependence on \[Omega] *)", "CodeComment"],
  "\nShow[Graphics[Line /@ Transpose[",
  StyleBox["(* use various \[Omega]-values *)", "CodeComment"],
  "\n  Table[{\[Omega], #}& /@ Take[Eigenvalues[SA\[Omega]N[\[Omega]]], -10], \
\n        {\[Omega], 0.1, 10, 0.1}]]], \n     Frame -> True, PlotRange -> {0, \
35}]"
}], "Input"],

Cell[TextData[{
  "We repeat the last calculations and investigate the magnitudes of the \
eigenvector components. Because the components are not smooth functions of \
the index, we do not display the components directly. Instead we fit a linear \
function to the logarithm of selected components (the selected components are \
the largest components starting with the highest states). This graphics that \
for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Omega]", "\[TildeTilde]", "3"}], TraditionalForm]]],
  " we have fastest decay of the eigenfunction components for the lowest \
states."
}], "Text"],

Cell[TextData[{
  "Module[{evecs}, \nShow[Graphics[",
  StyleBox["(* color each state differently *)", "CodeComment"],
  "\nMapIndexed[{Hue[0.8 (#2[[1]] - 1)/10], PointSize[0.006], Point /@ #}&, \n\
Transpose[Table[evecs = Abs[Eigenvectors[SA\[Omega]N[\[Omega]]]];\n",
  StyleBox["(* fit linear function to logarithm of eigenvector components *)",
     "CodeComment"],
  "\nTable[{\[Omega], Coefficient[Fit[\n      ",
  StyleBox["(* select maximal components; start from the end *)", 
    "CodeComment"],
  "\n      Most[Log[Reverse[FoldList[Max, 0, Reverse[evecs[[-j]]]]]]],\n      \
                    {1, x}, x], x]}, {j, 10}], \n      {\[Omega], 0.1, 10, \
0.1}]]]], Frame -> True, PlotRange -> All]]"
}], "Input"],

Cell[TextData[{
  "Next, we calculate the Hill matrix for a symbolic value of ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  " and show the dependence of the lowest eigenvalues as a function of ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  ". The spectrum of ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  " is identical to the spectrum for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"-", "\[Gamma]"}], TraditionalForm]]],
  " because the sign change of ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  " in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", " ", 
          RowBox[{"cos", "(", 
            RowBox[{"3", "\[CurlyPhi]"}], ")"}], 
          SuperscriptBox["r", "3"]}], TraditionalForm]]],
  " effectively just flips that potential around the ",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]axis. Some even and odd states are degenerate [",
  
  CounterBox["BibliographyCounter", "Noid80"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Noid80",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Hu00"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hu00",
    ButtonStyle->"Hyperlink"],
  "]. "
}], "Text"],

Cell[TextData[{
  "Module[{\[CurlyEpsilon]Max = 24, \[Delta]\[Gamma] = 1/36, SA\[Gamma]},\n\
Show[Graphics[\n",
  StyleBox["(* calculate lowest eigenvalues for various \[Gamma]-values *)", 
    "CodeComment"],
  "\nFunction[{eo, col}, eo[\[CurlyEpsilon]Max];\n Table[",
  StyleBox["(* form matrix and calculate lowest eigenvalues *)", 
    "CodeComment"],
  "\n       SA\[Gamma] = Normal[SparseHillMatrix[{1, 0, \[Gamma]}, 1]];\n     \
  ",
  StyleBox["(* even states in red; odd states in blue *)", "CodeComment"],
  "\n       {col, PointSize[0.005], Point[{\[Gamma], #}]}& /@ \n              \
 Take[Eigenvalues[N @ SA\[Gamma]], -10], \n       {\[Gamma], -3, 3, \[Delta]\
\[Gamma]}]] @@@ \n  ",
  StyleBox["(* even and odd states *)", "CodeComment"],
  "\n  {{numberEvenBasisFunctions, RGBColor[1, 0, 0]},\n   \
{numberOddBasisFunctions,  RGBColor[0, 0, 1]}},\n     PlotRange -> All, Frame \
-> True]]]"
}], "Input"],

Cell[TextData[{
  "To calculate explicit position representations of the eigenfunctions, we \
need the numerical values of the Laguerre polynomials. To calculate them \
quickly (meaning using machine arithmetic), we need a numerically stable \
recursion relation. To avoid the generation of large values for increasing \
values of angular quantum numbers, we do not calculate the numerical values \
of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}], 
        TraditionalForm]]],
  " directly, but rather of the normalized version ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubsuperscriptBox["\[Chi]", "n", "\[Lambda]"], "(", "z", ")"}], 
          "=", 
          RowBox[{
            RowBox[{
              RowBox[{"n", "!"}], " ", "/", 
              RowBox[{
                RowBox[{"(", 
                  RowBox[{"n", "+", "\[Lambda]"}], ")"}], "!"}]}], 
            RowBox[{
              SubsuperscriptBox["L", "n", "\[Lambda]"], "(", "z", ")"}]}]}], 
        TraditionalForm]]],
  ". The ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[Chi]", "n", "\[Lambda]"], "(", "z", ")"}], 
        TraditionalForm]]],
  " obey the following recursion relation which is numerically stable when \
run downwards with respect to ",
  Cell[BoxData[
      FormBox["\[Lambda]", TraditionalForm]]],
  "."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["\[Chi]", "n", "\[Lambda]"], "(", "z", ")"}], "=",
         
        RowBox[{
          RowBox[{
            RowBox[{"(", 
              RowBox[{"z", "+", "\[Lambda]", "+", "1"}], ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["\[Chi]", "n", 
                RowBox[{"\[Lambda]", "+", "1"}]], "(", "z", ")"}]}], "-", 
          RowBox[{"z", " ", 
            RowBox[{"(", 
              RowBox[{"n", "+", "\[Lambda]", "+", "2"}], ")"}], " ", 
            RowBox[{
              SubsuperscriptBox["\[Chi]", "n", 
                RowBox[{"\[Lambda]", "+", "2"}]], "(", "z", ")"}]}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Here is a quick check of the quality of this recursion. To avoid large \
polynomial values for larger ",
  Cell[BoxData[
      FormBox["r", TraditionalForm]]],
  ", we also incorporate the exponential term ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{"-", "z"}], ")"}], TraditionalForm]]],
  " from the 2D harmonic oscillator wave function."
}], "Text"],

Cell[TextData[{
  "Module[{Lz = 25, \[Delta]z = 1/2, n = 150, \[CapitalLambda] = 150,\n       \
 \[Chi], zList, LaguerreLExpList},\n ",
  StyleBox["(* scaled LaguerreL functions *)", "CodeComment"],
  "\n \[Chi][n_, \[Lambda]_, z_] := n!/(n + \[Lambda])! LaguerreL[n, \
\[Lambda], z];\n ",
  StyleBox["(* z-values *)", "CodeComment"],
  "\n zList = N @ Table[z, {z, 0, Lz, \[Delta]z}];\n ",
  StyleBox["(* starting values of the recursion relation *)", "CodeComment"],
  "\n Do[LaguerreLExpList[n, \[Lambda]] = N[\[Chi][n, \[Lambda], N[zList, \
100]] Exp[-zList]], \n    {\[Lambda], \[CapitalLambda] - 1, \
\[CapitalLambda]}];\n ",
  StyleBox["(* carry out recursion downwards *)", "CodeComment"],
  "\n Do[LaguerreLExpList[n, \[Lambda]] = \n     (1 + zList + \[Lambda]) \
LaguerreLExpList[n, 1 + \[Lambda]] - \n     zList (2 + \[Lambda] + n) \
LaguerreLExpList[n, 2 + \[Lambda]], {\[Lambda], \[CapitalLambda] - 2, 0, \
-1}];\n ",
  StyleBox["(* display logarithm of relative error as a function of \[Lambda] \
*)", "CodeComment"],
  "\n ListPlot[Table[{\[Lambda], Log[10, #]}& @ Abs[Max[\n      \
Cases[LaguerreLExpList[n, \[Lambda]]/\n            (\[Chi][n, \[Lambda], \
N[zList, 200]] Exp[-zList]) - 1, _?NumberQ]]],\n      {\[Lambda], 0, \
\[CapitalLambda] - 2}], PlotRange -> All, Frame -> True, Axes -> False]]"
}], "Input"],

Cell[TextData[{
  "After having evaluated ",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " or ",
  StyleBox["numberOddBasisFunctions", "MR"],
  ", the function ",
  StyleBox["nmNumbers", "MR"],
  " has downvalues. For the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"n", ",", "m"}], "}"}], TraditionalForm]]],
  "\[Hyphen]values contained in the domain of the function ",
  StyleBox["nmNumbers", "MR"],
  ", we will calculate numerical values for discretizations radially and \
azimuthally. We carry out the radial discretization in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0", ",", 
            StyleBox["rMax",
              "TI"]}], "]"}], TraditionalForm]]],
  " and the azimuthal discretization in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0", ",", "\[Pi]"}], "]"}], TraditionalForm]]],
  " (because we will later visualize the squares of the eigenfunctions and \
all eigenfunctions have definite parity with respect to the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis, we do not need the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"\[Pi]", ",", 
            RowBox[{"2", "\[Pi]"}]}], "]"}], TraditionalForm]]],
  " domain)."
}], "Text"],

Cell[TextData[{
  "cacheEigenFunctionLists[\[Omega]_, rMax_, {ppr_, pp\[CurlyPhi]_}] :=\n\
Block[{\[Chi], n, \[CapitalLambda], LaguerreLExpList, \[Delta]r = rMax/ppr, L \
= 1/Sqrt[\[Omega]],\n       \[CapitalLambda]ming, \[CapitalLambda]g, tpd = \
Developer`ToPackedArray},\n Clear[RList, \[CapitalPhi]List];\n ",
  StyleBox["(* extremal n, m values *)", "CodeComment"],
  "\n nAndMinmMaxmList = {#1[[1, 1]], Min[Last /@ #], Max[Last /@ #]}& /@ \n  \
     Split[Sort[nmNumbers /@ Range[dim]], #1[[1]] == #2[[1]]&];\n \
Do[usednmPair[nmNumbers[k]] = True, {k, dim}];\n ",
  StyleBox["(* radial eigenfunctions *)", "CodeComment"],
  "\n ",
  StyleBox["(* list of scaled, squared radii *)", "CodeComment"],
  "\n zList = N @ Table[(r/L)^2, {r, 0, rMax, \[Delta]r}];\n \[Chi][n_, \
\[Lambda]_, z_] := n!/(n + \[Lambda])! LaguerreL[n, \[Lambda], z];\n Do[{n, \
\[CapitalLambda]min, \[CapitalLambda]} = nAndMinmMaxmList[[j]]; \n    ",
  StyleBox["(* calculate normalized Laguerre polynomials *)", "CodeComment"],
  "\n    Do[LaguerreLExpList[n, \[Lambda]] = \[Chi][n, \[Lambda], zList] \
Exp[-zList/2], \n       {\[Lambda], \[CapitalLambda] - 1, \[CapitalLambda]}];\
\n    Do[LaguerreLExpList[n, \[Lambda]] = \n       (1 + zList + \[Lambda]) \
LaguerreLExpList[n, 1 + \[Lambda]] - \n       zList (2 + \[Lambda] + n) \
LaguerreLExpList[n, 2 + \[Lambda]], \n     {\[Lambda], \[CapitalLambda] - 2, \
\[CapitalLambda]min, -1}];\n   ",
  StyleBox["(* cache the radial wavefunction values *)", "CodeComment"],
  "  \n   Do[If[usednmPair[{n, \[Lambda]}], \n         ",
  StyleBox["(* list of radial wavefunction values *)", "CodeComment"],
  "\n         RList[n, \[Lambda]] = tpd[Sqrt[2]/L 1/Sqrt[n!/(n + \
\[Lambda])!]*\n                           If[\[Lambda] =!= 0, \
zList^(\[Lambda]/2),\n                              Table[1., {r, 0, rMax, \
\[Delta]r}]]*\n                               LaguerreLExpList[n, \
\[Lambda]]]],\n      {\[Lambda], \[CapitalLambda]min, \[CapitalLambda]}], {j, \
Length[nAndMinmMaxmList]}];\n ",
  StyleBox["(* azimuthal eigenfunctions in [0, Pi] *)", "CodeComment"],
  "\n \[CurlyPhi]List = N @ Table[\[CurlyPhi], {\[CurlyPhi], 0, Pi, Pi/pp\
\[CurlyPhi]}]; \n ",
  StyleBox["(* all occurring m quantum numbers *)", "CodeComment"],
  "\n {\[CapitalLambda]ming, \[CapitalLambda]g} = {Min[#], Max[#]}& @ \
Rest[Transpose[nAndMinmMaxmList]];\n \[CurlyPhi]EF = If[\[CapitalLambda]ming \
== 0, \[CapitalPhi]Even, \[CapitalPhi]Odd];\n Do[\[CapitalPhi]List[m] = tpd[N \
@ \[CurlyPhi]EF[m, \[CurlyPhi]List]], {m, \[CapitalLambda]ming, \
\[CapitalLambda]g}]] "
}], "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["cacheEigenFunctionLists", "MR"],
  " uses machine precision and will work well with ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["n", "max"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["m", "max"], TraditionalForm]]],
  " a few hundred. While this will be large enough for the visualizations to \
be presented at the later, for very high states, one might have to use high\
\[Hyphen]precision arithmetic to calculate the radial eigenfunctions (the \
Hill eigenvectors are good enough with machine arithmetic)."
}], "Text"],

Cell[TextData[{
  "The following graphic shows a comparison between the directly calculated \
radial eigenfunctions ",
  StyleBox["R[8, 8, r]", "MR"],
  " (thick gray line) and the discretized eigenfunctions (thin red line) \
obtained through the function ",
  StyleBox["cacheEigenFunctionLists", "MR"],
  "."
}], "Text"],

Cell[TextData[{
  "Show @\nBlock[{n = 24, m = 24, \[HBar] = 1, M = 1, \[Omega] = 2, \n       \
$DisplayFunction = Identity, ppr = 100, rMax = 10},\n\
numberEvenBasisFunctions[100];\ncacheEigenFunctionLists[\[Omega], rMax, {ppr, \
1}];\n{",
  StyleBox["(* exact radial eigenfunctions *)", "CodeComment"],
  "\n Plot[Evaluate[R[n, m, r]], {r, 0, rMax}, PlotPoints -> 200,\n      \
PlotStyle -> {GrayLevel[0.5], Thickness[0.02]}],\n ",
  StyleBox["(* recursively-calculated radial eigenfunctions  *)", 
    "CodeComment"],
  "\n ListPlot[MapIndexed[{(#2[[1]] - 1)/ppr rMax, #1}&, RList[n, m]], \n     \
     PlotRange -> All, PlotJoined -> True, \n          PlotStyle -> \
{Hue[0]}]}]"
}], "Input"],

Cell[TextData[{
  "We visualize the squares of the eigenfunctions using 3D plots and contour \
plots. Because the discretized eigenfunctions are defined on a tensor product \
grid in polar coordinates, we implement the two functions ",
  StyleBox["polarListPlot3D", "MR"],
  " and ",
  StyleBox["polarListContourPlot", "MR"],
  " that display such type discretized functions over a circular domain. The \
argument of both function is the matrix ",
  StyleBox["gef", "TI"],
  " of function values in polar coordinates in the upper half\[Hyphen]plane."
}], "Text"],

Cell[TextData[{
  "polarListPlot3D[gef_, rMax_:1, color___] :=\nModule[{ppr, pp\[CurlyPhi], \
r, \[CurlyPhi], points, polysU, polysL},\n {ppr, pp\[CurlyPhi]} = \
Dimensions[gef] - 1;\n ",
  StyleBox["(* Cartesian coordinates of points *)", "CodeComment"],
  "\n points = MapIndexed[({r, \[CurlyPhi]} = {rMax (#2[[1]] - 1)/ppr, \n     \
                           Pi (#2[[2]] - 1)/pp\[CurlyPhi]};\n                 \
     {r Cos[\[CurlyPhi]], r Sin[\[CurlyPhi]], #1})&, gef, {2}] // N;\n ",
  StyleBox["(* polygons in upper half-plane *)", "CodeComment"],
  "\n polysU = Table[Polygon[{points[[i, j]], points[[i + 1, j]],\n           \
              points[[i + 1, j + 1]], points[[i, j + 1]]}], \n                \
{i, ppr}, {j, pp\[CurlyPhi]}];\n ",
  StyleBox["(* polygons in lower half-plane *)", "CodeComment"],
  "\n polysL = Map[(# {1, -1, 1})&, polysU, {-2}];              \n ",
  StyleBox["(* resulting 3D graphics *)", "CodeComment"],
  "\n Show @ Graphics3D[{EdgeForm[], color, polysU, polysL}, \n      \
PlotRange -> All, Boxed -> False, BoxRatios -> {1, 1, 0.4}]]"
}], "Input"],

Cell["\<\
To see the structure in the squares of the higher\[Hyphen]order \
wave functions better, we use a nonlinear scaling for the coloring of the \
contour regions. Actually, we implement two color functions. One is based on \
a nonlinear function applied directly to the function values and the second \
on a linear function applied on the number of function values. The first one \
shows the overall structure of the eigenfunctions (having physical \
relevance), while the second reveals fine details (showing numerical details, \
largely resulting from the summation) in the regions where the function \
values are small.\
\>", "Text"],

Cell[TextData[{
  "polarListContourPlot[gef_, resolveFineStructure_: False, rMax_:1] :=\n\
Module[{ppr, pp\[CurlyPhi], \[Lambda], \[ScriptC]\[ScriptF], cts = 48},\n \
{ppr, pp\[CurlyPhi]} = Dimensions[gef];\n If[resolveFineStructure,\n    ",
  StyleBox["(* homogeneously spaced contours *)", "CodeComment"],
  "\n    cls = Union[#[[Round[ppr pp\[CurlyPhi]/cts/2]]]& /@ \n               \
 Partition[Sort[Flatten[gef]], Round[ppr pp\[CurlyPhi]/cts]]];\n    \[Lambda] \
= Length[cls];\n    ",
  StyleBox["(* use linear gradient of graylevels with respect to contours *)",
     "CodeComment"],
  "\n    \[ScriptC]\[ScriptF] = Function @@ {Which @@\n      \
Flatten[Append[MapIndexed[{#1, GrayLevel[1 - (#2[[1]] - 1)/\[Lambda]]}&, \n   \
                  Function[v, # < v] /@ cls], {True, GrayLevel[0]}]]};\n    \
colorOpts = Sequence[ColorFunctionScaling -> False,\n                         \
ColorFunction -> \[ScriptC]\[ScriptF], Contours -> cls],\n    ",
  StyleBox["(* nonlinear color function scaling *)", "CodeComment"],
  "\n    \[ScriptC]\[ScriptF][x_] :=  GrayLevel[1 - If[x < 1/2, 0 + Sqrt[1/4 \
- (x - 1/2)^2], \n                                         1 - Sqrt[1/4 - (x \
- 1/2)^2]]];    \n    colorOpts = Sequence[ColorFunctionScaling -> True,\n    \
                     ColorFunction -> \[ScriptC]\[ScriptF], Contours -> \
cts]];                  \n ",
  StyleBox["(* contour plot in the upper half-plane *)", "CodeComment"],
  "\n lcp = ListContourPlot[gef, colorOpts, \n            DisplayFunction -> \
Identity, ContourLines -> False,\n            PlotRange -> All, MeshRange -> \
{{0, Pi}, {0, rMax}}, \n            ContourStyle -> {{GrayLevel[0], \
Thickness[0.002]}}];\n ",
  StyleBox["(* make a graphics and map polygons to Cartesian coordinates *)", 
    "CodeComment"],
  "\n gr = Graphics[lcp];\n grR = gr /. (pl:(Polygon | Line))[points_] :>   \n\
              pl[addPoints[points, 10^-2 Min[rMax, 2Pi]]];\n ",
  StyleBox["(* upper half-plane polygons *)", "CodeComment"],
  "\n grRCU = grR /. (pl:(Polygon | Line))[points_] :>   \n                 \
pl[{#2 Cos[#1], #2 Sin[#1]}& @@@ points];  \n ",
  StyleBox["(* lower half-plane polygons *)", "CodeComment"],
  "\n grRCL = grRCU /. (pl:(Polygon | Line))[points_] :>   \n                 \
  pl[(# {1, -1})& /@ points];                \n ",
  StyleBox["(* resulting contour graphic *)", "CodeComment"],
  "                \n Show[{grRCU, grRCL},\n      Frame -> False, \
DisplayFunction -> $DisplayFunction]]    "
}], "Input"],

Cell[TextData[{
  "To generate a contour plot in polar coordinates, we map a contour plot \
made in \"Cartesian\" ",
  Cell[BoxData[
      FormBox["\[CurlyPhi]", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["r", TraditionalForm]]],
  "\[Hyphen]coordinates to Cartesian ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  ",",
  Cell[BoxData[
      FormBox["y", TraditionalForm]]],
  "\[Hyphen]graphics coordinates. Because the polygons used to represent a \
contour plot have partially long edges, we have to subdivide these edges to \
obtain a smooth polygon boundary after the mapping to Cartesian graphics \
coordinates. The function ",
  StyleBox["addPoints", "MR"],
  " inserts points into the list of points ",
  StyleBox["points", "TI"],
  ", so that the largest resulting line segment is smaller than ",
  Cell[BoxData[
      FormBox["\[Delta]\[CurlyEpsilon]", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* add intermediate points into list points so that the maximal\n \
  distance between two consecutive points is \[Delta]\[CurlyEpsilon] *)", 
    "CodeComment"],
  "\naddPoints[points_, \[Delta]\[CurlyEpsilon]_] := \n Module[{n, l}, Join \
@@ \n       (Function[s, ",
  StyleBox["(* segment s short enough? *)", "CodeComment"],
  "\n               If[(l = Sqrt[#. #]&[Subtract @@ s]) < \[Delta]\
\[CurlyEpsilon], s, \n         n = Floor[l/\[Delta]\[CurlyEpsilon]] + 1; ",
  StyleBox["(* form segments *)", "CodeComment"],
  "\n         Table[# + i/n (#2 - #1), {i, 0, n - 1}]& @@ s]] /@ \n           \
   ",
  StyleBox["(* form segments between points *)", "CodeComment"],
  "\n              Partition[Append[points, First[points]], 2, 1])]"
}], "Input"],

Cell[TextData[{
  "To construct the position representation of the eigenfunctions, we use the \
function ",
  StyleBox["constructEigenFunction", "MR"],
  ". Its argument is an eigenvector from the diagonalized Hill matrix. The \
function ",
  StyleBox["constructEigenFunction", "MR"],
  " assumes that the functions ",
  StyleBox["numberEvenBasisFunctions", "MR"],
  " and ",
  StyleBox["cacheEigenFunctionLists", "MR"],
  " have already been evaluated, so that the current basis functions are \
globally visible. We form the tensor product of the azimuthal and the radial \
eigenfunctions for only those states, contributing significantly to the sum \
(here we use the value ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", 
          RowBox[{"-", "4"}]], TraditionalForm]]],
  " for the relative contribution, which is sufficient for graphics \
purposes)."
}], "Text"],

Cell[TextData[{
  "constructEigenFunction[evec_] :=\nModule[{maxBasisValues, relWeightList, \
\[CurlyEpsilon]R, ef, n, m,\n        ",
  StyleBox["(* small enough for graphics purposes *)", "CodeComment"],
  " \[CurlyEpsilon] = 10^-4},\n       ",
  StyleBox["(* relative size of products of expansion coefficients \n         \
 times [radial part of the] eigenvector magnitude *)", "CodeComment"],
  "\n       maxBasisValues = Table[Max[Abs[RList @@ nmNumbers[j]]], \n        \
                      {j, Length[evec]}];\n       relWeightList = \
maxBasisValues Abs[evec];\n       \[CurlyEpsilon]R = \[CurlyEpsilon] \
Max[relWeightList];                     \n       ",
  StyleBox["(* assume RList is a global variable *)", "CodeComment"],
  "\n       ef = Table[0., {Length[RList[0, 1]]}, \
{Length[\[CapitalPhi]List[1]]}];\n       ",
  StyleBox["(* add all eigenfunctions that contribute significantly *)", 
    "CodeComment"],
  "\n       Do[If[relWeightList[[j]] > \[CurlyEpsilon]R,\n             {n, m} \
= nmNumbers[j]; \n             ",
  StyleBox["(* faster method for: \n                ", "CodeComment"],
  StyleBox["ef = ef + evec[[j]] Outer[Times, RList[n, m], \
\[CapitalPhi]List[m]];", "CodeComment"],
  StyleBox[" *)", "CodeComment"],
  "\n             LinearAlgebra`BLAS`GER[Evaluate[evec[[j]]], \n              \
                         RList[n, m], \[CapitalPhi]List[m], ef]],\n          \
{j, Length[evec]}];\n       ",
  StyleBox["(* return summed eigenfunction *)", "CodeComment"],
  " ef]"
}], "Input"],

Cell[TextData[{
  "We start with a calculation of the states for the parameter values ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "=", "1"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Beta]", "=", 
          RowBox[{
            RowBox[{"-", "1"}], "/", "2"}]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Gamma]", "=", 
          RowBox[{"-", "3"}]}], TraditionalForm]]],
  ". We use a relatively small basis of 650 states (up to energy 50) and \
diagonalize the full (dense) matrix). Here are the lowest eigenvalues."
}], "Text"],

Cell[TextData[{
  StyleBox["(* number all basis function up to energy 50 (basis size 650) *)",
     "CodeComment"],
  "\nnumberEvenBasisFunctions[50]; Print[\"dim = \", dim]; \n",
  StyleBox["(* form sparse Hill matrix *)", "CodeComment"],
  "\nSA = With[{\[Omega] = 1}, SparseHillMatrix[N @ {1, -1/2, -3}, N @ \
\[Omega]]]; \n",
  StyleBox["(* calculate eigenvalues and eigenvectors *)", "CodeComment"],
  "\nesystem = Eigensystem[N[Normal[SA]]]; \n",
  StyleBox["(* sort by increasing eigenvalues *)", "CodeComment"],
  "\naux = Sort[MapIndexed[{#1, #2[[1]]} & , esystem[[1]]]]; \nevecs = \
esystem[[2, Last /@ aux]];\nFirst /@ Take[aux, 6]"
}], "Input"],

Cell["\<\
A quick look at the eigenvectors shows that this basis is a bit too \
small for a reliable visualization (we will use larger bases in a moment). \
But for a qualitative correct graphics we have enough information.\
\>", \
"Text"],

Cell["\<\
Show[GraphicsArray[
Table[ListPlot[Log[10, Abs[evecs[[j]]]], 
               PlotRange -> {0, -6}, AxesOrigin -> {0, 0},
               DisplayFunction -> Identity], {j, 3}]]]\
\>", "Input"],

Cell[TextData[{
  "Now, we calculate the discretized radial eigenfunctions and display the \
squares of the eigenfunctions as 3D plots. The qualitative shape of the \
eigenfunctions is as expected: in the ground state we see the full symmetry \
of the potential. The next higher states still have the reflection symmetry \
with respect to the ",
  Cell[BoxData[
      FormBox["x", TraditionalForm]]],
  "\[Hyphen]axis. The second even state has only a slightly higher energy \
than the ground state (for three independent wells, the splitting will be \
exponentially small)."
}], "Text"],

Cell[TextData[{
  StyleBox["(* calculate position representation of eigenfunctions *)\n", 
    "CodeComment"],
  "cacheEigenFunctionLists[1, 6, {60, 120}]"
}], "Input"],

Cell["\<\
Show[GraphicsArray[
 Block[{$DisplayFunction = Identity}, 
  Table[polarListPlot3D[constructEigenFunction[evecs[[j]]]^2, 6,
                        SurfaceColor[Hue[0.12], Hue[0], 2.5]], 
        {j, 3}]]]]\
\>", "Input"],

Cell["Here is a higher state shown.", "Text"],

Cell["\<\
polarListPlot3D[constructEigenFunction[evecs[[24]]]^2, 6,
                        SurfaceColor[Hue[0.78], Hue[0.12], 2.26]]\
\>", \
"Input"],

Cell["Here are contour plots of some of the higher states.", "Text"],

Cell["\<\
Show[GraphicsArray[
 Block[{$DisplayFunction = Identity}, 
  Table[polarListContourPlot[constructEigenFunction[evecs[[j]]]^2, False], 
        {j, 10, 12}]]]]\
\>", "Input"],

Cell[TextData[{
  "Using ",
  StyleBox["True", "MR"],
  " for the second argument of ",
  StyleBox["polarListContourPlot", "MR"],
  " yields plots whose fine structure reflects the details of the numerical \
evaluation of the eigenfunctions. Changing the basis size of the azimuthal \
and radial discretization would show differently\[Hyphen]looking plots for \
the setting ",
  StyleBox["True", "MR"],
  "."
}], "Text"],

Cell["(DownValues[In, Sort -> True][[-2]] /. False -> True)[[2]]", "Input"],

Cell[TextData[{
  "Now, we visualize some of higher states for some selected potentials. Due \
to their considerably more complicated structure, the contour plot generated \
by ",
  StyleBox["polarListContourPlot", "MR"],
  " is frequently easier to grasp than the corresponding 3D plot from ",
  StyleBox["polarListPlot3D", "MR"],
  ". Given a parity ",
  StyleBox["evenOdd", "TI"],
  ", set of potential parameters ",
  Cell[BoxData[
      FormBox["\[Beta]", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["\[Gamma]", TraditionalForm]]],
  ", the maximal energy of the 2D harmonic oscillator basis states ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  ", and its frequency ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ", the function ",
  StyleBox["eigenFunctionContourPlotArray", "MR"],
  " calculates and displays ",
  Cell[BoxData[
      FormBox["\[ScriptO]", TraditionalForm]]],
  " states around the energy ",
  StyleBox["shift", "TI"],
  " above the potential bottom. The option ",
  StyleBox["showEigenvectorComponents", "MR"],
  " shows the base 10 logarithm of the absolute values of the eigenvector \
component. This allows to judge the correctness of the contour plots."
}], "Text"],

Cell[TextData[{
  StyleBox["(* estimate spatial extension of a state with energy \
\[CurlyEpsilon] \n   in a potential with parameters {\[Alpha], \[Beta], \
\[Gamma]} *)", "CodeComment"],
  "\nrClassical[\[CurlyEpsilon]_, {\[Alpha]_, \[Beta]_, \[Gamma]_}] := \
Max[Function[pm1, \nSelect[\[Rho] /. {ToRules[NRoots[\[CurlyEpsilon] == \
\[Alpha] \[Rho]^4 + \[Beta] \[Rho]^2 + pm1 \[Gamma] \[Rho]^3, \[Rho]]]},\n    \
   (Im[#] == 0 && # > 0)&]] /@ {+1, -1}]"
}], "Input"],

Cell[TextData[{
  "\n",
  "eigenFunctionContourPlotArray[evenOdd: (Even | Odd), \n                    \
          {\[Beta]_, \[Gamma]_}, {\[CurlyEpsilon]Max_, \[Omega]_}, {shift_, \
\[ScriptO]_},\n                              {ppr_, pp\[CurlyPhi]_}, opts___] \
:=\nModule[{SA, evecs, \[ScriptCapitalR], gef, \[Lambda] = 3}, \nPrint[{\
\[Beta], \[Gamma]}];\nIf[evenOdd === Even, numberEvenBasisFunctions, \n       \
              numberOddBasisFunctions][\[CurlyEpsilon]Max]; \n\
Print[\"dimFinal = \", dim]; \n",
  StyleBox["(* use high precision to guarantee that matrix is symmetric *)", 
    "CodeComment"],
  "\nSA = N[SparseHillMatrix[{1, \[Beta], \[Gamma]}, SetPrecision[\[Omega], \
30]]]; Print[SA];\n",
  StyleBox["(* calculate eigenvalues *)", "CodeComment"],
  "\nevecs = Reverse @ \nEigenvectors[SA, \[ScriptO], Method -> {\"Arnoldi\", \
Tolerance -> 10^-8,\n             BasisSize -> Min[dim, Abs[20 \[ScriptO]]], \
MaxIterations -> 10^4,\n             Shift -> shift}]; Print[\"evecs done\"];\
\n",
  StyleBox["(* approximate spatial extension of the wavefunction *)", 
    "CodeComment"],
  "            \n\[ScriptCapitalR] = 1.1 rClassical[N[shift], {1, \[Beta], \
\[Gamma]}] + 1/4; Print[\"\[ScriptCapitalR] = \", \[ScriptCapitalR]];\n",
  StyleBox["(* calculate discretized 2D HO eigenfunctions *)", 
    "CodeComment"],
  "  \ncacheEigenFunctionLists[\[Omega], \[ScriptCapitalR], {ppr, pp\
\[CurlyPhi]}];\n",
  StyleBox["(* partition a list into length \[Lambda]; append potential rest \
*)", "CodeComment"],
  "  \npartition[l_] := If[Mod[Length[l], \[Lambda]] === 0, Partition[l, \
\[Lambda]],\n         Append[Partition[l, \[Lambda]], Take[l, -Mod[Length[l], \
\[Lambda]]]]];\n",
  StyleBox["(* potentially show eigenvectors *)", "CodeComment"],
  "  \nIf[(# /. {opts} /. # -> False)&[showEigenvectorComponents],\n   \
Show[GraphicsArray[#]]& /@ \n   partition[ListPlot[Log[10, Abs[#]], PlotRange \
-> {-6, 0}, \n                      DisplayFunction -> Identity, \n           \
           AxesOrigin -> {0, 0}]& /@ evecs]];\n",
  StyleBox["(* show eigenfunctions squared *)", "CodeComment"],
  "     \nShow[GraphicsArray[#]]& /@ partition[\nTable[gef = \
constructEigenFunction[evecs[[j]]];\n      Block[{$DisplayFunction = \
Identity}, \n            polarListContourPlot[Abs[gef]^2]], {j, \
\[ScriptO]}]]]"
}], "Input"],

Cell[TextData[{
  "Now we have all functions implement to lean back and enjoy a gallery of H\
\[EAcute]non\[Dash]Heiles potential eigenfunctions. While the function ",
  StyleBox["eigenFunctionContourPlotArray", "MR"],
  " displays list plots of the Hill matrix eigenvectors, we do not show them \
explicitly. The reader can readily rerun the code to check that all \
eigenvectors decay rapidly enough to allow for a reliable visualization. We \
will always display six energetically consecutive states. In average, every \
third state has the full threefold rotational symmetry. "
}], "Text"],

Cell[TextData[{
  "We start with some relatively simple eigenfunctions using 6480 basis \
functions. The reflection symmetry on the real axis and the relicts of the \
threefold rotational symmetry are clearly visible. We also show the size of \
the eigenvectors of the Hill matrix. The eigenvectors decay quickly. The \
decay of the Hill matrix eigenfunctions depends on the chosen ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ". As a rule of thumb, we use in the following a value of ",
  Cell[BoxData[
      FormBox["\[Omega]", TraditionalForm]]],
  ", such that ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["r", "c"], "\[TildeTilde]", 
          RowBox[{"k", " ", "\[Omega]"}]}], TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["r", "c"], TraditionalForm]]],
  " is the maximal classical extension of a state and ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  " is a small integer. "
}], "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {205/42, -13/3}, {160, 3/2}, \
{57, 6},
               {90, 120}, showEigenvectorComponents -> False]\
\>", "Input"],

Cell["\<\
Here are some slightly more complicated states. We use 8190 basis \
functions. Neighbor states can have quite different\[Hyphen]looking \
probability distributions.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {-49/47, 149/86}, {180, 3/2}, \
{106, 6},
               {90, 120}, showEigenvectorComponents -> False]\
\>", "Input"],

Cell["\<\
And the next set of states shows only a minor influence of the \
three wells on the probability distributions.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {487/100, 191/31}, {220, 3/2}, \
{101, 6},
                  {120, 160},  showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
We continue with two sets of higher states having more \
structures.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {70/17, -249/55}, {200, 3/2}, \
{95, 6},
                          {90, 120}, showEigenvectorComponents -> \
False]\
\>", "Input"],

Cell["\<\
For the next states, we use more plot points to obtain a better \
resolved graphics of their fine structure.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {259/44, 117/47}, {180, 2}, \
{180, 6},
                    {120, 160}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
To visualize still higher states reliably, we use a larger basis \
set containing 14520 functions.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Even, {247/88, 163/34}, {240, 2}, \
{210, 6},
                        {120, 160}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
We now move on to the odd states. The odd states look qualitatively \
similar to the even states. Here are again some relatively simple \
states.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {-481/85, -17/8}, {160, 3/2}, \
{95, 6},
                   {90, 120}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["Here are three sets of slightly more complicates states.", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {-5, -19/6}, {180, 2}, {145, 6},
                {120, 160}, showEigenvectorComponents -> False]\
\>", "Input"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {286/83, 8/3}, {180, 2}, {155, \
6},
                      {120, 160}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {479/80, 423/97}, {180, 2}, \
{133, 6},
                   {120, 160}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
We continue with some more complicated states. We again use a \
larger basis size.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {-8/11, -36/11}, {180, 5/2}, \
{171, 6},
                      {120, 160}, showEigenvectorComponents -> False]\
\>", \
"Input"],

Cell["\<\
We end with some still higher states of the potential from the last \
example.\
\>", "Text"],

Cell["\<\
eigenFunctionContourPlotArray[Odd, {-8/11, -36/11}, {200, 2}, {220, \
6},
                      {150, 200}, showEigenvectorComponents -> False]\
\>", \
"Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Symbolics Volume, Chapter 3", "Section"],

Cell[CellGroupData[{

Cell[TextData[{
  "  1.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Rational Value of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[InvisiblePrefixScriptBase]", 
              FormBox["2",
                "TraditionalForm"]], 
            SubscriptBox["F", 
              FormBox["1",
                "TraditionalForm"]]}], "(", 
          RowBox[{"a", ",", 
            RowBox[{"b", ";", "c", ";", "z"}]}], ")"}], TraditionalForm]]]
}], "ExerciseHeading"],

Cell[TextData[{
  "Find an examples of a Gauss hypergeometric function ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[InvisiblePrefixScriptBase]", 
              FormBox["2",
                "TraditionalForm"]], 
            SubscriptBox["F", 
              FormBox["1",
                "TraditionalForm"]]}], "(", 
          RowBox[{"a", ",", 
            RowBox[{"b", ";", "c", ";", "z"}]}], ")"}], TraditionalForm]]],
  " with rational arguments ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["b", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["c", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " that has a rational value which ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " does not find directly, or by using ",
  StyleBox["FunctionExpand", "MR"],
  " or ",
  StyleBox["FullSimplify", "MR"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We first find a set of  Gauss hypergeometric functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["\[InvisiblePrefixScriptBase]", 
              FormBox["2",
                "TraditionalForm"]], 
            SubscriptBox["F", 
              FormBox["1",
                "TraditionalForm"]]}], "(", 
          RowBox[{"a", ",", 
            RowBox[{"b", ";", "c", ";", "z"}]}], ")"}], TraditionalForm]]],
  " that do not autosimplify for explicit rational ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["b", TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox["c", TraditionalForm]]],
  " and symbolic ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". Restricting ",
  Cell[BoxData[
      FormBox["a", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["b", TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["c", TraditionalForm]]],
  " to be proper fractions with maximal denominator 6, we have 652 such \
hypergeometric functions. "
}], "SolutionSubgroup"],

Cell[TextData[{
  "abcMaxDenominator = 6;\nabcs = Union[Flatten[Table[i/j, {j, \
abcMaxDenominator}, {i, 0, j}]]];\n\n",
  StyleBox["(* use symmetry in a and b *)", "CodeComment"],
  "\nabs = Flatten[Table[{abcs[[i]], abcs[[j]]}, {i, Length[abcs]}, \n        \
                                    {j, i - 1}], 1];\n                        \
                    \nLength[abc = Flatten[Function[ab, Append[ab, #]& /@ \
abcs] /@ abs, 1]]"
}], "Input"],

Cell["\<\
hyps[z_] = Select[Hypergeometric2F1[##, z]& @@@ abc, 
                  MemberQ[#, Hypergeometric2F1, {0, Infinity}, Heads -> \
True]&] /.
                  Hypergeometric2F1 -> hypergeometric2F1;
                  
Length[hyps[z]]\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["rationalQ", "MR"],
  " find a numerical approximation for ",
  Cell[BoxData[
      FormBox["\[Zeta]", TraditionalForm]]],
  " and checks if this number is a nice fraction."
}], "Text"],

Cell[TextData[{
  "rationalQ[\[Zeta]_] := \n   (Head[Rationalize[Hypergeometric2F1 @@ N[\
\[Zeta], 20]]] === Rational) &&\n   ",
  StyleBox["(* repeat with more digits *)", "CodeComment"],
  "\n   (Head[Rationalize[Hypergeometric2F1 @@ N[\[Zeta], 50]]] === \
Rational)"
}], "Input"],

Cell[TextData[{
  "Now, we use values for ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " which are proper fractions with a given denominator in ",
  StyleBox["hyps[", "MR"],
  StyleBox["z", "TI"],
  StyleBox["]", "MR"],
  " and select the ones that are fractions. We increase the denominator value \
until we find a result. After a few minutes, we find the example ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{
              SubscriptBox["\[InvisiblePrefixScriptBase]", 
                FormBox["2",
                  "TraditionalForm"]], 
              SubscriptBox["F", 
                FormBox["1",
                  "TraditionalForm"]]}], "\[InvisibleApplication]", 
            RowBox[{"(", 
              RowBox[{
                TagBox[
                  TagBox[
                    RowBox[{
                      TagBox[
                        RowBox[{"2", "/", "3"}],
                        Hypergeometric2F1,
                        Editable->True], ",", 
                      TagBox[
                        RowBox[{"1", "/", "3"}],
                        Hypergeometric2F1,
                        Editable->True]}],
                    InterpretTemplate[ {
                      SlotSequence[ 1]}&]],
                  Hypergeometric2F1,
                  Editable->False], ";", 
                TagBox[
                  TagBox[
                    TagBox[
                      RowBox[{"5", "/", "6"}],
                      Hypergeometric2F1,
                      Editable->True],
                    InterpretTemplate[ {
                      SlotSequence[ 1]}&]],
                  Hypergeometric2F1,
                  Editable->False], ";", 
                TagBox[
                  RowBox[{"27", "/", "32"}],
                  Hypergeometric2F1,
                  Editable->True]}], ")"}]}], "=", 
          RowBox[{"8", "/", "5"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
denominatorNFractions[n_] := Select[Range[n - 1]/n, Denominator[#] \
== n&]\
\>", "Input"],

Cell["\<\
n = 1;
While[rat2F1s = Flatten[Select[hyps[#], rationalQ]& /@ 
                            denominatorNFractions[n]];
      rat2F1s === {}, n++];    
rat2F1s  /.  hypergeometric2F1 -> Hypergeometric2F1              \
\>", \
"Input"],

Cell["Rationalize[N[%, 1000]]", "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  2.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Discrete Harmonic Oscillator Wave Functions"
}], "ExerciseHeading"],

Cell[TextData[{
  "Discrete equivalents of the continuous Hermite polynomials times weight \
function ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{
                SuperscriptBox["\[Pi]", 
                  RowBox[{"1", "/", "2"}]], 
                SuperscriptBox["2", "n"], 
                RowBox[{"n", "!"}]}], ")"}], 
            RowBox[{
              RowBox[{"-", "1"}], "/", "2"}]], 
          RowBox[{"exp", "(", 
            RowBox[{
              RowBox[{"-", 
                SuperscriptBox["\[Xi]", "2"]}], "/", "2"}], ")"}], 
          RowBox[{
            SubscriptBox["H", "n"], "(", "\[Xi]", ")"}]}], 
        TraditionalForm]]],
  " are given by [",
  
  CounterBox["BibliographyCounter", "Atakishiyev01"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Atakishiyev01",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Atakishiyev03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Atakishiyev03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Atakishiyev04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Atakishiyev04",
    ButtonStyle->"Hyperlink"],
  "], ",
  "[",
  
  CounterBox["BibliographyCounter", "Lorente04"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Lorente04",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["f", "m", "j"], "(", "q", ")"}], ":=", 
        RowBox[{
          StyleBox[
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{"-", "1"}], ")"}], 
              RowBox[{"j", "+", "m"}]],
            GridBoxOptions->{ColumnAlignments->{Center}}], 
          StyleBox[" ",
            GridBoxOptions->{ColumnAlignments->{Center}}], 
          StyleBox[
            SuperscriptBox["2", 
              RowBox[{"-", "j"}]],
            GridBoxOptions->{ColumnAlignments->{Center}}], 
          StyleBox[" ",
            GridBoxOptions->{ColumnAlignments->{Center}}], 
          StyleBox[
            SqrtBox[
              StyleBox[
                RowBox[{
                  TagBox[
                    RowBox[{"(", GridBox[{
                          {
                            TagBox[
                              RowBox[{"2", " ", "j"}],
                              Identity,
                              Editable->True]},
                          {
                            TagBox[
                              RowBox[{"j", "+", "m"}],
                              Identity,
                              Editable->True]}
                          }], ")"}],
                    InterpretTemplate[ Binomial[ #, #2]&],
                    Editable->False], " ", 
                  TagBox[
                    RowBox[{"(", GridBox[{
                          {
                            TagBox[
                              RowBox[{"2", " ", "j"}],
                              Identity,
                              Editable->True]},
                          {
                            TagBox[
                              RowBox[{"j", "+", "q"}],
                              Identity,
                              Editable->True]}
                          }], ")"}],
                    InterpretTemplate[ Binomial[ #, #2]&],
                    Editable->False]}],
                SpanMinSize->3]],
            GridBoxOptions->{ColumnAlignments->{Center}}], " ", 
          RowBox[{
            SubscriptBox["K", 
              RowBox[{"j", "+", "m"}]], "(", 
            RowBox[{
              RowBox[{
                RowBox[{"j", "+", "q"}], ";", 
                FractionBox["1", "2"]}], ",", 
              RowBox[{"2", " ", "j"}]}], ")"}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "where ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["K", "n"], "(", 
          RowBox[{
            RowBox[{"x", ";", "p"}], ",", "\[Nu]"}], ")"}], 
        TraditionalForm]]],
  " are the symmetric Kravchuk polynomials ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            SubscriptBox["K", "n"], "(", 
            RowBox[{
              RowBox[{"x", ";", "p"}], ",", "\[Nu]"}], ")"}], 
          SubscriptBox["=", 
            RowBox[{" ", "2"}]], "\[NegativeThinSpace]", 
          RowBox[{
            SubscriptBox["F", "1"], "(", 
            RowBox[{
              RowBox[{"-", "n"}], ",", 
              RowBox[{
                RowBox[{"-", "x"}], ";", 
                RowBox[{"-", "\[Nu]"}], ";", 
                RowBox[{"1", "/", "p"}]}]}], ")"}]}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  " is a positive integer, ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " are positive integers fulfilling ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            RowBox[{"-", "j"}], "\[LessEqual]", "q"}], ",", 
          RowBox[{"m", "\[LessEqual]", "j"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "Visualize the resulting discrete functions. As ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  " approaches infinity, the Hermite polynomials times weight function are \
recovered in the following way:"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderscriptBox["lim", 
            RowBox[{"j", "\[Rule]", "\[Infinity]"}]], 
          RowBox[{
            RadicalBox["j", "4"], 
            RowBox[{
              SubsuperscriptBox["f", 
                RowBox[{"n", "-", "j"}], "j"], "(", 
              RowBox[{
                SqrtBox["j"], "q"}], ")"}]}]}], "=", 
        RowBox[{
          FractionBox["1", 
            SqrtBox[
              RowBox[{
                SqrtBox["\[Pi]"], " ", 
                SuperscriptBox["2", "n"], " ", 
                RowBox[{"n", "!"}]}]]], 
          RowBox[{"exp", "(", 
            RowBox[{"-", 
              FractionBox[
                SuperscriptBox["\[Xi]", "2"], "2"]}], ")"}], 
          RowBox[{
            SubscriptBox["H", "n"], "(", "\[Xi]", ")"}]}]}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For a fixed ",
  Cell[BoxData[
      FormBox["j", TraditionalForm]]],
  ", calculate how the left\[Hyphen] and the right\[Hyphen] hand sides of the \
last equation differ as a function of ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with defining the discrete and continuous harmonic oscillator \
eigenfunctions. The functions ",
  StyleBox["discreteHOWF", "MR"],
  " and ",
  StyleBox["continuousHOWF", "MR"],
  " both return a list of values of the form ",
  StyleBox["{", "MR"],
  StyleBox["coordinate", "TI"],
  StyleBox[", ", "MR"],
  StyleBox["value", "TI"],
  StyleBox["}", "MR"],
  "."
}], "SolutionSubgroup"],

Cell[TextData[{
  "KravtchukK[n_, x_, p_, \[Nu]_] = Hypergeometric2F1[-n, -x, -\[Nu], 1/p];\n\
",
  StyleBox["(* let Hypergeometric2F1 autoevaluate in the degenerate case *", 
    "CodeComment"],
  ")\nKravtchukK[n_, \[Xi]_, p_, \[Xi]_] = Hypergeometric2F1[-n, -\[Xi], -\
\[Xi], 1/p];\n\nf[m_, j_, q_] := (-1)^(j + m) 2^-j Sqrt[Binomial[2j, j + m] \
Binomial[2j, j + q]]*\n                 KravtchukK[j + m, j + q, 1/2, 2j]\n   \
              \ndiscreteHOWF[j_][n_, q_] := {j^(-1/2) q, j^(1/4) f[n - j, j, \
q]}\ncontinuousHOWF[n_, \[Xi]_] := {\[Xi], Exp[-\[Xi]^2/2] HermiteH[n, \
\[Xi]]/Sqrt[Sqrt[Pi] 2^n n!]}"
}], "Input"],

Cell[TextData[{
  "The next graphic shows all discrete wave functions for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"j", "=", "128"}], TraditionalForm]]],
  " at once."
}], "Text"],

Cell["\<\
With[{j = 128}, 
     Show[Graphics[{PointSize[0.002],
     Table[{Hue[0.8 n/j], Point[N[discreteHOWF[j][n, q], 200]]}, 
           {n, 0, j}, {q, -j, j}]},  PlotRange -> All]]]\
\>", "Input"],

Cell[TextData[{
  "The following graphic shows the lowest discrete wave functions for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"j", "=", "128"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
With[{j = 128, nMax = 12},
Show[Graphics[Table[{Hue[0.8 n/nMax], PointSize[0.006],
                Point /@ #, Line[#]}&[
                 Table[discreteHOWF[j][n, q], {q, -j, j}]],
               {n, 0, nMax}]], PlotRange -> All, AspectRatio -> 1/4]]\
\>", \
"Input"],

Cell[TextData[{
  "The next three graphic show the discrete wave functions as points and the \
continuous ones as curves. For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "\[LessLess]", "j"}], TraditionalForm]]],
  ", the discrete wave functions are an excellent approximation to the \
continuous one."
}], "Text"],

Cell["\<\
With[{j = 128, n = 6},
Show[GraphicsArray[Function[n, 
Graphics[{{Hue[0], PointSize[0.008], Point /@ #},
               {GrayLevel[0], Thickness[0.0001],
                Line[{#, continuousHOWF[n, #][[2]]}& @@@ #]}}&[
                Table[discreteHOWF[j][n, q], {q, -j, j}]],
                PlotRange -> All]] /@ {6, 20, 40}]]]\
\>", "Input"],

Cell["\<\
The sum of the squares of the differences (between the discrete and \
the continuous wave functions) at the discrete points shows the features of \
the last graphic more quantitatively. Interestingly, the sum of squares \
oscillates around a limiting value.\
\>", "Text"],

Cell[TextData[{
  "\[Delta][j_, n_, prec_] := ",
  StyleBox["(* sum square of differences *)", "CodeComment"],
  "\nSum[(#2 - continuousHOWF[n, #1][[2]])^2& @@\n     discreteHOWF[N[j, \
prec]][N[n, prec], N[q, prec]], {q, -j, j}]"
}], "Input"],

Cell["\<\
\[Delta]Data = Table[{n, \[Delta][128, n, 120]}, {n, 128}];
ListPlot[Log[10, \[Delta]Data], PlotRange -> All]\
\>", "Input"],

Cell[TextData[{
  "For a (Fock\[Hyphen]space\[Hyphen])truncated harmonic oscillator, see [",
  
  CounterBox["BibliographyCounter", "Trzetrzelewski03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Trzetrzelewski03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  3.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Average Length of Smallest Component of ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D Unit Vectors"
}], "ExerciseHeading"],

Cell[TextData[{
  "The average length ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          OverscriptBox[
            SubsuperscriptBox["x", "d", "<"], "_"], "=", 
          RowBox[{
            UnderscriptBox["min", 
              RowBox[{"1", "\[LessEqual]", "j", "\[LessEqual]", "d"}]], 
            RowBox[{"\[LeftBracketingBar]", 
              SubscriptBox["x", "j"], "\[RightBracketingBar]"}]}]}], 
        TraditionalForm]]],
  " of the absolute value of the smallest component of a point ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["x", "1"], ",", 
            SubscriptBox["x", "2"], ",", "\[Ellipsis]", ",", 
            SubscriptBox["x", "d"]}], "}"}], TraditionalForm]]],
  " on a ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere is [",
  
  CounterBox["BibliographyCounter", "Rivin03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Rivin03",
    ButtonStyle->"Hyperlink"],
  "]"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        OverscriptBox[
          SubsuperscriptBox["x", "d", "<"], "_"], "=", 
        RowBox[{
          FractionBox[
            RowBox[{
              RowBox[{"\[CapitalGamma]", "(", 
                RowBox[{"d", "/", "2"}], ")"}], " "}], 
            RowBox[{"\[CapitalGamma]", "(", 
              RowBox[{
                RowBox[{"(", 
                  RowBox[{"d", "+", "1"}], ")"}], "/", "2"}], ")"}]], 
          RowBox[{
            SubsuperscriptBox["\[Integral]", "0", "\[Infinity]"], 
            RowBox[{
              SuperscriptBox[
                RowBox[{"(", 
                  RowBox[{"1", "-", 
                    RowBox[{"erf", "(", "y", ")"}]}], ")"}], "d"], "d", 
              "\[InvisibleSpace]", 
              RowBox[{"y", "."}]}]}]}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "For each ",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "\[LessEqual]", "d", "\[LessEqual]", "10"}], 
        TraditionalForm]]],
  ", calculate ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "6"], TraditionalForm]]],
  " random points and the resulting average of the absolute value of the \
smallest component. "
}], "Text"],

Cell[TextData[{
  "A random point (with respect to the area) on a ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere can be calculated in the following recursive way [",
  
  CounterBox["BibliographyCounter", "Hicks59"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Hicks59",
    ButtonStyle->"Hyperlink"],
  "]. Given a (random) point ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["x", "1"], ",", 
            SubscriptBox["x", "2"], ",", "\[Ellipsis]", ",", 
            SubscriptBox["x", 
              RowBox[{"d", "-", "1"}]]}], "}"}], TraditionalForm]]],
  " on a ",
  Cell[BoxData[
      FormBox[
        RowBox[{"(", 
          RowBox[{"d", "-", "1"}], ")"}], TraditionalForm]]],
  "D unit sphere, the point ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{"r", " ", 
              SubscriptBox["x", "1"]}], ",", 
            RowBox[{"r", " ", 
              SubscriptBox["x", "2"]}], ",", "\[Ellipsis]", ",", 
            RowBox[{"r", " ", 
              SubscriptBox["x", 
                RowBox[{"d", "-", "1"}]]}], ",", 
            RowBox[{"\[PlusMinus]", 
              SqrtBox[
                RowBox[{"1", "-", 
                  SuperscriptBox["r", "2"]}]]}]}], "}"}], TraditionalForm]]],
  " is a random point on a ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere. Here ",
  Cell[BoxData[
      FormBox[Cell["\[PlusMinus]"], TraditionalForm]]],
  " is chosen with equal probability to generate a point on the upper/lower \
hemisphere of the ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere. Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{"r", "=", 
          RowBox[{
            SubscriptBox["f", "d"], "(", "\[DoubleStruckR]", ")"}]}], 
        TraditionalForm]]],
  " where ",
  Cell[BoxData[
      FormBox["\[DoubleStruckR]", TraditionalForm]]],
  " is a uniformly in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"[", 
          RowBox[{"0", ",", "1"}], "]"}], TraditionalForm]]],
  " distributed variable and the inverse function ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["f", "d", 
            RowBox[{"-", "1"}]], "(", "\[DoubleStruckR]", ")"}], 
        TraditionalForm]]],
  " is defined through"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SubsuperscriptBox["f", "d", 
            RowBox[{"-", "1"}]], "(", "\[Xi]", ")"}], "=", 
        RowBox[{
          FractionBox[
            RowBox[{
              SubsuperscriptBox["\[Integral]", "0", "\[Xi]"], 
              RowBox[{
                SuperscriptBox[
                  RowBox[{
                    SuperscriptBox["\[Rho]", 
                      RowBox[{"d", "-", "2"}]], "(", 
                    RowBox[{"1", "-", 
                      SuperscriptBox["\[Rho]", "2"]}], ")"}], 
                  RowBox[{
                    RowBox[{"-", "1"}], "/", "2"}]], "d", "\[InvisibleSpace]",
                 "\[Rho]"}]}], 
            RowBox[{
              SubsuperscriptBox["\[Integral]", "0", "1"], 
              RowBox[{
                SuperscriptBox[
                  RowBox[{
                    SuperscriptBox["\[Rho]", 
                      RowBox[{"d", "-", "2"}]], "(", 
                    RowBox[{"1", "-", 
                      SuperscriptBox["\[Rho]", "2"]}], ")"}], 
                  RowBox[{
                    RowBox[{"-", "1"}], "/", "2"}]], "d", "\[InvisibleSpace]",
                 "\[Rho]"}]}]], "."}]}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Starting with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{"\[PlusMinus]", "1"}], "}"}], TraditionalForm]]],
  " (",
  Cell[BoxData[
      FormBox[Cell["\[PlusMinus]"], TraditionalForm]]],
  " with equal probability), this procedure generates randomly distributed \
points on a ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We start with the calculation of the function ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["f", "d"], TraditionalForm]]],
  ". Although ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["f", "d", 
          RowBox[{"-", "1"}]], TraditionalForm]]],
  " can be obtained in closed form through incomplete Beta functions, ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["f", "d"], TraditionalForm]]],
  " cannot be expressed in closed form for all ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  " (it can be expressed in closed form for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"d", "=", "2"}], TraditionalForm]]],
  " and all odd ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "). We calculate ",
  Cell[BoxData[
      FormBox[
        SubsuperscriptBox["f", "d", 
          RowBox[{"-", "1"}]], TraditionalForm]]],
  " numerically by solving the corresponding differential equation, invert it \
in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            SubscriptBox["f", "d"], ",", 
            RowBox[{"(", "\[Rho]", ")"}], ",", "\[Rho]"}], "}"}], 
        TraditionalForm]]],
  ", and interpolate the data. This avoids time\[Hyphen]consuming root\
\[Hyphen]finding steps."
}], "SolutionSubgroup"],

Cell[TextData[{
  StyleBox["(* avoid messages due to singularity at \[Rho] == 1 *)", 
    "CodeComment"],
  "\nOff[NDSolve::ndsz]; Off[InterpolatingFunction::dmval];"
}], "Input"],

Cell[TextData[{
  "Module[{pp = 200, \[CapitalEpsilon] = 10^100, fInv, fInvSol, \[Rho]}, \n\
Do[",
  StyleBox["(* solve for f_d *)", "CodeComment"],
  "\n   fInvSol = NDSolve[{fInv'[\[Rho]] == Which[\[Rho] == 0, 0, \[Rho] == \
1, \[CapitalEpsilon], \n                                        True, \
\[Rho]^(d - 2)/Sqrt[1 - \[Rho]^2]], \n                      fInv[0] == 0}, \n \
                 fInv, {\[Rho], 0, 1}, PrecisionGoal -> 16,\n                 \
 AccuracyGoal -> 16, WorkingPrecision -> 30,\n                  MaxSteps -> \
10^4][[1, 1, 2]];\n   FInv1 = fInvSol[1];\n   ",
  StyleBox["(* interpolate inverted data *)", "CodeComment"],
  "\n   f[d] = Interpolation[Table[{If[\[Rho] == 1, 1, \
fInvSol[\[Rho]]/FInv1], \[Rho]} // N, \n                              \
{\[Rho], 0, 1, 1/pp}]],\n   {d, 2, 21}]]"
}], "Input"],

Cell[TextData[{
  "Here are the ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["f", "d"], "(", "\[Xi]", ")"}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"2", "\[LessEqual]", "d", "\[LessEqual]", "21"}], 
        TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
Plot[Evaluate[Table[f[d][\[Rho]], {d, 2, 21}]], {\[Rho], 0, 1}, 
     PlotRange -> All, PlotStyle -> Table[Hue[n/26], {n, 2, 21}]]\
\>", \
"Input"],

Cell[TextData[{
  "Given a vector ",
  StyleBox["x", "TI"],
  " on the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"(", 
          RowBox[{"d", "-", "1"}], ")"}], TraditionalForm]]],
  "D unit sphere, the function ",
  StyleBox["liftStep", "MR"],
  " generates a vector on the ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D unit sphere."
}], "Text"],

Cell["\<\
liftStep[x_List] := 
With[{r = f[Length[x] + 1][Random[]]}, 
     Join[r x, {(2. Random[Integer] - 1) Re[Sqrt[1 - r^2]]}]]\
\>", "Input"],

Cell[TextData[{
  "Nesting the function ",
  StyleBox["liftStep", "MR"],
  " yields the function ",
  StyleBox["random\[ScriptCapitalN]SpherePointList", "MR"],
  ". For a given positive integer ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  ", it returns a list of random points on a 1D sphere, 2D sphere, \
\[Ellipsis], ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D sphere."
}], "Text"],

Cell["\<\
random\[ScriptCapitalN]SpherePointList[d_] := 
       NestList[liftStep, {2. Random[Integer] - 1.}, d - 1]\
\>", "Input"],

Cell["\<\
The ensemble average of such points is uniformly distributed with \
respect to the surface area measure of the spheres. The following graphics \
show 1000 points on a circle and a classical sphere.\
\>", "Text"],

Cell["\<\
With[{pointList = Table[random\[ScriptCapitalN]SpherePointList[3], \
{1000}]}, 
Show[GraphicsArray[
     {Graphics[Point[#[[2]]]& /@ pointList,
               AspectRatio -> Automatic,
               PlotRange -> 1.66 {{-1, 1}, {-1, 1}}],
      Graphics3D[Point[#[[3]]]& /@ pointList,
                 PlotRange -> 1.1 {{-1, 1}, {-1, 1}, {-1, 1}}]}]]]     \
\>", \
"Input"],

Cell[TextData[{
  "The function ",
  StyleBox["randomxMinList", "MR"],
  " returns a list of the minimal length of the components of a random point \
on a 1D sphere, 2D sphere, \[Ellipsis], ",
  Cell[BoxData[
      FormBox["d", TraditionalForm]]],
  "D sphere."
}], "Text"],

Cell["\<\
randomxMinList[d_] := Min[Abs[#]]& /@ \
random\[ScriptCapitalN]SpherePointList[d]\
\>", "Input"],

Cell[TextData[{
  "Modelling now ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["10", "6"], TraditionalForm]]],
  " random points on spheres up to dimension 10 can be carried out in a few \
minutes."
}], "Text"],

Cell["\<\
dMax = 10; o = 10^6; 
SeedRandom[1];
(averages = Sum[randomxMinList[dMax], {o}]/o);  // Timing\
\>", "Input"],

Cell["\<\
The resulting averages agree excellently with the theoretical \
predictions.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* theoretical average value *)", "CodeComment"],
  "\nxMinTh[d_] := Gamma[d/2]/Gamma[(d + 1)/2]*\n              NIntegrate[(1 \
- Erf[y])^d, {y, 0, Infinity},\n                         PrecisionGoal -> 12]\
\n\n",
  StyleBox["(* list of {dimension, error in percent} *)", "CodeComment"],
  "\nMapIndexed[{#2[[1]], #1}&, \n           Round[10000 (Table[xMinTh[d], \
{d, dMax}]/\n                              averages - 1)]/100. \"%\"]"
}], "Input"],

Cell[TextData[{
  "For a computational more efficient way to produce random points on high\
\[Hyphen]dimensional spheres, see ",
  "[",
  
  CounterBox["BibliographyCounter", "Knuth69"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Knuth69",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  4.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " ODE for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " with respect to ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]]
}], "ExerciseHeading"],

Cell[TextData[{
  "Derive an ordinary differential equation for the Jacobi elliptic function \
",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " with respect to ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "The first derivatives of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " with respect to ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " are relatively complicated functions. "
}], "SolutionSubgroup"],

Cell["\<\
{D[JacobiSN[z, m], m], D[JacobiSN[z, m], m, m]} // \
TraditionalForm\
\>", "Input"],

Cell[TextData[{
  "Most functions appearing in the derivatives are Jacobi functions \
themselves and we could use the algebraic identities between them to \
eliminate them in favor of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  ". Most troublesome are the two elliptic integrals ",
  Cell[BoxData[
      FormBox[
        RowBox[{"E", "(", 
          RowBox[{
            RowBox[{"am", "(", 
              RowBox[{"z", "\[VerticalSeparator]", "m"}], ")"}], 
            "\[VerticalSeparator]", "m"}], ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"F", "(", 
          RowBox[{
            RowBox[{"am", "(", 
              RowBox[{"z", "\[VerticalSeparator]", "m"}], ")"}], 
            "\[VerticalSeparator]", "m"}], ")"}], TraditionalForm]]],
  ". The last one is of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          StyleBox["inverseFunction",
            "TI"], "(", 
          RowBox[{
            StyleBox["function",
              "TI"], "(", "z", ")"}], ")"}], TraditionalForm]]],
  " and ignoring branch cuts, we assume for differential\[Hyphen]algebraic \
purposes it is equal to ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". This leaves us with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"E", "(", 
          RowBox[{
            RowBox[{"am", "(", 
              RowBox[{"z", "\[VerticalSeparator]", "m"}], ")"}], 
            "\[VerticalSeparator]", "m"}], ")"}], TraditionalForm]]],
  ", which we eliminate from the first two derivatives."
}], "Text"],

Cell["\<\
For shorter formulas, we start by introducing some obvious \
abbreviations for the functions and derivatives involved.\
\>", "Text"],

Cell[TextData[{
  "eqs1 = Table[Numerator[Together[\n         d[k] - TrigExpand[D[JacobiSN[z, \
m], {m, k}]]]], {k, 2}] //. \n     ",
  StyleBox["(* introduce some abbreviations *)   ", "CodeComment"],
  " \n     {JacobiSN[z, m] -> sn, JacobiCN[z, m] -> cn, JacobiDN[z, m] -> dn, \
\n      JacobiCD[z, m] -> cd, JacobiDC[z, m] -> dc, JacobiNS[z, m] -> ns, \n  \
    JacobiSD[z, m] -> sd, JacobiNC[z, m] -> nc, JacobiDS[z, m] -> ds,\n      \
JacobiND[z, m] -> nd, JacobiSC[z, m] -> sc, JacobiCS[z, m] -> cs,\n       \
EllipticE[JacobiAmplitude[z, m], m] -> EA,\n       \
EllipticF[JacobiAmplitude[z, m], m] -> z} /.\n     ",
  StyleBox["(* use only sn, cn, and dn *)   ", "CodeComment"],
  "\n     {cd -> cn/dn, dc -> dn/cn, ns -> 1/sn, sd -> sn/dn, nc -> 1/cn,  \n \
     ds -> dn/sn, nd -> 1/dn,  sc -> sn/cn, cs -> cn/sn}"
}], "Input"],

Cell[TextData[{
  "We eliminate ",
  StyleBox["EA", "MR"],
  "=",
  Cell[BoxData[
      FormBox[
        RowBox[{"E", "(", 
          RowBox[{
            RowBox[{"am", "(", 
              RowBox[{"z", "\[VerticalSeparator]", "m"}], ")"}], 
            "\[VerticalSeparator]", "m"}], ")"}], TraditionalForm]]],
  " and obtain the following expression."
}], "Text"],

Cell["\<\
eqs2 = Factor[Numerator[Together[eqs1[[2]] /. Solve[eqs1[[1]] == 0, \
EA][[1]]]]]\
\>", "Input"],

Cell[TextData[{
  "Ignoring the irrelevant factors ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "-", "1"}], TraditionalForm]]],
  ", we arrive at the following expression containing the a square root. By \
squaring, we eliminate this square root."
}], "Text"],

Cell["\<\
(eqs3 = Factor[((eqs2[[-1]] + #)^2 - #^2)&[
               2 cn^2 dn^3 Sqrt[1 - m sn^2] d[1]]]) // Short[#, 4]&\
\>", \
"Input"],

Cell[TextData[{
  "The remaining expression contains the three Jacobi functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"dn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " polynomially. We use the two fundamental quadratic relations between the \
three functions to eliminate ",
  Cell[BoxData[
      FormBox[
        RowBox[{"cn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"dn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["Variables[eqs3]", "Input"],

Cell["\<\
(eqs4 = Expand[eqs3 /. {cn -> Sqrt[1 - sn^2], 
                        dn -> Sqrt[1 - m sn^2]}]) // Short[#, 4]&\
\>", \
"Input"],

Cell[TextData[{
  "Squaring one more time to eliminate the square roots yields a product of \
two polynomials in the Jacobi function ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " and its derivatives."
}], "Text"],

Cell["\<\
(eqs5 = Factor[Expand[((eqs4 - #)^2 - #^2)&[Plus @@
               Cases[eqs4, __ Power[_, 1/2]]]]]) // Short[#, 4]&\
\>", "Input"],

Cell["\<\
A quick numerical check shows that the first factor contains the \
differential equation we were looking for.\
\>", "Text"],

Cell["\<\
eqs6 = (List @@ eqs5) /. {sn -> w[m], d[j_] :> \
Derivative[j][w][m]};\
\>", "Input"],

Cell["\<\
eqs6 /. w -> (JacobiSN[z, #]&) /. {z -> 1/Pi, m -> 1/E} // N[#, \
100]&\
\>", "Input"],

Cell["Here is the resulting differential equation. ", "Text"],

Cell["\<\
Collect[eqs6[[1]], {w''[m], w'[m]}, Factor] // \
TraditionalForm\
\>", "Input"],

Cell[TextData[{
  "Because the differential equation in quadratic in the second derivative, \
we could differentiate it with respect to ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " and obtain a differential equation linear in the highest derivative. Such \
a differential equation allows for an easy numerical solution (no choice of \
the branch of a root has to be made). The function ",
  Cell[BoxData[
      FormBox[
        RowBox[{"sn", "(", 
          RowBox[{"z", "|", "m"}], ")"}], TraditionalForm]]],
  " is a meromorphic function of ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  " for any ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "Walker03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Walker03",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  5.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Zeta Sums"
}], "ExerciseHeading"],

Cell[TextData[{
  "Consider the sums ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["c", "k"], "=", 
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"j", "=", "0"}], "k"], 
            RowBox[{
              StyleBox[
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{"-", "1"}], ")"}], "j"],
                GridBoxOptions->{RowSpacings->0}], 
              StyleBox[" ",
                GridBoxOptions->{RowSpacings->0}], 
              RowBox[{
                StyleBox[
                  TagBox[
                    RowBox[{"(", GridBox[{
                          {
                            TagBox["k",
                              Identity,
                              Editable->True]},
                          {
                            TagBox["j",
                              Identity,
                              Editable->True]}
                          }], ")"}],
                    InterpretTemplate[ Binomial[ #, #2]&],
                    Editable->False],
                  GridBoxOptions->{RowSpacings->0}], "/", 
                TagBox[
                  RowBox[{"\[Zeta]", "(", 
                    TagBox[
                      RowBox[{
                        RowBox[{"2", " ", "j"}], "+", "2"}],
                      Zeta,
                      Editable->True], ")"}],
                  InterpretTemplate[ 
                    Function[ BoxForm`e$, 
                      Zeta[ BoxForm`e$]]]]}]}]}]}], TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "BaezDuarte03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"BaezDuarte03",
    ButtonStyle->"Hyperlink"],
  "]",
  ". Visualize the dependence of ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " on ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"0", "\[LessEqual]", "k", "\[LessEqual]", 
          SuperscriptBox["10", "4"]}], TraditionalForm]]],
  ". Assuming ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            SubscriptBox["c", "k"], "\[RightBracketingBar]"}], "\[Tilde]", 
          SuperscriptBox["k", "\[Alpha]"]}], TraditionalForm]]],
  ", what is an approximate value for ",
  Cell[BoxData[
      FormBox["\[Alpha]", TraditionalForm]]],
  "?"
}], "Text"],

Cell[CellGroupData[{

Cell["Here is a straightforward definition of the sums.", "SolutionSubgroup"],

Cell["c[k_] := Sum[(-1)^j Binomial[k, j]/Zeta[2j + 2], {j, 0, k}]", "Input"],

Cell[TextData[{
  "While for small ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  " , this straightforward definition works, for larger ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  ", it becomes exponentially slower. We observe that the results are of the \
order ",
  Cell[BoxData[
      FormBox[
        RowBox[{"-", 
          SuperscriptBox["10", 
            RowBox[{"-", 
              StyleBox["smallInteger",
                "TI"]}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
$MaxExtraPrecision = 10^5;
dataT = {#, Timing[N[c[#], 20]]}& /@ {10, 50, 100, 200, 500, 1000, \
2000}\
\>", "Input"],

Cell[TextData[{
  "So we have to implement an alternative way to get a numerical value for ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "\[TildeTilde]", 
          SuperscriptBox["10", "4"]}], TraditionalForm]]],
  ". Let us look at the size of the largest integers occurring in the exact \
calculations. The largest binomial coefficients has about 3000 digits for ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"k", "=", 
            SuperscriptBox["10", "4"]}], ",", " "}], TraditionalForm]]],
  "but already for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "=", "2000"}], TraditionalForm]]],
  ", the denominator of the zeta function has more than 5100 digits. This \
suggests using high\[Hyphen]precision floating point numbers instead of exact \
arithmetic in the following."
}], "Text"],

Cell["{Binomial[10000, 5000], Denominator[Zeta[2000]]} // N", "Input"],

Cell[TextData[{
  "Next, we observe that ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Zeta]", "(", 
          RowBox[{"2", "n"}], ")"}], TraditionalForm]]],
  " approaches 1 exponentially fast for large ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  ". By observing that ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"j", "=", "0"}], "k"], 
            StyleBox[
              RowBox[{
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{"-", "1"}], ")"}], "j"], " ", 
                TagBox[
                  RowBox[{"(", GridBox[{
                        {
                          TagBox["k",
                            Identity,
                            Editable->True]},
                        {
                          TagBox["j",
                            Identity,
                            Editable->True]}
                        }], ")"}],
                  InterpretTemplate[ Binomial[ #, #2]&],
                  Editable->False]}],
              GridBoxOptions->{RowSpacings->0}]}], "=", "0"}], 
        TraditionalForm]]],
  ", we subtract this sum to obtain summands of the form",
  StyleBox[" largeBinomial\[Times]smallZeta", "TI"],
  ", which gives much smaller values than the original small. The following \
graphic shows sizes of the ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "+", "1"}], TraditionalForm]]],
  " summands for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "=", "500"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "=", "1000"}], TraditionalForm]]],
  ". The size of the summands vary over many hundred orders of magnitude to \
give a small final result. Approximately the first ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "/", "2"}], TraditionalForm]]],
  " terms contribute significantly to the final result."
}], "Text"],

Cell["\<\
Show[Graphics[
{Hue[#1], Table[Point[{j, Log[10, Abs[N[(-1)^j Binomial[#2, j]*
                (1/Zeta[2j + 2] - 1), 20]]]}], {j, 0, #2}]}& @@@
 {{0, 500}, {0.8, 1000}}], PlotRange -> All, Axes -> True]\
\>", "Input"],

Cell[TextData[{
  "Now, let us implement two further computational optimizations. For a given \
",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  ", we have to generate all binomial coefficients. While this could be, of \
course, done with ",
  Cell[BoxData[
      FormBox[
        RowBox[{"k", "+", "1"}], TraditionalForm]]],
  " calls to ",
  StyleBox["Binomial", "MR"],
  ", a recursive calculation of the binomial coefficients is hundreds of \
times faster for larger ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  StyleBox["(* list of all k + 1 binomial coefficients Binomial[k, j], j, 0, \
1, \[Ellipsis], k *)", "CodeComment"],
  "\nbinomialList[k_] := FoldList[Times, 1, (k - Range[0, k - 1])/(1 + \
Range[0, k - 1])]"
}], "Input"],

Cell["\<\
{Table[Binomial[10000, k], {k, 0, 10000}]; // Timing,
 binomialList[10000]; // Timing}\
\>", "Input"],

Cell[TextData[{
  "The second computational optimization refers to the zeta function values. \
Because the zeta function term in the definition of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " is independent of ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  ", we can once and for all calculate a list of zeta function values and \
reuse parts of it for a given ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  ". So, we calculate the following list of zeta function values ",
  StyleBox["zetaList", "MR"],
  ". We also include the factor ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{"(", 
            RowBox[{"-", "1"}], ")"}], "j"], TraditionalForm]]],
  " and calculate the function values to a precision depending on the size of \
the largest binomial coefficient with which they will be later multiplied. \
The following calculation is needed one time and will take a few minutes."
}], "Text"],

Cell[TextData[{
  "BL = binomialList[10001] // N;\n\n(zetaList = Table[(-1)^j (1/Zeta[N[2j + \
2, ",
  StyleBox["(* use adaptive precision *)", "CodeComment"],
  "\n                         Max[Ceiling[Log[10, BL[[j + 1]]] + 300], 7/10 \
j]]] - 1), \n                  {j, 10000, 0, -1}] // Reverse;) // Timing"
}], "Input"],

Cell[TextData[{
  "So, we end with the following optimized definition for the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ". "
}], "Text"],

Cell["cF[k_] := binomialList[k].Take[zetaList, k + 1]", "Input"],

Cell[TextData[{
  "Here is a quick check showing that ",
  StyleBox["c[", "MR"],
  StyleBox["k", "TI"],
  StyleBox["]", "MR"],
  " and ",
  StyleBox["cF[", "MR"],
  StyleBox["k", "TI"],
  StyleBox["]", "MR"],
  " give identical results."
}], "Text"],

Cell["(cF[#]/c[#] - 1)& /@ {10, 100, 1000}", "Input"],

Cell[TextData[{
  StyleBox["cF", "MR"],
  " is much faster ",
  StyleBox["c", "MR"],
  " and we can calculate ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "10000"], TraditionalForm]]],
  " in a few seconds."
}], "Text"],

Cell["{cF[1000] // Timing // N, cF[10000] // Timing // N}", "Input"],

Cell[TextData[{
  "Next, we calculate a larger set of values of the ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " and visualize the logarithm of their absolute value."
}], "Text"],

Cell["\<\
tab = Table[C6 = Timing[{k, cF[k]}]; C6[[2]], {k, 10000, 0, -100}];\
\
\>", "Input"],

Cell["\<\
ListPlot[Log @ Drop[Abs[tab], -1], PlotRange -> All,
         AxesLabel -> {Log[k], Log[Subscript[c, k]]}]\
\>", "Input"],

Cell[TextData[{
  "Modulo some small oscillations visible for larger ",
  Cell[BoxData[
      FormBox["k", TraditionalForm]]],
  ", we see a dependence of the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["c", "k"], "\[Tilde]", 
          SuperscriptBox["k", "\[Alpha]"]}], TraditionalForm]]],
  ". Fitting the data points to such a curve yields ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Alpha]", "\[TildeTilde]", 
          RowBox[{"-", "2"}]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["Fit[Select[Log @ Abs[tab], #[[1]] > 5&], {1, x}, x] // N", "Input"],

Cell[TextData[{
  "Here are the resulting more pronounced oscillations of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["c", "k"], "/", 
          SuperscriptBox["k", 
            RowBox[{"-", "2"}]]}], TraditionalForm]]],
  "."
}], "Text"],

Cell["ListPlot[{#1, #2 #1^2}& @@@ Abs[tab], PlotRange -> All]", "Input"],

Cell[TextData[{
  "Interestingly, the condition ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[LeftBracketingBar]", 
            SubscriptBox["c", "k"], "\[RightBracketingBar]"}], "\[LessLess]", 
          
          SuperscriptBox["k", 
            RowBox[{
              RowBox[{
                RowBox[{"-", "3"}], "/", "4"}], "+", "\[CurlyEpsilon]"}]]}], 
        TraditionalForm]]],
  " is equivalent to the Riemann hypothesis ",
  "[",
  
  CounterBox["BibliographyCounter", "BaezDuarte03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"BaezDuarte03",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  6.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Harmonic Numbers Inversion"
}], "ExerciseHeading"],

Cell[TextData[{
  "Find a high\[Hyphen]order series approximation for the solution of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{
            UnderoverscriptBox["\[Sum]", 
              RowBox[{"k", "=", "1"}], "n"], 
            RowBox[{"1", "/", "k"}]}], "=", "m"}], TraditionalForm]]],
  " for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", 
          RowBox[{"n", "(", "m", ")"}]}], TraditionalForm]]],
  " for large ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "We obtain an zeroth order solution by summing the harmonic series and \
expanding it around ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "=", "\[Infinity]"}], TraditionalForm]]],
  " ",
  "[",
  
  CounterBox["BibliographyCounter", "Zeyman85"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Zeyman85",
    ButtonStyle->"Hyperlink"],
  "]",
  "."
}], "SolutionSubgroup"],

Cell["\<\
Normal[Series[FunctionExpand[HarmonicNumber[n]], 
       {n, Infinity, 0}]] // Solve[# == m, n]&\
\>", "Input"],

Cell["\<\
A first order solution will contain the product log function.\
\>", \
"Text"],

Cell["\<\
Normal[Series[FunctionExpand[HarmonicNumber[n]], 
       {n, Infinity, 1}]] // Solve[# == m, n]&\
\>", "Input"],

Cell[TextData[{
  "To obtain a high order series solution, we look for a Laurent series in ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "=", 
          RowBox[{"exp", "(", 
            RowBox[{"m", "-", "\[Gamma]"}], ")"}]}], TraditionalForm]]],
  ". The series must have the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"n", "\[Proportional]", 
          RowBox[{"\[CurlyEpsilon]", "-", 
            RowBox[{"1", "/", "2"}], "+", 
            RowBox[{
              SubscriptBox["c", "1"], "/", "\[CurlyEpsilon]"}], "+", 
            RowBox[{
              SubscriptBox["c", "2"], "/", 
              SuperscriptBox["\[CurlyEpsilon]", "2"]}], "+", 
            "\[Ellipsis]"}]}], TraditionalForm]]],
  ". It is straightforward to calculate the first 100 ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  " recursively."
}], "Text"],

Cell[TextData[{
  "Module[{k = 0, nS = \[CurlyEpsilon] - 1/2, \[Delta]nS, \[CurlyEpsilon]nS, \
c, sol, o = 100},\n Do[k++; \n    ",
  StyleBox["(* add new series term *)", "CodeComment"],
  "\n    \[Delta]nS = Normal[Series[EulerGamma + 1/n + PolyGamma[0, n], \n    \
            {n, Infinity, 2}]] /.  n -> nS + c[k]/\[CurlyEpsilon]^k;\n    ",
  StyleBox["(* calculate series *)", "CodeComment"],
  "\n    \[CurlyEpsilon]nS = Series[\[Delta]nS, {\[CurlyEpsilon], Infinity, k \
+ 1}] - (EulerGamma - Log[1/\[CurlyEpsilon]]);\n    ",
  StyleBox["(* cancel series term *)", "CodeComment"],
  "\n    coeff = Coefficient[Normal[\[CurlyEpsilon]nS], \[CurlyEpsilon], -(k \
+ 1)];\n    sol = Solve[coeff == 0, c[k]];\n    nS = nS + \
c[k]/\[CurlyEpsilon]^k /. sol[[1]], {o}];\n    ",
  StyleBox["(* resulting series *)", "CodeComment"],
  "\n    n\[ScriptCapitalS][\[CurlyEpsilon]_] = nS];"
}], "Input"],

Cell["Here are some of the terms of the resulting series.", "Text"],

Cell["n\[ScriptCapitalS][\[CurlyEpsilon]] // Take[#, -16]&", "Input"],

Cell[TextData[{
  "The left graphic shows the size of the coefficients of the series in ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  ". The right graphic shows the values of the series for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"m", "=", "1"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
maxExp = Max[-Last /@ Cases[n\[ScriptCapitalS][\[CurlyEpsilon]], \
\[CurlyEpsilon]^_, Infinity]];
n\[ScriptCapitalS]List[\[CurlyEpsilon]_] = MapIndexed[#1 \[CurlyEpsilon]^(2 - \
#2[[1]])&, 
                Reverse[CoefficientList[\[CurlyEpsilon]^maxExp #& /@ n\
\[ScriptCapitalS][\[CurlyEpsilon]], \[CurlyEpsilon]]]];\
\>", "Input"],

Cell[TextData[{
  "Off[Graphics::gptn];\nShow[GraphicsArray[\nBlock[{$DisplayFunction = \
Identity},\n      ",
  StyleBox["(* show base 10 logarithm *)", "CodeComment"],
  "\n      {ListPlot[Log[10, Abs[n\[ScriptCapitalS]List[\[CurlyEpsilon]] /. \
\[CurlyEpsilon] -> 1 // N]]],\n       ListPlot[Log[10, \
Abs[n\[ScriptCapitalS]List[\[CurlyEpsilon]] /. (\[CurlyEpsilon] -> Exp[m - \
EulerGamma] /. \n                                                 m -> N[1, \
20])]]]}]]]"
}], "Input"],

Cell[TextData[{
  "The difference ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["H", 
            RowBox[{"n", "(", "m", ")"}]], "-", "m"}], TraditionalForm]]],
  " shows the quality of the series. Due to the argument ",
  Cell[BoxData[
      FormBox[
        RowBox[{"exp", "(", 
          RowBox[{"m", "-", "\[Gamma]"}], ")"}], TraditionalForm]]],
  ", the quality increases exponentially with ",
  Cell[BoxData[
      FormBox["m", TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
\[Delta]m[m_] := HarmonicNumber[Plus @@ \
n\[ScriptCapitalS]List[Exp[m - EulerGamma]]] - m\
\>", "Input"],

Cell["\<\
$MaxExtraPrecision = 100;
ListPlot[Table[{m, Log[10, Abs[\[Delta]m[m] // N[#, 20]&]]}, {m, 36}]]\
\>", \
"Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  7.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L1"], TraditionalForm]]],
  " Sliding coin"
}], "ExerciseHeading"],

Cell[TextData[{
  "The equations of motion for a flat spinning disk sliding on a plane \
surface including friction can be written, after an appropriate scaling of \
variables, in the following form [",
  
  CounterBox["BibliographyCounter", "Farkas03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Farkas03",
    ButtonStyle->"Hyperlink"],
  "], [",
  
  CounterBox["BibliographyCounter", "Malhotra02"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Malhotra02",
    ButtonStyle->"Hyperlink"],
  "]:"
}], "Text",
  CellTags->{
  "T[D[Sliding Spinning Disk]]", "Index[14, {disk, spinning and sliding ~}]"}],\


Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          OverscriptBox["\[ScriptX]", ".."], "(", "\[Tau]", ")"}], "=", 
        RowBox[{"{", GridBox[{
              {
                RowBox[{
                  StyleBox[
                    FractionBox[
                      RowBox[{"4", " "}], 
                      RowBox[{"3", " ", "\[Pi]", " ", 
                        RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}]}]],
                    ScriptLevel->0], 
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            SuperscriptBox[
                              RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}],
                               "2"], "+", "1"}], ")"}], " ", 
                        RowBox[{"E", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            "2"], ")"}]}], "+", 
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            SuperscriptBox["\[CurlyEpsilon]", "2"], "-", 
                            "1"}], ")"}], " ", 
                        RowBox[{"K", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            "2"], ")"}]}]}], ")"}]}], 
                RowBox[{
                  RowBox[{"if", " ", 
                    RowBox[{"\[LeftBracketingBar]", 
                      RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                      "\[RightBracketingBar]"}]}], "\[LessEqual]", "1"}]},
              {
                RowBox[{
                  StyleBox[
                    FractionBox[
                      RowBox[{"4", " ", 
                        RowBox[{"sgn", "(", 
                          RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                          ")"}]}], 
                      RowBox[{"3", " ", "\[Pi]"}]],
                    ScriptLevel->0], "  ", 
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            SuperscriptBox[
                              RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}],
                               "2"], "+", "1"}], ")"}], " ", 
                        RowBox[{"E", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            RowBox[{"-", "2"}]], ")"}]}], "-", 
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            SuperscriptBox[
                              RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}],
                               "2"], "-", "1"}], ")"}], " ", 
                        RowBox[{"K", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            RowBox[{"-", "2"}]], ")"}]}]}], ")"}]}], 
                RowBox[{
                  RowBox[{"if", " ", 
                    RowBox[{"\[LeftBracketingBar]", 
                      RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                      "\[RightBracketingBar]"}]}], "\[GreaterEqual]", "1"}]}
              }]}]}], TraditionalForm]], "DisplayFormula",
  AutoStyleOptions->{"UnmatchedBracketStyle"->None}],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          OverscriptBox["\[CurlyPhi]", ".."], "(", "\[Tau]", ")"}], "=", 
        RowBox[{"{", GridBox[{
              {
                RowBox[{
                  StyleBox[
                    FractionBox["4", 
                      RowBox[{"9", " ", "\[Pi]"}]],
                    ScriptLevel->0], " ", 
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{"4", "-", 
                            RowBox[{"2", " ", 
                              SuperscriptBox[
                                RowBox[{
                                "\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                                "2"]}]}], ")"}], " ", 
                        RowBox[{"E", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            "2"], ")"}]}], "+", 
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            SuperscriptBox[
                              RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}],
                               "2"], "-", "1"}], ")"}], " ", 
                        RowBox[{"K", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            "2"], ")"}]}]}], ")"}]}], 
                RowBox[{
                  RowBox[{"if", " ", 
                    RowBox[{"\[LeftBracketingBar]", 
                      RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                      "\[RightBracketingBar]"}]}], "\[LessEqual]", "1"}]},
              {
                RowBox[{
                  StyleBox[
                    FractionBox[
                      RowBox[{"4", " ", 
                        RowBox[{"sgn", "(", 
                          RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                          ")"}]}], 
                      RowBox[{"9", "\[Pi]", " ", 
                        RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}]}]],
                    ScriptLevel->0], " ", 
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            RowBox[{"4", " ", 
                              SuperscriptBox[
                                RowBox[{
                                "\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                                "2"]}], "-", 
                            RowBox[{"2", " ", 
                              SuperscriptBox[
                                RowBox[{
                                "\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                                "4"]}]}], ")"}], " ", 
                        RowBox[{"E", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            RowBox[{"-", "2"}]], ")"}]}], "+", 
                      RowBox[{
                        RowBox[{"(", 
                          RowBox[{
                            RowBox[{"2", " ", 
                              SuperscriptBox[
                                RowBox[{
                                "\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                                "4"]}], "-", 
                            RowBox[{"5", " ", 
                              SuperscriptBox[
                                RowBox[{
                                "\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                                "2"]}], "+", "3"}], ")"}], " ", 
                        RowBox[{"K", "(", 
                          SuperscriptBox[
                            RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                            RowBox[{"-", "2"}]], ")"}]}]}], ")"}]}], 
                RowBox[{
                  RowBox[{"if", " ", 
                    RowBox[{"\[LeftBracketingBar]", 
                      RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], 
                      "\[RightBracketingBar]"}]}], "\[GreaterEqual]", "1"}]}
              }]}]}], TraditionalForm]], "DisplayFormula",
  AutoStyleOptions->{"UnmatchedBracketStyle"->None}],

Cell[TextData[{
  "Here ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[ScriptX]", "(", "\[Tau]", ")"}], TraditionalForm]]],
  " is the position of the disk along its direction of motion, and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyPhi]", "(", "\[Tau]", ")"}], TraditionalForm]]],
  " is the angle of the disk with respect to its center. The friction induces \
a complicated coupling between the translational and the rotational movement \
characterized by the quantity ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[CurlyEpsilon]", "(", "\[Tau]", ")"}], "=", 
          RowBox[{
            RowBox[{
              OverscriptBox["\[ScriptX]", "."], "(", "\[Tau]", ")"}], "/", 
            RowBox[{
              OverscriptBox["\[CurlyPhi]", "."], "(", "\[Tau]", ")"}]}]}], 
        TraditionalForm]]],
  ". ",
  Cell[BoxData[
      FormBox[
        RowBox[{"E", "(", "z", ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"K", "(", "z", ")"}], TraditionalForm]]],
  " are the complete elliptic integrals. For a fixed initial velocity ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[ScriptV]", "(", "0", ")"}], "=", 
          RowBox[{
            OverscriptBox["x", "."], "(", "0", ")"}]}], TraditionalForm]]],
  " and various initial angular velocities ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[Omega]", "(", "0", ")"}], "=", 
          RowBox[{
            OverscriptBox["\[CurlyPhi]", "."], "(", "0", ")"}]}], 
        TraditionalForm]]],
  ", solve the equations of motion numerically. Does a disk that initially \
rotates move faster than one that does not rotate initially?"
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "Here are the expressions for the force and the torque. We use the explicit \
limit values as ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "\[Rule]", "0"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[CurlyEpsilon]", "\[Rule]", "1"}], TraditionalForm]]],
  " to avoid nonnumerical results."
}], "SolutionSubgroup"],

Cell[TextData[{
  "\[ScriptCapitalF][\[CurlyEpsilon]_] = \nWhich[\[CurlyEpsilon] == 1, 8/(3 \
Pi), ",
  StyleBox["(* no rotation *) ", "CodeComment"],
  "\[CurlyEpsilon] === ComplexInfinity, 1, \nAbs[\[CurlyEpsilon]] < 1,  \n4/3 \
((\[CurlyEpsilon]^2 + 1) EllipticE[\[CurlyEpsilon]^2] + (\[CurlyEpsilon]^2 - \
1) EllipticK[\[CurlyEpsilon]^2])/(Pi \[CurlyEpsilon]),\nAbs[\[CurlyEpsilon]] \
> 1,\n4/3 Sign[\[CurlyEpsilon]] ((\[CurlyEpsilon]^2 + 1) EllipticE[1/\
\[CurlyEpsilon]^2] - (\[CurlyEpsilon]^2 - 1) \
EllipticK[1/\[CurlyEpsilon]^2])/(Pi)];"
}], "Input"],

Cell[TextData[{
  "\[ScriptCapitalT][\[CurlyEpsilon]_] = \nWhich[\[CurlyEpsilon] == 1, 8/(9 \
Pi), ",
  StyleBox["(* no rotation *) ", "CodeComment"],
  "\[CurlyEpsilon] === ComplexInfinity, 0, \nAbs[\[CurlyEpsilon]] < 1, \n4/9 \
((4 - 2 \[CurlyEpsilon]^2) EllipticE[\[CurlyEpsilon]^2] + (\[CurlyEpsilon]^2 \
- 1) EllipticK[\[CurlyEpsilon]^2])/Pi,\nAbs[\[CurlyEpsilon]] > 1,\n4/9 Sign[\
\[CurlyEpsilon]] ((4 \[CurlyEpsilon]^2 - 2 \[CurlyEpsilon]^4) EllipticE[1/\
\[CurlyEpsilon]^2] + \n     (2\[CurlyEpsilon]^4 - 5\[CurlyEpsilon]^2 + 3) \
EllipticK[1/\[CurlyEpsilon]^2])/(Pi \[CurlyEpsilon])];"
}], "Input"],

Cell[TextData[{
  "Here are the force and the torque as a function of ",
  Cell[BoxData[
      FormBox["\[CurlyEpsilon]", TraditionalForm]]],
  ". For increasing angular velocity, the force is decreasing and the torque \
is increasing."
}], "Text"],

Cell["\<\
Show[GraphicsArray[
Plot[#[\[CurlyEpsilon]], {\[CurlyEpsilon], 0, 4}, DisplayFunction -> \
Identity,
     Frame -> True, Axes -> False, PlotRange -> All]& /@ {\[ScriptCapitalF], \
\[ScriptCapitalT]}]];\
\>", "Input"],

Cell[TextData[{
  "Solving the equations of motions and visualizing the results is \
straightforward. We use ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"\[ScriptV]", "(", "0", ")"}], "=", "2"}], 
        TraditionalForm]]],
  " and integrate the equations as long as ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          OverscriptBox["x", "."], "(", "\[Tau]", ")"}], TraditionalForm]]],
  " is positive. The left graphic shows the positions and the angles (as \
dashed lines) for four initial angular velocities. The right graphic shows \
the positions and the velocity and the angular velocity (as dashed lines) for \
the same four initial angular velocities. The graphics show clearly that a \
spinning disk moves further. They also show that the translational motion and \
the rotational motion stop at the same moment, meaning the disk cannot end \
its translational motion first and just spin or end spinning before ending \
its translational motion [",
  
  CounterBox["BibliographyCounter", "Farkas03"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Farkas03",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "Module[{\[ScriptV]0 = 2, ndsol, \[CapitalTau] = 4}, \n\
Show[GraphicsArray[Show /@ Transpose[ Function[{\[Omega]0, color},\n",
  StyleBox["(* solve differential equations *)", "CodeComment"],
  "\nndsol = NDSolve[{\[ScriptX]'[\[Tau]] == \[ScriptV][\[Tau]], \
\[CurlyPhi]'[\[Tau]] == \[Omega][\[Tau]], \n                 \[ScriptV]'[\
\[Tau]] == -\[ScriptCapitalF][\[ScriptV][\[Tau]]/\[Omega][\[Tau]]], \
\[Omega]'[\[Tau]] == -2 \
\[ScriptCapitalT][\[ScriptV][\[Tau]]/\[Omega][\[Tau]]],\n                 \
\[ScriptX][0] == 0, \[ScriptV][0] == \[ScriptV]0, \[CurlyPhi][0] == 0, \
\[Omega][0] == \[Omega]0},\n                {\[ScriptX], \[ScriptV], \
\[CurlyPhi], \[Omega]}, {\[Tau], 0, \[CapitalTau]}, StoppingTest -> \
\[ScriptV][\[Tau]] < 0];\n\[CapitalTau]1 = ndsol[[1, 1, 2, 1, 1, 2]];\n\
(Plot[Evaluate[{#1[\[Tau]], #2[\[Tau]]} /. ndsol[[1]]], {\[Tau], 0, \
\[CapitalTau]1},\n     PlotStyle -> {{color, Thickness[0.002]},\n             \
      {color, Thickness[0.002], Dashing[{0.02, 0.02}]}},\n     \
DisplayFunction -> Identity, AxesLabel -> {\[Tau], {#1, #2}}]& @@@ \n     ",
  StyleBox["(* show \[ScriptX], \[ScriptV], and \[CurlyPhi], \[Omega] *)", 
    "CodeComment"],
  " {{\[ScriptX], \[CurlyPhi]}, {\[ScriptV], \[Omega]}})] @@@\n  ",
  StyleBox["(* various initial velocities *)", "CodeComment"],
  "\n  {{0.010, Hue[0.00]}, {0.500, Hue[0.12]}, \n   {1.000, Hue[0.22]}, \
{3.000, Hue[0.78]}}]]]]"
}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "  8.",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["\[InvisibleSpace]", "L2"], TraditionalForm]]],
  " Theta Function Identities"
}], "ExerciseHeading"],

Cell[TextData[{
  "The elliptic theta functions ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "a"], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  " obey many identities. For explicit values of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ", typical examples are:"
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox["\[Pi]", "4"], ",", "q"}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "4"], "(", 
            RowBox[{"0", ",", 
              SuperscriptBox["q", "4"]}], ")"}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"2", " ", 
            RowBox[{
              SuperscriptBox[
                SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                MultilineFunction->None], "(", 
              RowBox[{"0", ",", 
                SuperscriptBox["q", "4"]}], ")"}]}], "+", 
          RowBox[{
            SuperscriptBox[
              SubscriptBox["\[CurlyTheta]", "3"], "\[Prime]",
              MultilineFunction->None], "(", 
            RowBox[{
              FractionBox["\[Pi]", "4"], ",", "q"}], ")"}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}]}], "+", 
          RowBox[{"2", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", 
                SuperscriptBox["q", "2"]}], ")"}], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                FractionBox["\[Pi]", "4"], ",", 
                SuperscriptBox["q", "2"]}], ")"}]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"2", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", 
                SuperscriptBox["q", "2"]}], ")"}], " ", 
            RowBox[{
              SuperscriptBox[
                SubscriptBox["\[CurlyTheta]", "3"], "\[Prime]",
                MultilineFunction->None], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}]}], "-", 
          RowBox[{
            SqrtBox["2"], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}], "3"]}]}], 
        "=", "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SqrtBox["2"], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}]}], "-", 
          RowBox[{"2", " ", 
            RowBox[{
              SuperscriptBox[
                SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                MultilineFunction->None], "(", 
              RowBox[{"0", ",", 
                SuperscriptBox["q", "2"]}], ")"}]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SqrtBox["2"], " ", 
            RowBox[{"(", 
              RowBox[{
                SuperscriptBox[
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "1"], "(", 
                    RowBox[{
                      RowBox[{"-", 
                        FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], "2"], 
                "+", 
                RowBox[{"2", " ", 
                  SuperscriptBox[
                    RowBox[{
                      SubscriptBox["\[CurlyTheta]", "1"], "(", 
                      RowBox[{
                        RowBox[{"-", 
                          FractionBox["\[Pi]", "4"]}], ",", "q"}], ")"}], 
                    "2"]}]}], ")"}], " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "4"]}], ",", 
                SuperscriptBox["q", "2"]}], ")"}]}], "-", 
          RowBox[{"2", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", 
                SuperscriptBox["q", "4"]}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{"(", 
                RowBox[{
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "3"], "(", 
                    RowBox[{
                      FractionBox["\[Pi]", "8"], ",", "q"}], ")"}], "+", 
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "4"], "(", 
                    RowBox[{
                      FractionBox["\[Pi]", "8"], ",", "q"}], ")"}]}], ")"}], 
              "2"]}]}], "=", "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            RowBox[{
              SuperscriptBox[
                SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                MultilineFunction->None], "(", 
              RowBox[{"0", ",", "q"}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  FractionBox["\[Pi]", "3"], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"]}], "+", 
          RowBox[{
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  FractionBox["\[Pi]", "3"], ",", "q"}], ")"}], "2"], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  FractionBox["\[Pi]", "6"], ",", "q"}], ")"}], "2"]}]}], "=",
         "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "4"]}], 
          "-", 
          RowBox[{"9", " ", 
            SuperscriptBox[
              RowBox[{
                SuperscriptBox[
                  SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                  MultilineFunction->None], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", 
                  SuperscriptBox["q", "4"]}], ")"}], "2"]}], "+", 
          RowBox[{"9", " ", 
            SuperscriptBox[
              RowBox[{
                SuperscriptBox[
                  SubscriptBox["\[CurlyTheta]", "3"], "\[Prime]",
                  MultilineFunction->None], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", 
                  SuperscriptBox["q", "4"]}], ")"}], "2"]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "2"], " ",
             
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], "6"]}], 
          "+", 
          RowBox[{"8", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "2"], " ",
             
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "6"]}], 
          "+", 
          RowBox[{"8", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "6"], " ",
             
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "2"]}], 
          "-", 
          RowBox[{"144", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"], " ", 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox[
                  TagBox["\[CurlyTheta]",
                    EllipticThetaPrime], "1", "\[Prime]"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"]}]}], "=", "0."}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"20", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "4"], " ",
             
            SuperscriptBox[
              RowBox[{
                SuperscriptBox[
                  SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                  MultilineFunction->None], "(", 
                RowBox[{"0", ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"]}], "-", 
          RowBox[{"3", " ", 
            RowBox[{
              SuperscriptBox[
                SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                MultilineFunction->None], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], "7"]}], 
          "-", 
          RowBox[{"72", " ", 
            SuperscriptBox[
              RowBox[{
                SuperscriptBox[
                  SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                  MultilineFunction->None], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"], " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], "4"]}], 
          "+", 
          RowBox[{"12", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "4"], " ",
             
            SuperscriptBox[
              RowBox[{
                SuperscriptBox[
                  SubscriptBox["\[CurlyTheta]", "1"], "\[Prime]",
                  MultilineFunction->None], "(", 
                RowBox[{"0", ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"]}]}], "=", "0."}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SuperscriptBox[
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "1"], "(", 
              RowBox[{
                RowBox[{"-", 
                  FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "8"], "-", 
          RowBox[{"4", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "2"], " ",
             
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "3"]}], ",", "q"}], ")"}], "6"]}], 
          "+", 
          RowBox[{"3", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "8"]}], 
          "-", 
          RowBox[{"3", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "2"]}], ",", "q"}], ")"}], "6"], " ",
             
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", "q"}], ")"}], "2"]}], 
          "+", 
          RowBox[{"72", " ", 
            SuperscriptBox[
              RowBox[{
                SubscriptBox["\[CurlyTheta]", "1"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"], " ", 
            SuperscriptBox[
              RowBox[{
                SubsuperscriptBox[
                  TagBox["\[CurlyTheta]",
                    EllipticThetaPrime], "1", "\[Prime]"], "(", 
                RowBox[{
                  RowBox[{"-", 
                    FractionBox["\[Pi]", "6"]}], ",", 
                  SuperscriptBox["q", "2"]}], ")"}], "2"]}]}], "=", "0."}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "Write a program that, based on the series expansion of the theta functions \
in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ", searches for (and finds) such identities."
}], "Text"],

Cell[CellGroupData[{

Cell[TextData[{
  "For symbolic ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ", we have the following series expansions for the theta functions. ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "3"], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "4"], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  " are pure power series in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "1"], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "2"], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  " are Puisseux series with fractional exponents that are multiples of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"1", "/", "4"}], TraditionalForm]]],
  ". (The same observation holds for the derivatives with respect to ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ".)"
}], "SolutionSubgroup"],

Cell["\<\
\[Theta] = EllipticTheta;
Table[Series[\[Theta][j, z, q], {q, 0, 20}], {j, 4}]\
\>", "Input"],

Cell[TextData[{
  "For brevity of notation, we will use ",
  Cell[BoxData[
      FormBox["\[CurlyTheta]", TraditionalForm]]],
  " for the theta functions. The two functions ",
  StyleBox["toTypeset", "MR"],
  " and ",
  StyleBox["fromTypeset", "MR"],
  " convert from ",
  StyleBox["\[Theta]", "MR"],
  " (used for inputting the theta functions) to ",
  StyleBox["\[CurlyTheta]", "MR"],
  " (used for formatting the resulting identities)",
  "."
}], "Text"],

Cell["\<\
toTypeset[expr_] := expr //. {\[Theta][a_, z_, q_] :> Subscript[\
\[CurlyTheta], a][z, q], 
                              EllipticThetaPrime[a_, z_, q_] :> 
                                                 Derivative[1][Subscript[\
\[CurlyTheta], a]][z, q]};
                                                 
fromTypeset[expr_] := expr //. {Subscript[\[CurlyTheta], a_][z_, q_] :> \
\[Theta][a, z, q], 
                                Derivative[d_][Subscript[\[CurlyTheta], \
a_]][z_, q_] :> 
                                               Derivative[0, 1, \
0][\[Theta]][a, z, q]};\
\>", "Input"],

Cell["\<\
Generalizing the identities given in the exercise, we will look for \
identities of the form\
\>", "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          UnderoverscriptBox["\[Product]", 
            RowBox[{"j", "=", "1"}], "o"], 
          RowBox[{
            SubscriptBox["c", "j"], "(", 
            RowBox[{
              UnderoverscriptBox["\[Product]", 
                RowBox[{"k", "=", "1"}], 
                SubscriptBox["n", "j"]], 
              RowBox[{
                SuperscriptBox["q", 
                  SubscriptBox["\[Alpha]", 
                    RowBox[{"j", ",", "k"}]]], 
                SuperscriptBox[
                  RowBox[{
                    SubsuperscriptBox["\[CurlyTheta]", 
                      SubscriptBox["a", 
                        RowBox[{"j", ",", "k"}]], 
                      RowBox[{"(", 
                        SubscriptBox["d", 
                          RowBox[{"j", ",", "k"}]], ")"}]], "(", 
                    RowBox[{
                      SubscriptBox["z", 
                        SubscriptBox["", 
                          RowBox[{"j", ",", "k"}]]], ",", 
                      SuperscriptBox["q", 
                        SubscriptBox["\[Beta]", 
                          RowBox[{"j", ",", "k"}]]]}], ")"}], 
                  SubscriptBox["\[Gamma]", 
                    RowBox[{"j", ",", "k"}]]]}]}], ")"}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "with rational ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "k"], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["z", 
          RowBox[{"k", ",", "j"}]], TraditionalForm]]],
  " fractions of ",
  Cell[BoxData[
      FormBox["\[Pi]", TraditionalForm]]],
  ", and positive integers ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Alpha]", 
          RowBox[{"k", ",", "j"}]], TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Beta]", 
          RowBox[{"k", ",", "j"}]], TraditionalForm]]],
  " , ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["\[Gamma]", 
          RowBox[{"k", ",", "j"}]], TraditionalForm]]],
  ", the order of the derivatives is ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["d", 
            RowBox[{"j", ",", "k"}]], "\[Element]", 
          RowBox[{"{", 
            RowBox[{"0", ",", "1"}], "}"}]}], TraditionalForm]]],
  ", and ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["a", 
            RowBox[{"j", ",", "k"}]], "\[Element]", 
          RowBox[{"{", 
            RowBox[{"1", ",", "2", ",", "3", ",", "4"}], "}"}]}], 
        TraditionalForm]]],
  ". We restrict the search to identities containing the theta functions and \
their first derivatives with respect to ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". Derivatives with respect to ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " can be expressed through derivatives with respect to ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " by using the differential equation ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"4", " ", "q", " ", 
            RowBox[{
              RowBox[{"\[PartialD]", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "a"], "(", 
                  RowBox[{"z", ",", "q"}], ")"}]}], "/", 
              RowBox[{"\[PartialD]", "q"}]}]}], "=", 
          RowBox[{
            RowBox[{"-", 
              RowBox[{
                SuperscriptBox["\[PartialD]", "2"], 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "a"], "(", 
                  RowBox[{"z", ",", "q"}], ")"}]}]}], "/", 
            RowBox[{"\[PartialD]", 
              SuperscriptBox["z", "2"]}]}]}], TraditionalForm]]],
  ". And higher derivatives with respect to ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " can be reduced to the theta functions and their first derivatives (and \
the single ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]independent term ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[CurlyTheta]", "4", "\[DoublePrime]"], "(", 
          RowBox[{"0", ",", "q"}], ")"}], TraditionalForm]]],
  ") [",
  
  CounterBox["BibliographyCounter", "Baruch10"],
  ButtonBox["\[SixPointedStar]",
    ButtonData:>"Baruch10",
    ButtonStyle->"Hyperlink"],
  "]."
}], "Text"],

Cell[TextData[{
  "To find such identities programmatically, we form series in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " with integer coefficients from the theta functions and their derivatives \
and then try to form linear combinations of products of such series with \
unknown coefficients ",
  Cell[BoxData[
      FormBox[
        SubscriptBox["c", "j"], TraditionalForm]]],
  ". Taking the coefficients of the powers of ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " results in a linear system in the coefficients. Taking enough such linear \
equations, we will obtain overdetermined systems, and we will search for \
nontrivial null spaces. The null spaces will then give the desired \
identities."
}], "Text"],

Cell[TextData[{
  "Because we want series in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " with integer coefficients, but for ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "=", 
          RowBox[{
            RowBox[{"p", "/", "q"}], "\[Times]", " ", "\[Pi]"}]}], 
        TraditionalForm]]],
  " we might obtain overall radical factors for the series, we define a \
function ",
  StyleBox["extractCommonRadicalFactor", "MR"],
  " that extracts common radical factors from a series. (We could, of course, \
in principle use any exact coefficients. But (modular) integer arithmetic is \
much faster than calculations with arbitrary algebraic numbers.)"
}], "Text"],

Cell["\<\
extractCommonRadicalFactor[f_, q_] :=
Module[{ser = Series[f, {q, 0, 40}], fac, rad},
       fac = Factor[PowerExpand[Normal[ser] /. q -> \[ScriptQ]^4]];
       rad = fac /. (r:Power[_?NumericQ, _Rational]) rest__ :> {r};
       f/Which[Head[rad] =!= List || rad === {}, 1,  True, rad[[1]]]]\
\>", \
"Input"],

Cell[TextData[{
  "We will keep our series in the form ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            StyleBox[
              RowBox[{"\[CurlyTheta]", 
                StyleBox["Symbolic",
                  "TI"]}]], ",", 
            StyleBox["explicitSeriesInq",
              "TI"]}], "}"}], TraditionalForm]]],
  ". For a given expression containing theta functions, the command ",
  StyleBox["makeSeriesPair", "MR"],
  " forms such a pair."
}], "Text"],

Cell["\<\
makeSeriesPair[f_] := {toTypeset[#], Series[#, {q, 0, 30}]}& @ 
                                     extractCommonRadicalFactor[f, q]\
\>", \
"Input"],

Cell[TextData[{
  "Now we must decide which fractions of ",
  Cell[BoxData[
      FormBox["\[Pi]", TraditionalForm]]],
  " to take for the ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  "\[Hyphen]values. The function ",
  StyleBox["makeSimpleSeriesTerms", "MR"],
  " form the theta pairs ",
  Cell[BoxData[
      FormBox[
        RowBox[{"{", 
          RowBox[{
            RowBox[{
              SubsuperscriptBox["\[CurlyTheta]", "a", 
                RowBox[{"(", "d", ")"}]], "(", 
              RowBox[{"z", ",", "q"}], ")"}], ",", "\[Ellipsis]"}], "}"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"a", "=", "1"}], ",", "2", ",", "3", ",", "4"}], 
        TraditionalForm]]],
  ", ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          RowBox[{"d", "=", "0"}], ",", "1"}], TraditionalForm]]],
  " for a given ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". "
}], "Text"],

Cell["\<\
makeSimpleSeriesTerms[piFractions_] := 
 DeleteCases[#, {_, _?(Normal[#] === 0&)}]& @ 
     Flatten[Table[makeSeriesPair[Derivative[0, d, 0][\[Theta]][a, #, q]], 
                   {a, 4}, {d, 0, 1}]& /@ piFractions, 2];\
\>", "Input"],

Cell[TextData[{
  "For ",
  Cell[BoxData[
      FormBox[
        RowBox[{"z", "=", 
          RowBox[{"\[Pi]", "/", "8"}]}], TraditionalForm]]],
  ", we cannot extract a simple radical. We form linear combinations of two \
theta functions instead."
}], "Text"],

Cell["\<\
T1 = Join[makeSimpleSeriesTerms[{0, Pi/2, -Pi/2, Pi/4, -Pi/4}],
          makeSeriesPair /@ 
        Join[{\[Theta][3, Pi/8, q] + \[Theta][4, Pi/8, q], \[Theta][3, Pi/8, \
q] - \[Theta][4, Pi/8, q]},
             {\[Theta][3, Pi/8, q] + \[Theta][4, Pi/8, q], \[Theta][3, Pi/8, \
q] - \[Theta][4, Pi/8, q]} /.
                                                \[Theta] -> Derivative[0, 1, \
0][\[Theta]]]];
T1 // TableForm // TraditionalForm                          \
\>", "Input"],

Cell[TextData[{
  "We will not only consider ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubsuperscriptBox["\[CurlyTheta]", "a", 
            RowBox[{"(", "d", ")"}]], "(", 
          RowBox[{"z", ",", "q"}], ")"}], TraditionalForm]]],
  ", but the more general term ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox[
          RowBox[{
            SubsuperscriptBox["\[CurlyTheta]", "a", 
              RowBox[{"(", "d", ")"}]], "(", 
            RowBox[{"z", ",", 
              SuperscriptBox["q", "\[Beta]"]}], ")"}], "\[Gamma]"], 
        TraditionalForm]]],
  ". So, for the current choices of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ", we obtain 96 theta series."
}], "Text"],

Cell[TextData[{
  "makeBaseTerms[T1_] :=  Flatten[Table[Join[First /@ T1, {} ",
  StyleBox["(* First /@ T2 *)", "CodeComment"],
  "] /.\n                                            q -> q^(2^e), {e, 0, \
2}]];\n                                            \n\[CurlyTheta]BaseTerms = \
makeBaseTerms[T1];\nLength[\[CurlyTheta]BaseTerms]"
}], "Input"],

Cell[TextData[{
  "We now calculate the series of the functions ",
  StyleBox["\[CurlyTheta]BaseTerms", "MR"],
  " to order ",
  Cell[BoxData[
      FormBox[
        RowBox[{"O", "(", 
          SuperscriptBox["q", "250"], ")"}], TraditionalForm]]],
  "."
}], "Text"],

Cell["\<\
o = 250;

make\[CurlyTheta]BaseTermsSeries[\[CurlyTheta]BaseTerms_] := DeleteCases[
 {toTypeset[#], ExpandAll @ Series[fromTypeset[#], 
                                   {q, 0, o}]}& /@ \[CurlyTheta]BaseTerms,
                               {_, _?((Normal[#] === 0)&)}];

\[CurlyTheta]BaseTermsSeries = \
make\[CurlyTheta]BaseTermsSeries[\[CurlyTheta]BaseTerms];\
\>", "Input"],

Cell[TextData[{
  "Removing all the series that are simple multiples of each other leads to \
33 different series. The function ",
  StyleBox["identifyIntegerMultiples", "MR"],
  " identities series that are multiples of each other."
}], "Text"],

Cell[TextData[{
  StyleBox["(* pull out a common integer from a series *)", "CodeComment"],
  "\npullOutIntegerFactor[{f_, ser_}] := \nModule[{g = \
Abs[FactorSquareFree[Normal[ser]] /. _Plus :> 1 /. q -> 1]}, \n       If[g == \
0, {f, g}, {f/g, ser/g}]]\n       \n",
  StyleBox["(* make pairs of plus/minus the series *)", "CodeComment"],
  "\nsortedPlusMinusPair[{\[CurlyTheta]_, ser_}] := \nModule[{p = {ser, \
-ser}, pS = Sort[{ser, -ser}]},\n       If[p === pS, {pS, {\[CurlyTheta], -\
\[CurlyTheta]}}, {pS, {-\[CurlyTheta], \[CurlyTheta]}}]]"
}], "Input"],

Cell[TextData[{
  "identifyIntegerMultiples[listOfSeries_] := \nModule[{listOfSeries1, \
listOfSeriesPairs, equivalenceSeries}, \n ",
  StyleBox["(* pull out common integers *)", "CodeComment"],
  "\n listOfSeries1 = pullOutIntegerFactor /@ listOfSeries;\n ",
  StyleBox["(* form \[PlusMinus]1\[Times]series *)", "CodeComment"],
  "\n listOfSeriesPairs = sortedPlusMinusPair /@ listOfSeries1;\n ",
  StyleBox["(* identify equivalent series *)", "CodeComment"],
  "\n equivalenceSeries = Split[Sort[listOfSeriesPairs], #1[[1]] === \
#2[[1]]&];\n ",
  StyleBox["(* return equivalence classes in form {\[CurlyTheta], series} *)",
     "CodeComment"],
  "\n Apply[{#2[[1]], #1[[1]]}&, equivalenceSeries, {2}]]"
}], "Input"],

Cell["\<\
equivalentSeriesList = \
identifyIntegerMultiples[\[CurlyTheta]BaseTermsSeries];
\[CurlyTheta]BaseTermsFinal = First /@ equivalentSeriesList;
Length[\[CurlyTheta]BaseTermsFinal]\
\>", "Input"],

Cell["Here are the form of the resulting 33 series shown.", "Text"],

Cell["\<\
Reverse[First /@ \[CurlyTheta]BaseTermsFinal] // \
TraditionalForm\
\>", "Input"],

Cell["\<\
And here are the tuples of theta functions, representing identical \
series. (For the further calculations, we use only one representative version \
of these series. By substituting the equivalent forms, we could generate more \
identities.)\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* pull out an overall factor from the identities if possible *)",
     "CodeComment"],
  "\noverallFactor[l_] := Factor[Plus @@ l] /. _Plus?(Not[NumericQ[#]]&) :> 1\
\n\n(sIds = Equal @@@ ((#/overallFactor[#])& /@ \n   Map[First, \
Select[equivalentSeriesList, (Length[#] > 1)&], {2}])) //\n                   \
                                     TraditionalForm"
}], "Input"],

Cell["\<\
A quick numerical high\[Hyphen]precision check confirms the last \
result. \
\>", "Text"],

Cell["\<\
Off[N::meprec];
Union[N[Normal[fromTypeset[sIds]] /. q -> 1/2, 22]]
On[N::meprec];\
\>", "Input"],

Cell[TextData[{
  "Some of the series in ",
  StyleBox["\[CurlyTheta]BaseTermsFinal", "MR"],
  " are powers series in ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["q", 
          RowBox[{"1", "/", "4"}]], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        SuperscriptBox["q", 
          RowBox[{"1", "/", "2"}]], TraditionalForm]]],
  " rather than in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ". By multiplying them with each other, we obtain power series in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  ". The function ",
  StyleBox["make\[CurlyTheta]BaseProductsPre", "MR"],
  " forms all possible such products."
}], "Text"],

Cell[TextData[{
  "make\[CurlyTheta]BaseProductsPre[\[CurlyTheta]BaseTermsFinal_] := \n\
Module[{fBases2, fBases4, intBases, \[Lambda]2, \[Lambda]4},\n ",
  StyleBox["(* series in half-integer and in quarter-integer powers of q *)", 
    "CodeComment"],
  "                                    \n {fBases2, fBases4} = \n  \
Function[q, Cases[\[CurlyTheta]BaseTermsFinal, _?(MemberQ[Normal[#[[2]]], \n  \
                  Power[_, Rational[_, q]], Infinity]&)]] /@ {2, 4};          \
                          \n                                     \n ",
  StyleBox["(* series in integer powers of q *)", "CodeComment"],
  "\n intBases = Complement[\[CurlyTheta]BaseTermsFinal, Join[fBases2, \
fBases4]];\n ",
  StyleBox["(* form all eries in integer powers of q by multiplication *)", 
    "CodeComment"],
  "\n {\[Lambda]2, \[Lambda]4} = Length /@ {fBases2, fBases4};\n \
Join[intBases, \n      ",
  StyleBox["(* 1/2 + 1/2 = 1 *)", "CodeComment"],
  "\n      Union @ Flatten[Table[((fBases2[[i]]^#1) (fBases2[[j]]^#2))& @@@ \n\
                                  {{1, 1}}, {i, \[Lambda]2}, {j, \
\[Lambda]2}], 2],\n      ",
  StyleBox["(* 1/2 + (1/4 + 1/4) = (1/4 + 1/4) + 1/2 = 1 *)", "CodeComment"],
  "\n      Union @ Flatten[Table[((fBases2[[i]]^#1) (fBases4[[j]]^#2))& @@@ \
{{1, 2}},\n                            {i, \[Lambda]2}, {j, \[Lambda]4}], 2], \
 \n      ",
  StyleBox["(* (1/4 + 1/4) + (1/4 + 1/4) \n         = (1/4) + (1/4 + 1/4 + \
1/4) = (1/4 + 1/4 + 1/4) + (1/4) = 1 *)", "CodeComment"],
  "\n      Union @ Flatten[Table[((fBases4[[i]]^#1) (fBases4[[j]]^#2))& @@@ \n\
                             {{2, 2}, {1, 3}, {3, 1}},  {i, \[Lambda]4}, {j, \
\[Lambda]4}], 2]]];"
}], "Input"],

Cell["\<\
By eliminating again doubles, and series that are just negtives of \
each other from the 73 series, we are left with 72 different series.\
\>", \
"Text"],

Cell["\<\
\[CurlyTheta]BaseProductsPre = make\[CurlyTheta]BaseProductsPre[\
\[CurlyTheta]BaseTermsFinal];
\[CurlyTheta]BaseProductsPre // Length\
\>", "Input"],

Cell["\<\
equivalentProductSeriesList = \
identifyIntegerMultiples[\[CurlyTheta]BaseProductsPre];
\[CurlyTheta]BaseProducts = First /@ equivalentProductSeriesList;
\[CapitalLambda] = Length[\[CurlyTheta]BaseProducts]\
\>", "Input"],

Cell["Here are the two products that are equivalent.", "Text"],

Cell["\<\
Equal @@@ ((#/overallFactor[#])& /@ Take[Map[First, 
   Select[equivalentProductSeriesList, Length[#] > 1&], {2}], All]) // 
                                                       TraditionalForm\
\>", \
"Input"],

Cell["\<\
And these are the 72 products that we will use as building blocks \
in forming linear combinations of products and powers to find \
identities.\
\>", "Text"],

Cell[TextData[{
  StyleBox["(* truncate a series in such a way to display n nonvanishing \
terms *)", "CodeComment"],
  "\nmakeNTermSeries[HoldPattern[sd:SeriesData[x_, x0_, cs_, min_, max_, \
den_]], \n                n_Integer?Positive] := \nModule[{pos = Position[cs, \
_?(# !=0&), {1}, n], \[Lambda]}, \n       \[Lambda] = Max[pos];\n       \
If[Length[pos] < n, sd,\n          SeriesData[x, x0, Take[cs, \[Lambda]], \
min, min + \[Lambda], den]]]"
}], "Input"],

Cell["\<\
{#1, makeNTermSeries[#2, 4]}& @@@ \[CurlyTheta]BaseProducts // \
TableForm // 
                                                TraditionalForm\
\>", "Input"],

Cell["\<\
Now, we have the theta monomials to use on the ansatz for the \
linear combinations to form the identities we are looking for. We use all \
basic monomials with equal probability and raise them to randomly chosen \
small powers. (Because sometimes the same monomial will be chosen multiple \
times, this does not limit the maximal power in which a theta function can \
occur.)\
\>", "Text"],

Cell["\<\
\[DoubleStruckR] := Random[Integer, {1, \[CapitalLambda]}];
e\[DoubleStruckR] :=  Random[Integer, {0, 2}];
o\[DoubleStruckR] :=  Random[Integer, {0, 6}];\
\>", "Input"],

Cell[TextData[{
  "The function ",
  StyleBox["findIdentityCandidates", "MR"],
  " carries out the above\[Hyphen]described procedure to find potential \
nontrivial identities. The argument ",
  Cell[BoxData[
      FormBox["n", TraditionalForm]]],
  " indicates the number of theta monomials to be used in the initial ansatz. \
To speed up the null space calculation, we do not carry it out over rational \
numbers or integers (which would potentially lead to huge integers and so \
would be slow), but rather form only a modular null space."
}], "Text"],

Cell[TextData[{
  "findIdentityCandidates[n_] := \nModule[{prime = Prime[10^6], \
ansatzFunctions, \[Lambda], cList, qPoly, qSeries,\n        coeffs, \
\[ScriptL], eqs, ns, potentialIdentities}, \n",
  StyleBox["(* carry out identity search until a candidate is found *)", 
    "CodeComment"],
  "\nWhile[\n ",
  StyleBox["(* form products of powers of theta functions *)", 
    "CodeComment"],
  "\n ansatzFunctions = DeleteCases[#, 1]& @ \n         Union[Table[",
  StyleBox["(* q^e *)", "CodeComment"],
  " Product[\[CurlyTheta]S[\[DoubleStruckR]]^e\[DoubleStruckR], {o\
\[DoubleStruckR]}], {n}]];\n ",
  StyleBox["(* number of different theta monomials *)", "CodeComment"],
  "\n \[Lambda] = Length[ansatzFunctions];\n ",
  StyleBox["(* form linear combination with unknown coefficients *)", 
    "CodeComment"],
  "\n cList = Table[c[k], {k, \[Lambda]}];\n ",
  StyleBox["(* form resulting series *)", "CodeComment"],
  "\n qPoly = cList.ansatzFunctions /. \[CurlyTheta]S[k_] :> \
\[CurlyTheta]BaseProducts[[k, 2]];\n qSeries = qPoly + O[q]^o; \n ",
  StyleBox["(* extract linear equations in the c's from q-powers *)", 
    "CodeComment"],
  "\n coeffs = DeleteCases[qSeries[[3]], 0, {1}];\n \[ScriptL] = \
Length[coeffs];\n ",
  StyleBox["(* form coefficient matrix with more rows than columns *)", 
    "CodeComment"],
  "\n eqs = Function[sum, Coefficient[sum, #]& /@ cList] /@ \n                \
                 Take[coeffs, Min[3 \[Lambda], \[ScriptL]]];\n ",
  StyleBox["(* find modular null space *)", "CodeComment"],
  "\n ns = NullSpace[eqs, Modulus -> prime];\n ",
  StyleBox["(* lift modular null space *)", "CodeComment"],
  "\n res = (Mod[#, prime, -Floor[prime/2]].ansatzFunctions)& /@ ns;  \n ",
  StyleBox["(* the potential identities; ignore multiplicative factors *)", 
    "CodeComment"],
  "\n potentialIdentities = Cases[Factor[res /. \[CurlyTheta]S[k_] :> \
\[CurlyTheta]BaseProducts[[k, 1]]], \n                             _Plus, \
Infinity];\n potentialIdentities === {}];\n ",
  StyleBox["(* return found identities *)", "CodeComment"],
  " potentialIdentities]"
}], "Input"],

Cell[TextData[{
  "Because of the use of modular arithmetic in the last function, there is no \
guarantee that the result holds for all moduli, we add an additional high\
\[Hyphen]precision numeric test to check found identities. The function ",
  StyleBox["findIdentity", "MR"],
  " finds a numerically verified identity."
}], "Text"],

Cell["\<\
finalqTestQ[id_] := 
Module[{tf},
       Off[N::meprec]; 
       tf = N[fromTypeset[id] /. \[InvisibleSpace]q -> 1/2, 1000] == 0;
       Off[N::meprec]; 
       tf]

findIdentity[n_] := 
Module[{ids}, 
       While[(ids = Select[findIdentityCandidates[n], finalqTestQ]) == {}];
       ids]\
\>", "Input"],

Cell[TextData[{
  "We are now in a position to carry out the identity search. To avoid that \
we get multiple copies of the same identity, we define a function ",
  StyleBox["findIdentities", "MR"],
  " that tries to find ",
  StyleBox["o", "TI"],
  " identities. It eliminates all multiple found identities."
}], "Text"],

Cell[TextData[{
  "findIdentities[o_, n_] :=\nModule[{bag = {}, newIds, newIds1, newIds2},\n \
While[Length[bag] < o,\n       newIds = findIdentity[n];\n       ",
  StyleBox["(* were the newly found identities already encountered *)", 
    "CodeComment"],
  "\n       newIds1 = Union[Cases[Factor[newIds], _Plus, Infinity]];\n       \
newIds2 = Select[newIds1, FreeQ[bag, #]&]; \n       ",
  StyleBox["(* update identity collection *)", "CodeComment"],
  "\n       bag = Join[bag, newIds2]];\n ",
  StyleBox["(* return found identities *)", "CodeComment"],
  " bag]"
}], "Input"],

Cell["\<\
And here are 25 identities involving some of the \
above\[Hyphen]constructed 33 theta terms.\
\>", "Text"],

Cell["\<\
SeedRandom[2];
findIdentities[25, 300] \
\>", "Input"],

Cell[TextData[{
  "By changing the values of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " as fractions of ",
  Cell[BoxData[
      FormBox["\[Pi]", TraditionalForm]]],
  " to another value uniformly, we can extract the identities that are valid \
for any ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". (To find such identities, we could have started with series expansions \
in ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  " and form systems of equations in powers of ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ".)"
}], "Text"],

Cell["\<\
Select[fromTypeset[%], (N[# /. Pi -> E /. q -> 1/2, 22] == 
                        N[# /. Pi -> 1/Pi /. q -> 1/2, 22] == 0)&]\
\>", \
"Input"],

Cell[TextData[{
  "We can now easily carry out a search for theta identities with different \
values of ",
  Cell[BoxData[
      FormBox["z", TraditionalForm]]],
  ". Here is another list of theta function series."
}], "Text"],

Cell["\<\
T1 = makeSimpleSeriesTerms[{0, Pi/2, -Pi/2, Pi/3, -Pi/3, Pi/6, \
-Pi/6}];\
\>", "Input"],

Cell["This time, we have 36 theta monomials.", "Text"],

Cell["\<\
\[CurlyTheta]BaseTerms = makeBaseTerms[T1];
\[CurlyTheta]BaseTermsSeries = \
make\[CurlyTheta]BaseTermsSeries[\[CurlyTheta]BaseTerms];
equivalentSeriesList = \
identifyIntegerMultiples[\[CurlyTheta]BaseTermsSeries];
\[CurlyTheta]BaseTermsFinal = First /@ equivalentSeriesList;
Length[\[CurlyTheta]BaseTermsFinal]\
\>", "Input"],

Cell[TextData[{
  "And for the linear combinations, we can draw from 132 theta monomials and \
no equivalent series among the ",
  StyleBox["\[CurlyTheta]BaseProductsPre", "MR"],
  "."
}], "Text"],

Cell["\<\
\[CurlyTheta]BaseProductsPre = make\[CurlyTheta]BaseProductsPre[\
\[CurlyTheta]BaseTermsFinal];
equivalentProductSeriesList = \
identifyIntegerMultiples[\[CurlyTheta]BaseProductsPre];
\[CurlyTheta]BaseProducts = First /@ equivalentProductSeriesList;
\[CapitalLambda] = Length[\[CurlyTheta]BaseProducts]\
\>", "Input"],

Cell["And here are again 20 identities among them.", "Text"],

Cell["\<\
SeedRandom[2];
findIdentities[20, 360]\
\>", "Input"],

Cell[TextData[{
  "The interested reader could now continue with further theta series. Here \
are a few further possibilities for the series to be used in ",
  StyleBox["\[CurlyTheta]BaseTerms", "MR"],
  "."
}], "Text"],

Cell["\<\
makeSeriesPair /@ Join[
   { \[Theta][1, Pi/12, q] + \[Theta][2, Pi/12, q], \[Theta][1, Pi/12, q] - \
\[Theta][2, Pi/12, q],
     \[Theta][3, Pi/12, q] + \[Theta][4, Pi/12, q], \[Theta][3, Pi/12, q] - \
\[Theta][4, Pi/12, q],
     \[Theta][2, 4 Pi/5, q] - \[Theta][2, 2 Pi/5, q],
    -\[Theta][2,  Pi/5, q] + \[Theta][2, 2 Pi/5, q] - \[Theta][2, 3 Pi/5, q] \
+ \[Theta][2, 4 Pi/5, q],
     \[Theta][3, 3 Pi/5, q] + \[Theta][3, 4 Pi/5, q],
    -\[Theta][3, 3 Pi/10, q] - \[Theta][3, 7 Pi/10, q] + \[Theta][3, 9 Pi/10, \
q] + 3 \[Theta][4, Pi/5, q],
    -\[Theta][3,   Pi/10, q] - \[Theta][3, 3 Pi/10, q] - \[Theta][3, 7 Pi/10, \
q] + 3 \[Theta][4, Pi/5, q]},
   { \[Theta]p[1, Pi/12, q] + \[Theta]p[2, Pi/12, q], \[Theta]p[1, Pi/12, q] \
- \[Theta]p[2, Pi/12, q],
     \[Theta]p[3, Pi/12, q] + \[Theta]p[4, Pi/12, q], \[Theta]p[3, Pi/12, q] \
- \[Theta]p[4, Pi/12, q]} /.
                                                  \[Theta]p -> Derivative[0, \
1, 0][\[Theta]]]\
\>", "Input"],

Cell[TextData[{
  "These are some of the series that result from the use of theta functions \
at values that are multiples of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "5"}], TraditionalForm]]],
  " and ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "10"}], TraditionalForm]]],
  "."
}], "Text"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"-", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "2"], "(", 
              RowBox[{
                FractionBox["\[Pi]", "5"], ",", 
                SuperscriptBox["q", "4"]}], ")"}]}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"2", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "+", 
          RowBox[{"2", " ", 
            RowBox[{"(", 
              RowBox[{
                RowBox[{"-", 
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "3"], "(", 
                    RowBox[{
                      FractionBox[
                        RowBox[{"3", " ", "\[Pi]"}], "5"], ",", "q"}], 
                    ")"}]}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}], 
                "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}]}], ")"}]}]}], "=", 
        "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox["\[Pi]", "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"2", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "+", 
          RowBox[{"2", " ", 
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"7", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"9", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "-", 
                RowBox[{"3", " ", 
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "4"], "(", 
                    RowBox[{
                      FractionBox["\[Pi]", "5"], ",", "q"}], ")"}]}]}], 
              ")"}]}]}], "=", "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"-", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                FractionBox[
                  RowBox[{"3", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}]}], "+",
           
          RowBox[{"2", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                FractionBox[
                  RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                SuperscriptBox["q", "4"]}], ")"}]}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"4", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}], "+", 
          RowBox[{"2", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "3"], "(", 
              RowBox[{
                FractionBox[
                  RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                SuperscriptBox["q", "4"]}], ")"}]}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"7", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"9", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "-", 
          RowBox[{"3", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "4"], "(", 
              RowBox[{
                FractionBox["\[Pi]", "5"], ",", "q"}], ")"}]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"-", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "2"], "(", 
              RowBox[{
                FractionBox["\[Pi]", "5"], ",", 
                SuperscriptBox["q", "4"]}], ")"}]}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"2", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "2"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
              SuperscriptBox["q", "4"]}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"4", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"3", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "-", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"7", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "+", 
          RowBox[{
            SubscriptBox["\[CurlyTheta]", "3"], "(", 
            RowBox[{
              FractionBox[
                RowBox[{"9", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], "+", 
          RowBox[{"3", " ", 
            RowBox[{
              SubscriptBox["\[CurlyTheta]", "4"], "(", 
              RowBox[{
                FractionBox["\[Pi]", "5"], ",", "q"}], ")"}]}]}], "=", "0"}], 
      TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}], 
                "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", "q"}], ")"}]}], 
              ")"}], "2"], "-", 
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"7", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"9", " ", "\[Pi]"}], "10"], ",", "q"}], ")"}], 
                "-", 
                RowBox[{"3", " ", 
                  RowBox[{
                    SubscriptBox["\[CurlyTheta]", "4"], "(", 
                    RowBox[{
                      FractionBox["\[Pi]", "5"], ",", "q"}], ")"}]}]}], ")"}],
             "2"], "+", 
          RowBox[{"2", " ", 
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox["\[Pi]", "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"2", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}]}], ")"}], " ", 
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "3"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}]}], ")"}]}]}], "=", 
        "0"}], TraditionalForm]], "DisplayFormula"],

Cell[BoxData[
    FormBox[
      RowBox[{
        RowBox[{
          RowBox[{"2", " ", 
            RowBox[{"(", 
              RowBox[{
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        SubscriptBox["\[CurlyTheta]", "3"], "(", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"3", " ", "\[Pi]"}], "5"], ",", "q"}], 
                        ")"}], "+", 
                      RowBox[{
                        SubscriptBox["\[CurlyTheta]", "3"], "(", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"4", " ", "\[Pi]"}], "5"], ",", "q"}], 
                        ")"}]}], ")"}], "2"], "-", 
                RowBox[{"2", " ", 
                  SuperscriptBox[
                    RowBox[{"(", 
                      RowBox[{
                        RowBox[{
                          SubscriptBox["\[CurlyTheta]", "3"], "(", 
                          RowBox[{
                            FractionBox[
                              RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                            SuperscriptBox["q", "4"]}], ")"}], "+", 
                        RowBox[{
                          SubscriptBox["\[CurlyTheta]", "3"], "(", 
                          RowBox[{
                            FractionBox[
                              RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                            SuperscriptBox["q", "4"]}], ")"}]}], ")"}], 
                    "2"]}], "+", 
                SuperscriptBox[
                  RowBox[{"(", 
                    RowBox[{
                      RowBox[{
                        SubscriptBox["\[CurlyTheta]", "3"], "(", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"3", " ", "\[Pi]"}], "10"], ",", "q"}], 
                        ")"}], "+", 
                      RowBox[{
                        SubscriptBox["\[CurlyTheta]", "3"], "(", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"7", " ", "\[Pi]"}], "10"], ",", "q"}], 
                        ")"}], "-", 
                      RowBox[{
                        SubscriptBox["\[CurlyTheta]", "3"], "(", 
                        RowBox[{
                          FractionBox[
                            RowBox[{"9", " ", "\[Pi]"}], "10"], ",", "q"}], 
                        ")"}], "-", 
                      RowBox[{"3", " ", 
                        RowBox[{
                          SubscriptBox["\[CurlyTheta]", "4"], "(", 
                          RowBox[{
                            FractionBox["\[Pi]", "5"], ",", "q"}], ")"}]}]}], 
                    ")"}], "2"]}], ")"}]}], "-", 
          SuperscriptBox[
            RowBox[{"(", 
              RowBox[{
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox["\[Pi]", "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"2", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "+", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"3", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}], "-", 
                RowBox[{
                  SubscriptBox["\[CurlyTheta]", "2"], "(", 
                  RowBox[{
                    FractionBox[
                      RowBox[{"4", " ", "\[Pi]"}], "5"], ",", 
                    SuperscriptBox["q", "4"]}], ")"}]}], ")"}], "2"]}], "=", 
        "0"}], TraditionalForm]], "DisplayFormula"],

Cell[TextData[{
  "To search for identities with other multiples of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", "d"}], TraditionalForm]]],
  ", we need linear combinations of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "a"], "(", 
          RowBox[{
            RowBox[{"p", " ", 
              RowBox[{"\[Pi]", "/", "d"}]}], ",", "q"}], ")"}], 
        TraditionalForm]]],
  " such that the series expansion of these linear combinations has integer \
coefficients. The following function ",
  StyleBox["find\[CurlyTheta]LinearCombinations", "MR"],
  " tries to find ",
  Cell[BoxData[
      FormBox["o", TraditionalForm]]],
  " linear combinations of thsi form for multiples of ",
  Cell[BoxData[
      FormBox[
        RowBox[{"\[Pi]", "/", 
          StyleBox["den",
            "TI"]}], TraditionalForm]]],
  "."
}], "Text"],

Cell[TextData[{
  "find\[CurlyTheta]LinearCombinations[o_, den_] := \nModule[{",
  StyleBox["(* general series expansions at q == 0 *)", "CodeComment"],
  "\n        ser = Normal[Table[Series[EllipticTheta[j, z, q], \n             \
                     {q, 0, 25}], {j, 4}]],\n        sum12, sumS12, sum34, \
sumS34, vars, \[DoubleStruckR]\[DoubleStruckC], \[DoubleStruckR]\
\[DoubleStruckC]\[DoubleStruckS], \[DoubleStruckS], \n        n\
\[DoubleStruckS], n\[DoubleStruckS]r, bag = {}},\n ",
  StyleBox["(* symbolic linear combinations of the two pairs with equal \
q-powers *)", "CodeComment"],
  "\n {sumS12, sumS34} = \n   (Sum[c[\[Alpha], j] Subscript[\[CurlyTheta], \
#1][j Pi/(2 den), q], {j, 0, 2 den - 1}] + \n    Sum[c[\[Beta], j] Subscript[\
\[CurlyTheta], #2][j Pi/(2 den), q], {j, 0, 2 den - 1}])& @@@\n               \
                                            {{1, 2}, {3, 4}};\n ",
  StyleBox["(* explicit linear combinations of the two pairs with equal \
q-powers *)", "CodeComment"],
  "\n {sum12, sum34} = {sumS12, sumS34} /. \n                Subscript[\
\[CurlyTheta], j_] :> Function @@ {{z, q}, Evaluate[ser[[j]]]};      \n ",
  StyleBox["(* the undetermined coefficients *)", "CodeComment"],
  "\n vars = Cases[sumS12, _c, Infinity];\n ",
  StyleBox["(* values for the 4 den undetermined coefficients \n    \
c[\[Alpha], j] and c[\[Beta], j], j = 0, 1, \[Ellipsis], 2 den - 1 *)", 
    "CodeComment"],
  "\n \[DoubleStruckR]\[DoubleStruckC] := Rule @@@ Transpose[{vars, \
Table[Random[Integer, {-1, 1}], \n                                       \
{Length[vars]}]}];\n While[Length[bag] < o, ",
  StyleBox["(* try linear combination *)", "CodeComment"],
  " \[DoubleStruckR]\[DoubleStruckC]\[DoubleStruckS] = \[DoubleStruckR]\
\[DoubleStruckC];       \n       ",
  StyleBox["(* check if try combination results in q-series \n       with \
integer coefficients *)", "CodeComment"],
  "     \n      ",
  StyleBox[" (* series in \[CurlyTheta]_1 and \[CurlyTheta]_2 *)   ", 
    "CodeComment"],
  "                  \n       \[DoubleStruckS] = sum12 //. \[DoubleStruckR]\
\[DoubleStruckC]\[DoubleStruckS]; n\[DoubleStruckS] = N[\[DoubleStruckS], \
22]; n\[DoubleStruckS]r = n\[DoubleStruckS] /. x_Real :> Round[x];\n       \
If[(n\[DoubleStruckS] - n\[DoubleStruckS]r /. q -> 1) == 0, AppendTo[bag, \
{sumS12 /. \[DoubleStruckR]\[DoubleStruckC]\[DoubleStruckS], \
n\[DoubleStruckS]r}]];\n       ",
  StyleBox["(* series in \[CurlyTheta]_3 and \[CurlyTheta]_4 *) ", 
    "CodeComment"],
  "\n       \[DoubleStruckS] = sum34 //. \[DoubleStruckR]\[DoubleStruckC]\
\[DoubleStruckS]; n\[DoubleStruckS] = N[\[DoubleStruckS], 22]; n\
\[DoubleStruckS]r = n\[DoubleStruckS] //. x_Real :> Round[x];\n       If[(n\
\[DoubleStruckS] - n\[DoubleStruckS]r  /. q -> 1) == 0, AppendTo[bag, {sumS34 \
/. \[DoubleStruckR]\[DoubleStruckC]\[DoubleStruckS], n\[DoubleStruckS]r}]]];\n\
 ",
  StyleBox["(* return found linear combinations *)", "CodeComment"],
  " bag]      "
}], "Input"],

Cell[TextData[{
  "Here are some linear combinations of ",
  Cell[BoxData[
      FormBox[
        RowBox[{
          SubscriptBox["\[CurlyTheta]", "a"], "(", 
          RowBox[{
            RowBox[{"p", " ", 
              RowBox[{"\[Pi]", "/", "7"}]}], ",", "q"}], ")"}], 
        TraditionalForm]]],
  " that have integer ",
  Cell[BoxData[
      FormBox["q", TraditionalForm]]],
  "\[Hyphen]series coefficients."
}], "Text"],

Cell["\<\
SeedRandom[123];
find\[CurlyTheta]LinearCombinations[6, 7]\
\>", "Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["References", "ReferencesSection",
  CellTags->"T[Ref[1]]"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Abramson, D. H. Zanette. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 67, 057101 (2003). "
}], "BibliographyItem",
  CellTags->"Abramson03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Acedo, S. B. Yuste. ",
  StyleBox["arXiv:cond-mat", "TI"],
  "/0310121 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Acedo03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Adler, J. Moser. ",
  StyleBox["Comm. Math. Phys.", "TI"],
  " 61, 1 (1978)."
}], "BibliographyItem",
  CellTags->"Adler78"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Aguirre, J. C. Vallejo, M. A. F. Sanju\[AAcute]n. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 64, 066208 (2001). "
}], "BibliographyItem",
  CellTags->"Aguirre01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Aguirre, M. A. F. Sanju\[AAcute]n. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 67, 056201 (2003). "
}], "BibliographyItem",
  CellTags->"Aguirre03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Alonso, S. Brouard, J. P. Palao, R. S. Mayato. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0309030 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Alonso03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. M. Angelo, L. Sanz, K. Furuya. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 68, 016206 (2003). "
}], "BibliographyItem",
  CellTags->"Angelo03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. M. Atakishiyev, G. S. Pogosyan, L. E. Vicent, K. B. Wolf. ",
  StyleBox["J. Phys.", "TI"],
  " A 34, 9381 (2001). "
}], "BibliographyItem",
  CellTags->"Atakishiyev01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. M. Atakishiyev, G. S. Pogosyan, K. B. Wolf. ",
  StyleBox["Int. J. Mod. Phys.", "TI"],
  " A 18, 317 (2003). "
}], "BibliographyItem",
  CellTags->"Atakishiyev03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. M. Atakishiyev, A. U. Klimyk, K. B. Wolf. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0401035 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Atakishiyev04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Azzam, E. Kreysig. ",
  StyleBox["SIAM J. Math. Anal.", "TI"],
  " 13, 254 (1982)."
}], "BibliographyItem",
  CellTags->"Azzam82"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Baake, U. Grimm, R. J. Baxter. ",
  StyleBox["arXiv:solv-int", "TI"],
  "/9902009 (1999).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Baake99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. B\[AAcute]ez\[Dash]Duarte. ",
  StyleBox["arXiv:math.NT", "TI"],
  "/0307215 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"BaezDuarte03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. A. Baker, P. Graves\[Dash]Morris. ",
  StyleBox["Pad\[EAcute] Approximants", "TI"],
  ", Cambridge University Press, Cambridge, 1996. "
}], "BibliographyItem",
  CellTags->"Baker96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Balcou, A. L\[CloseCurlyQuote]Huillier, D. Escande. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 53, 3456 (1996). "
}], "BibliographyItem",
  CellTags->"Balcou96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. E. Ballentine, S. M. McRae. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 58, 1799 (1998). "
}], "BibliographyItem",
  CellTags->"Ballentine98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H. P. Baltes, E. R. Hilf. ",
  StyleBox["Spectra of Finite Systems", "TI"],
  ", BI Wissenschaftsverlag, Mannheim, 1976. "
}], "BibliographyItem",
  CellTags->"Baltes76"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Bajnok, S. B. Damelin, J. Li, G. L. Mullen. ",
  StyleBox["Comput.", "TI"],
  " 68, 97 (2003). "
}], "BibliographyItem",
  CellTags->"Bajnok02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. M. Barbashov, N. A. Chernikov. ",
  StyleBox["Soviet Phys. JETP", "TI"],
  " 24, 437 (1967). "
}], "BibliographyItem",
  CellTags->"Barbashov67"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. T. Barlow, R. F. Bass. ",
  StyleBox["Proc. R. Soc. Lond.", "TI"],
  " A 431, 345 (1990). "
}], "BibliographyItem",
  CellTags->"Barlow90"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Barth\[EAcute]l\[EAcute]my, S. V. Buldyrev, S. Havlin, H. E. Stanley. \
",
  StyleBox["Phys. Rev.", "TI"],
  " E 61, R3283 (1995). "
}], "BibliographyItem",
  CellTags->"Barthelemy00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Baruch. ",
  StyleBox["Ueber die Differentialrelationen zwischen den Thetafunctionen \
eines Arguments.", "TI"],
  ", Ph. D. thesis, Halle, 1910. "
}], "BibliographyItem",
  CellTags->"Baruch10"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. E. Bayfield. ",
  StyleBox["Quantum Evolution.", "TI"],
  ", Wiley, New York, 1999."
}], "BibliographyItem",
  CellTags->"Bayfield99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  O. R. Beaver, T. Garrity. ",
  StyleBox["J. Number Th.", "TI"],
  " 107, 105 (2004). "
}], "BibliographyItem",
  CellTags->"Beaver04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Bell. ",
  StyleBox["J. Phys.", "TI"],
  " B 3, 745 (1970). "
}], "BibliographyItem",
  CellTags->"Bell70"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Belloni, M. A. Doncheski, R. W. Robinett. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0312086 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Belloni03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Belmonte, M. J. Shelley, S. T. Eldakar, C. H. Wiggins. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 387, 114301 (2001)."
}], "BibliographyItem",
  CellTags->"Belmonte01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  V. P. Berezovoj, Y. L. Bolotin, V. A. Cherkaskiy. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0301012 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Berezovoj03a"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. V. Berry in W. Guttinger, H. Elkheimer (eds.). ",
  StyleBox["Structural Stability in Physics", "TI"],
  ", Springer\[Hyphen]Verlag, Berlin, 1979. "
}], "BibliographyItem",
  CellTags->"Berry79"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. V. Berry, N. L. Balazs. ",
  StyleBox["J. Phys.", "TI"],
  " A 12, 625 (1979). "
}], "BibliographyItem",
  CellTags->"Berry79b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Besprosvany. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 63, 233108 (2001). "
}], "BibliographyItem",
  CellTags->"Besprosvany01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. Betchov. ",
  StyleBox["J. Fluid Mech.", "TI"],
  " 22, 471 (1965). "
}], "BibliographyItem",
  CellTags->"Betchov65"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Bhattacharya, S. Habib, K. Jacobs. ",
  StyleBox["Los Alamos Sc.", "TI"],
  " n 27, 110 (2002). "
}], "BibliographyItem",
  CellTags->"Bhattacharya02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. Bialnynicki\[Dash]Birula in B. Jancewicz, J. Lukierski (eds.). ",
  StyleBox["Quantum Theory of Particles and Fields.", "TI"],
  " , World Scientific, Singapore, 1983. "
}], "BibliographyItem",
  CellTags->"BialnynickiBirula83"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Blochintsev. ",
  StyleBox["Dokl. Akad. Nauk", "TI"],
  " 82, 553 (1952). "
}], "BibliographyItem",
  CellTags->"Blochintsev52"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Bode in B. Kramer (ed.). ",
  StyleBox["Advances in Solid State Physics.", "TI"],
  ", v. 41, Springer\[Hyphen]Verlag, Berlin, 2001."
}], "BibliographyItem",
  CellTags->"Bode01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. Bogomolny, C. Schmit. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0402017 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Bogomolny04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  " A. O. Bolivar. ",
  StyleBox["Quantum\[Dash]Classical Correspondence", "TI"],
  ", Springer\[Hyphen]Verlag, Berlin, 2004."
}], "BibliographyItem",
  CellTags->"Bolivar04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Borwein, D. Bailey. ",
  StyleBox["Mathematics by Experiment: Plausible Reasoning in the 21st \
Century", "TI"],
  ", A K Peters, Nautick, 2003. "
}], "BibliographyItem",
  CellTags->"Borwein03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Borwein, D. Bailey, R. Girgensohn. ",
  StyleBox["Experimentation in Mathematics", "TI"],
  ", A K. Peters, Natick, 2004. "
}], "BibliographyItem",
  CellTags->"Borwein04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Bosanac. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 28, 577 (1983). "
}], "BibliographyItem",
  CellTags->"Bosanac83"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Brack, R. K. Bhaduri, J. Law, M. V. Murthy. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 70, 568 (1993). "
}], "BibliographyItem",
  CellTags->"Brack93"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Brack, C. Creagh, J. Law. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 57, 788 (1998). "
}], "BibliographyItem",
  CellTags->"Brack98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Brenier. ",
  StyleBox["Arch. Rat. Mech. Anal.", "TI"],
  " 172, 65 (2004). "
}], "BibliographyItem",
  CellTags->"Brenier04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H.\[Hyphen]P. Breuer, F. Petruccione. ",
  StyleBox["The Theory of Open Quantum Systems", "TI"],
  ", Oxford University Press, Oxford, 2002. "
}], "BibliographyItem",
  CellTags->"Breuer02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  K. Briggs. ",
  StyleBox["Math. Comput.", "TI"],
  " 57, 435 (1991). "
}], "BibliographyItem",
  CellTags->"Briggs91"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. C. Brunelli, A. Das. ",
  StyleBox["arXiv:hep-th", "TI"],
  "/9712081 (1997).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Brunelli97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. L. Burchnall, T. W. Chaundy. ",
  StyleBox["Proc. Lond. Math. Soc.", "TI"],
  " 30, 401 (1930)."
}], "BibliographyItem",
  CellTags->"Burchnall30"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. F. Buttke. ",
  StyleBox["J. Comput. Phys.", "TI"],
  " 76, 301 (1988). "
}], "BibliographyItem",
  CellTags->"Buttke88"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. W. Byron, R. W. Fuller. ",
  StyleBox["Mathematics of Classical and Quantum Physics", "TI"],
  " v. 1, Addison Wesley, Reading, 1970 "
}], "BibliographyItem",
  CellTags->"Byron70"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. Camassa, D. D. Holm, J. M. Hyman. ",
  StyleBox["Adv. Appl. Mech.", "TI"],
  " 31, 1 (1994)."
}], "BibliographyItem",
  CellTags->"Camassa94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Cametti, C. Presilla. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0201147 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Cametti02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J.\[Hyphen]G. Caputo, J. Leon, A. Spire. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 283, 129 (2001). "
}], "BibliographyItem",
  CellTags->"Caputo01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. L. Cardeso, R. \[CapitalAAcute]lvarez\[Dash]Nodarse. ",
  StyleBox["J. Phys.", "TI"],
  " A 36, 2055 (2003). "
}], "BibliographyItem",
  CellTags->"Cardeso03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. H. E. Cartwright. ",
  StyleBox["arXiv:nlin.PS", "TI"],
  "/0211001 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"HyperlinkReturn"]
}], "BibliographyItem",
  CellTags->"Cartwright02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. R. R. Carvalho, R. L. de Matos Filho, L. Davidovich. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 70, 026211 (2004). "
}], "BibliographyItem",
  CellTags->"Carvalho04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Casati. ",
  StyleBox["Chaos ", "TI"],
  "6, 391 (1996). "
}], "BibliographyItem",
  CellTags->"Casati96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Cerruti\[Dash]Sola, M. Pettini. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 53, 179 (1996). "
}], "BibliographyItem",
  CellTags->"CerrutiSola96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Chaos\[Dash]Cador, E. Ley\[Dash]Koo. ",
  StyleBox["Int. J. Quant. Chem.", "TI"],
  " 97, 844 (2004). "
}], "BibliographyItem",
  CellTags->"ChaosCador04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H. Chat\[EAcute], P. Manneville. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 58, 112 (1987). "
}], "BibliographyItem",
  CellTags->"Chate87"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. K. Chatteraj, B. Maiti, S. Sengupta. ",
  StyleBox["Int. J. Quant. Chem.", "TI"],
  " 100, 254 (2004). "
}], "BibliographyItem",
  CellTags->"Chatteraj04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. S. Chellone. ",
  StyleBox["J. Phys.", "TI"],
  " A 4, 184 (1971). "
}], "BibliographyItem",
  CellTags->"Chellone71"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Christiansen, P. Cvitanovic, H. H. Rugh. ",
  StyleBox["J. Phys.", "TI"],
  " A 23, S713 (1990). "
}], "BibliographyItem",
  CellTags->"Christiansen90"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  K. M. Christoffel, P. Brumer. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 33, 4092 (1986). "
}], "BibliographyItem",
  CellTags->"Chang86"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Chruscinski, J. Kijowski. ",
  StyleBox["J. Phys.", "TI"],
  " 31, 269 (1998). "
}], "BibliographyItem",
  CellTags->"Chruscinski98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Ciattoni, P. D. Porto. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 69, 056611 (2004). "
}], "BibliographyItem",
  CellTags->"Ciattoni04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Cieslinski, P. K. H. Gragert, A. Sym. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 57, 1507 (1986). "
}], "BibliographyItem",
  CellTags->"Cieslinski86"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y.\[Hyphen]J. Chun, H.\[Hyphen]W. Lee. ",
  StyleBox["Ann. Phys.", "TI"],
  " 307, 438 (2003). "
}], "BibliographyItem",
  CellTags->"Chun03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Ciattoni, C. Conti, P. Di Porto. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 69, 036608 (2004). "
}], "BibliographyItem",
  CellTags->"Ciattoni04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. A. Clarkson and E. L. Mansfield. ",
  StyleBox["Nonlinearity", "TI"],
  " 16, R1 (2003)."
}], "BibliographyItem",
  CellTags->"Clarkson03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Cohen. ",
  StyleBox["Time\[Dash]Frequency Analysis", "TI"],
  ", Prentice Hall, Englewood Cliffs, 1995."
}], "BibliographyItem",
  CellTags->"Cohen95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. J. Crampin, E. A. Gaffney, P. K. Maini. ",
  StyleBox["Bull. Math. Biol.", "TI"],
  " 61, 1093 (1999). "
}], "BibliographyItem",
  CellTags->"Crampin99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. J. Crampin, P. K. Maini. ",
  StyleBox["Methods Appl. Anal.", "TI"],
  " 8, 415 (2001). "
}], "BibliographyItem",
  CellTags->"Crampin01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. J. Crampin, E. A. Gaffney, P. K. Maini. ",
  StyleBox["J. Math. Biol.", "TI"],
  " 44, 107 (2002). "
}], "BibliographyItem",
  CellTags->"Crampin02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. J. Crampin, W. W. Hackborn, P. K. Maini. ",
  StyleBox["Bull. Math. Biol.", "TI"],
  " 64, 747 (2002). "
}], "BibliographyItem",
  CellTags->"Crampin02b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. M. Cuccietti, H. M. Pastawski, D. A. Wisniacki. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 65, 045206 (2002). "
}], "BibliographyItem",
  CellTags->"Cuccietti02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. M. Cucchietti, D. A. R. Dalvit, J. P. Paz, W. H. Zurek. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0306142 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Cucchietti03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Czirj\[AAcute]k, R. Kopold, W. Becker, M. Kleber, W. P. Schleich. ",
  StyleBox["Opt. Comm.", "TI"],
  " 179, 29 (2000). "
}], "BibliographyItem",
  CellTags->"Czirjak00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  V. I. Denisov. ",
  StyleBox["Phys. Rev.", "TI"],
  " D 61, 036004 (2000). "
}], "BibliographyItem",
  CellTags->"Denisov00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. DeSerio. ",
  StyleBox["Am. J. Phys.", "TI"],
  " 71, 250 (2003). "
}], "BibliographyItem",
  CellTags->"DeSerio03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Dhar, D. M. Rao, U. Shankar N., S. Sridhar. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0303052 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Dhar03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. S. Dowker. ",
  StyleBox["arXiv:math.SP", "TI"],
  "/0409442 (2004).   ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Dowker04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. A. Driscoll. ",
  StyleBox["SIAM Rev.", "TI"],
  " 39, 1 (1997). "
}], "BibliographyItem",
  CellTags->"Driscoll97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. A. Driscoll, L. N. Trefethen. ",
  StyleBox["Schwarz\[Dash]Christoffel Mapping", "TI"],
  ", Cambridge University Press, Cambridge, 2002."
}], "BibliographyItem",
  CellTags->"Driscoll02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. A. Driscoll, H. P. W. Gottlieb. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 69, 016702 (2003). "
}], "BibliographyItem",
  CellTags->"Driscoll03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Dubey, L. S. Shapley. ",
  StyleBox["Math. Oper. Res.", "TI"],
  " 4, 99 (1979). "
}], "BibliographyItem",
  CellTags->"Dubey79"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. M. Duxbury, R. A. Guyer, J. Machta. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 66, 6711 (1995). "
}], "BibliographyItem",
  CellTags->"Duxbury95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Encinosa, B. Etemadi. ",
  StyleBox["Found. Phys.", "TI"],
  " 16, 403 (2003). "
}], "BibliographyItem",
  CellTags->"Encinosa03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Encinosa, L. Mott, B. Etemadi. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0409141 (2004).   ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Encinosa04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  V. Englisch, W. Lauterborn. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 44, 916 (1991). "
}], "BibliographyItem",
  CellTags->"Englisch91"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. L. Ericksen in M. E. Gurtin (ed.). ",
  StyleBox["Phase Transitions and Material Instabilities in Solids", "TI"],
  ", Academic Press, Orlando, 1984. "
}], "BibliographyItem",
  CellTags->"Ericksen84"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Z. Farkas, G. Bartels, T. Unger, D. E. Wolf. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 90, 248302 (2003). "
}], "BibliographyItem",
  CellTags->"Farkas03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. J. Feigenbaum. ",
  StyleBox["J. Stat. Phys.", "TI"],
  " 19, 25 (1978). "
}], "BibliographyItem",
  CellTags->"Feigenbaum78"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Felder, L. Kofman, A. Starobinsky. ",
  StyleBox["arXiv:hep-th", "TI"],
  "/0208019 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Felder02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. S. Felsenthal, M. Machover. ",
  StyleBox["The Measurement of Voting Power: Theory and Practice, Problems \
and Paradoxes", "TI"],
  ", Edward Elgar, London, 1998. "
}], "BibliographyItem",
  CellTags->"Felsenthal98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. Ferraro. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 325, 134 (2004). "
}], "BibliographyItem",
  CellTags->"Ferraro04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. F\[ODoubleDot]ldi, M. G. Benedict, A. Czirj\[AAcute]k, B. Moln\
\[AAcute]r. ",
  StyleBox["Fortschritte Phys.", "TI"],
  " 51, 122 (2004). "
}], "BibliographyItem",
  CellTags->"Foeldi03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Fornberg. ",
  StyleBox["SIAM Rev.", "TI"],
  " 40, 685 (1998). "
}], "BibliographyItem",
  CellTags->"Fornberg98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Fornberg, M. Ghrist. ",
  StyleBox["SIAM J. Num. Anal.", "TI"],
  " 37, 105 (1999). "
}], "BibliographyItem",
  CellTags->"Fornberg99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Friesecke, F. Theil. ",
  StyleBox["J. Nonlin. Sci.", "TI"],
  " 12, 445 (2002). "
}], "BibliographyItem",
  CellTags->"Friesecke02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Friesecke, K. Matthies. ",
  StyleBox["Disc. Contin. Dynam. Syst.", "TI"],
  " 3, 105 (2003). "
}], "BibliographyItem",
  CellTags->"Friesecke03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  U. Frisch, K. Khanin, T. Matsumoto. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0309068 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Frisch03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Galleani, L. Cohen. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 302, 149 (2002). "
}], "BibliographyItem",
  CellTags->"Galleani02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Galleani, L. L. Presti. ",
  StyleBox["J. Mod. Opt.", "TI"],
  " 49, 581 (2002). "
}], "BibliographyItem",
  CellTags->"Galleani02b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. A. Gardiner, D. Jaksch, R. Dum, J. I. Cirac, P. Zoller. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 62, 023612 (2000). "
}], "BibliographyItem",
  CellTags->"Gardiner00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Gaspard, S. A. Rice. ",
  StyleBox["J. Chem. Phys.", "TI"],
  " 90, 2225 (1989). "
}], "BibliographyItem",
  CellTags->"Gaspard89"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Gillet, Z. Csahok, C. Misbah. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 63, 241401 (2001). "
}], "BibliographyItem",
  CellTags->"Gillet01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. M. L. Gladwell. ",
  StyleBox["Quart. J. Mech. Appl. Math.", "TI"],
  " 755, 1 (2002). "
}], "BibliographyItem",
  CellTags->"Gladwell02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. P. Goldman. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 29, 3406 (1984). "
}], "BibliographyItem",
  CellTags->"Goldman84"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. A. Golovin, A. A. Nepomnyascchy. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 67, 056202 (2003). "
}], "BibliographyItem",
  CellTags->"Golovin03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Goos, M. Hanchen. ",
  StyleBox["Ann. Phys.", "TI"],
  " 1, 333 (1947). "
}], "BibliographyItem",
  CellTags->"Goos47"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Goos, M. H\[ADoubleDot]nchen. ",
  StyleBox["Ann. Phys.", "TI"],
  " 5, 251 (1947). "
}], "BibliographyItem",
  CellTags->"Goos49"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. D. Greenbaum, S. Habib, K. Shizume, B. Sundaram. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0401174 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Greenbaum04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. Grosche, F. Steiner. ",
  StyleBox["Handbook of Feynman Path Integrals", "TI"],
  ", Springer\[Hyphen]Verlag, Heidelberg 1998."
}], "BibliographyItem",
  CellTags->"Grosche98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Gutierrez, L. Vega. ",
  StyleBox["arXiv:math.AP", "TI"],
  "/0404291 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Gutierrez04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Gutman, I. Airam, A. Rabinovitch. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 69, 016211 (2004). "
}], "BibliographyItem",
  CellTags->"Gutman04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Habib, K. Shizume, W. H. Zurek. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/9803042 (1998).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Habib98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Habib, K. Jacobs, H. Mabuchi, R. Ryne, K. Shizume, B. Sundaram. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0010093 (2000).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Habib00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Hauswirth. ",
  StyleBox["arXiv:hep-lat", "TI"],
  "/0010033 (2000).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Hauswirth00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. S. Helmkamp, D. A. Browne. ",
  StyleBox["Phys. Rev. ", "TI"],
  "E 49, 1831 (1994). "
}], "BibliographyItem",
  CellTags->"Helmkamp94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. S. Hicks, R. F. Wheeling. ",
  StyleBox["Comm. ACM", "TI"],
  " 13, 17 (1959). "
}], "BibliographyItem",
  CellTags->"Hicks59"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. J. Hinch. ",
  StyleBox["Perturbation Methods", "TI"],
  ", Cambridge University Press, Cambridge, 1991. "
}], "BibliographyItem",
  CellTags->"Hinch91"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Hlushchuk, S. Russ. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0307054 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Hlushchuk03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Hobiki, K. Yakubo, T. Nakayama. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 52, R1310 (1995). "
}], "BibliographyItem",
  CellTags->"Hobiki95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Hobiki, K. Yakubo, T. Nakayama. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 54, 1997 (1996). "
}], "BibliographyItem",
  CellTags->"Hobiki96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. D. Holm, J. E. Marsden. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0312048 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Holm03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. D. Holm, M. F. Staley. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 308, 437 (2003). "
}], "BibliographyItem",
  CellTags->"Holm03b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Homolya, C. F. Osborne, I. D. Svalbe. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 67, 026211 (2003). "
}], "BibliographyItem",
  CellTags->"Homolya03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Homolya. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 318, 380 (2003). "
}], "BibliographyItem",
  CellTags->"Homolya03b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Horvat, T. Prosen. ",
  StyleBox["J. Phys.", "TI"],
  " A 36, 4015 (2003). "
}], "BibliographyItem",
  CellTags->"Horvat03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Horvat, T. Prosen. ",
  StyleBox["Prog. Theor. Phys.", "TI"],
  " S 150, 348 (2003). "
}], "BibliographyItem",
  CellTags->"Horvat03b"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  X.\[Hyphen]G. Hu, T.\[Hyphen]S. Ho, H. Rabitz. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 61, 2074 (2000). "
}], "BibliographyItem",
  CellTags->"Hu00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  X. Huang, W. L. Schaich. ",
  StyleBox["Am. J. Phys.", "TI"],
  " 72, 1232 (2004). "
}], "BibliographyItem",
  CellTags->"Huang04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Hyouguchi, R. Seto, M. Ueda, S. Adachi. ",
  StyleBox["Ann. Phys.", "TI"],
  " 312, 177 (2004). "
}], "BibliographyItem",
  CellTags->"Hyouguchi04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  V. K. Ignatovich. ",
  StyleBox["Phys. Lett.", "TI"],
  " A 322, 36 (2004). "
}], "BibliographyItem",
  CellTags->"Ignatovich04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. Jacoboni, P. Bordone. ",
  StyleBox["Rep. Prog. Phys.", "TI"],
  " 67, 1033 (2004). "
}], "BibliographyItem",
  CellTags->"Jacoboni04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Jakobson, M. Levitin, N. Nadirashvili, I. Polterovich. ",
  StyleBox["arXiv:math.SP", "TI"],
  "/0409154 (2004).   ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Jakobson04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Jacquod, I. Adagideli, C. W. J. Beenakker. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0203052 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Jacquod02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Jordan, M. Srednicki. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0112139 (2001).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Jordan01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. C. Joshi. ",
  StyleBox["J. Math. Phys.", "TI"],
  " 16, 389 (1975). "
}], "BibliographyItem",
  CellTags->"Joshi75"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Kalhous, L. Sk\[AAcute]la, J. Zamastil, J. \
\[CapitalCHacek]\[IAcute]zek. ",
  StyleBox["Int. J. Quant. Chem.", "TI"],
  " 99, 325 (2004). "
}], "BibliographyItem",
  CellTags->"Kalhous04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Kallunki, J. Krug. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 62, 6229 (2000). "
}], "BibliographyItem",
  CellTags->"Kallunki00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Z. P. Karkuszewski, J. Zakrzewski, W. H. Zurek. ",
  StyleBox["arXiv:nlin.CD", "TI"],
  "/0012048 (2000).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Karkuszewski00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Kenfack, K. Zyczkowski. ",
  StyleBox["J. Opt.", "TI"],
  " B 6, 396 (2004). "
}], "BibliographyItem",
  CellTags->"Kenfack04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  K.\[Hyphen]J. Kim, R. Cools, L. G. Ixaru. ",
  StyleBox["Appl. Num. Math.", "TI"],
  " 46, 59 (2003). "
}], "BibliographyItem",
  CellTags->"Kim03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. W. Knowles, M. L. McCarthy. ",
  StyleBox["J. Phys.", "TI"],
  " A 37, 8193 (2004). "
}], "BibliographyItem",
  CellTags->"Knowles04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. E. Knuth. ",
  StyleBox["The Art of Computer Programming", "TI"],
  ", v. 2, Addison\[Hyphen]Wesley, Reading, 1969. "
}], "BibliographyItem",
  CellTags->"Knuth69"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. J. Koch, M. Meinhardt. ",
  StyleBox["Rev. Mod. Phys.", "TI"],
  " 66, 1481 (1994). "
}], "BibliographyItem",
  CellTags->"Koch94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Kokubun. ",
  StyleBox["Phys. Rev.", "TI"],
  " D 57, 2610 (1998). "
}], "BibliographyItem",
  CellTags->"Kokubun98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D.\[Hyphen]X. Kong. ",
  StyleBox["Europhys. Lett.", "TI"],
  " 66, 617 (2004). "
}], "BibliographyItem",
  CellTags->"Kong04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. von Koppenfels, F. Stallmann. ",
  StyleBox["Praxis der konformen Abbildung", "TI"],
  ", Springer\[Hyphen]Verlag, Berlin, 1959."
}], "BibliographyItem",
  CellTags->"Koppenfels59"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. K\[ODoubleDot]stadt, M. Liu. ",
  StyleBox["Phys. Rev.", "TI"],
  " D 62, 023003 (2000). "
}], "BibliographyItem",
  CellTags->"Kostadt00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. L. Krapivsky, S. Redner. ",
  StyleBox["arXiv:physics", "TI"],
  "/0304036 (2003).    ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Krapivsky03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Krug. ",
  StyleBox["Physica", "TI"],
  " A 313, 47 (2002). "
}], "BibliographyItem",
  CellTags->"Krug02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. R. Kuttler, V. G. Sigillito. ",
  StyleBox["SIAM Review", "TI"],
  " 26, 163 (1984). "
}], "BibliographyItem",
  CellTags->"Kuttler84"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H. M. Lai, C. W. Kwok, Y. W. Loo, B. Y. Xu. ",
  StyleBox["Phys. Rev.", "TI"],
  " 62, 7330 (2000). "
}], "BibliographyItem",
  CellTags->"Lai00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J.\[Hyphen]E. Lane, R.M\[AE]land. ",
  StyleBox["J. Theor. Politics", "TI"],
  " 7, 223 (1995). "
}], "BibliographyItem",
  CellTags->"Lane95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  O. E. Lanford. ",
  StyleBox["Bull. Am. Math. Soc.", "TI"],
  " 6, 427 (1982)."
}], "BibliographyItem",
  CellTags->"Lanford82"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. L. Lapidus, J. W. Neuberger, R. J. Renka, C. A. Griffith. ",
  StyleBox["Int. J. Bifurc. Chaos", "TI"],
  " 6, 1185 (1996). "
}], "BibliographyItem",
  CellTags->"Lapidus96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Le Berre, E. Ressayre, A. Tallet, Y. Pomeau, L. Di Menza. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 66, 026203 (2003). "
}], "BibliographyItem",
  CellTags->"LeBerre02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. H. Lee. ",
  StyleBox["J. Math. Phys.", "TI"],
  " 36, 1217 (1995). "
}], "BibliographyItem",
  CellTags->"Lee95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. H. Lee. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 54, 946 (1996). "
}], "BibliographyItem",
  CellTags->"Lee96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. H. Lee. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 55, 1518 (1997). "
}], "BibliographyItem",
  CellTags->"Lee97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. H. Lee, J. Kim. ",
  StyleBox["Physica", "TI"],
  " A 304, 421 (2002). "
}], "BibliographyItem",
  CellTags->"Lee02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. P. S. Lemos, R. Kerner. ",
  StyleBox["arXiv:hep-th", "TI"],
  "/9907187 (1999).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Lemos99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Lesne. ",
  StyleBox["Renormalization Methods", "TI"],
  ", Wiley, Chichester, 1998. "
}], "BibliographyItem",
  CellTags->"Lesne98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Z. Liu, T. Qian. ",
  StyleBox["Int. J. Bifurc. Chaos.", "TI"],
  " 11, 781 (2001). "
}], "BibliographyItem",
  CellTags->"Liu01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. C. L\[OAcute]pez, P. Paz. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 68, 052305 (2003). "
}], "BibliographyItem",
  CellTags->"Lopez03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. L\[OAcute]pez. ",
  StyleBox["Ann. Phys.", "TI"],
  " 251, 372 (1991)."
}], "BibliographyItem",
  CellTags->"Lopez91"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. L\[OAcute]pez. ",
  StyleBox["Rev. Mex. Fis.", "TI"],
  " 48, 10 (2002)."
}], "BibliographyItem",
  CellTags->"Lopez02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. Lopuszanski. ",
  StyleBox["The Inverse Variational Problem in Classical Mechanics", "TI"],
  ", World Scientific, Singapore, 1999."
}], "BibliographyItem",
  CellTags->"Lopuszanski99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Lorente. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0401051 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Lorente04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Lou, C. Chen, X. Tang. ",
  StyleBox["J. Math. Phys.", "TI"],
  " 43, 4078 (2002). "
}], "BibliographyItem",
  CellTags->"Lou02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. Loutsenko. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0210018 (2002).    ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Loutsenko02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. Loutsenko. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0304008 (2003).    ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Loutsenko03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  L. Y. Lu, Z. H. Lu. ",
  StyleBox["J. Sound Vibr.", "TI"],
  " 272, 55 (2004). "
}], "BibliographyItem",
  CellTags->"Lu04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. T. Lu, J. B. Sokoloff, S. Sridhar. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 69, 026604 (2004). "
}], "BibliographyItem",
  CellTags->"Lu04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  O. Lyubomudrov. M. Edelman, G. M. Zalavsky. ",
  StyleBox["Int. J. Mod. Phys.", "TI"],
  " B 17, 4149 (2003). "
}], "BibliographyItem",
  CellTags->"Lyubomudrov03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. A. MacMahon. ",
  StyleBox["Collected Papers: Combinatorics", "TI"],
  " v.1, MIT Press, 1978."
}], "BibliographyItem",
  CellTags->"MacMahon78"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. T. Maitra. ",
  StyleBox["J. Chem. Phys.", "TI"],
  " 112, 531 (2000). "
}], "BibliographyItem",
  CellTags->"Maitra00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. Malhotra, N. S. Namachchivaya, R. J. McDonald. ",
  StyleBox["J. Nonlin. Sci.", "TI"],
  " 12, 1 (2002). "
}], "BibliographyItem",
  CellTags->"Malhotra02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Marder. ",
  StyleBox["arXiv:math.NT", "TI"],
  "/0405446 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Marder04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Mattila. ",
  StyleBox["Geometry of Sets and Measures in Euclidean Spaces", "TI"],
  ", Cambridge University Press, Cambridge, 1995. "
}], "BibliographyItem",
  CellTags->"Mattila95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. J. McCartin. ",
  StyleBox["Int. J. Math. Math. Sc.", "TI"],
  " 16, 807 (2004). "
}], "BibliographyItem",
  CellTags->"McCartin04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. W. McDonald, A. N. Kaufman. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 37, 3067 (1988). "
}], "BibliographyItem",
  CellTags->"McDonald88"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. B. Menski. ",
  StyleBox["Usp. Fiz. Nauk", "TI"],
  " 173, 1199 (2003). "
}], "BibliographyItem",
  CellTags->"Menski03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Monteoliva, J. P. Paz. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 85, 3373 (2000). "
}], "BibliographyItem",
  CellTags->"Monteoliva00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. Monteoliva, J. P. Paz. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 64, 056238 (2001). "
}], "BibliographyItem",
  CellTags->"Monteoliva01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. J. Morales\[Dash]Ruiz. ",
  StyleBox["Rep. Math. Phys.", "TI"],
  " 48, 183 (2001). "
}], "BibliographyItem",
  CellTags->"MoralesRuiz01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. B. Muratov, V. V. Osipov. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 54, 4860 (1996). "
}], "BibliographyItem",
  CellTags->"Muratov96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. B. Muratov, V. V. Osipov. ",
  StyleBox["Eur. J. Phys.", "TI"],
  " B 22, 213 (2001). "
}], "BibliographyItem",
  CellTags->"Muratov01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Netrusov, Y. Safarov. ",
  StyleBox["arXiv:math.SP", "TI"],
  "/0310093 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Netrusov03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. M. Nieto. ",
  StyleBox["J. Math. Phys.", "TI"],
  " 11, 1346 (1970). "
}], "BibliographyItem",
  CellTags->"Nieto70"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  D. W. Noid, M. L. Koszylowski, M. Tabor, R. A. Marcus. ",
  StyleBox["J. Chem. Phys.", "TI"],
  " 72, 6169 (1980). "
}], "BibliographyItem",
  CellTags->"Noid80"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Novaes, M. A. M. de Aguiar, J. E. M. Hornos. ",
  StyleBox["J. Phys.", "TI"],
  " A 36, 5773 (2003). "
}], "BibliographyItem",
  CellTags->"Novaes03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. F. Nye. ",
  StyleBox["J. Opt.", "TI"],
  " A 5, 503 (2003). "
}], "BibliographyItem",
  CellTags->"Nye03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. F. O\[CloseCurlyQuote]Connell. ",
  StyleBox["J. Opt.", "TI"],
  " B 5, S349 (2003). "
}], "BibliographyItem",
  CellTags->"O'Connell03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Okada, A. Shudo, T. Harayama, S. Tasaki. ",
  StyleBox["Prog. Theor. Phys.", "TI"],
  " S 150, 397 (2003). "
}], "BibliographyItem",
  CellTags->"Okada03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. Ota, I. Ohba. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0308154 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Ota03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. Parekh, V. R. Kumar, B. D. Kulkarni. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 52, 5100 (1995). "
}], "BibliographyItem",
  CellTags->"Parekh95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. K. Pattanayak, W. C. Schieve. ",
  StyleBox["Phys. Rev.", "TI"],
  " A 46, 1821 (1992). "
}], "BibliographyItem",
  CellTags->"Pattanayak92"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. K. Pattanyak, B. Sundaram, B. J. Greenbaum. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 90, 014103 (2003). "
}], "BibliographyItem",
  CellTags->"Pattanyak03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C. Pennetta, L. Reggiani, G. Tref\[AAcute]n, E. Alfinito. ",
  StyleBox["arXiv:cond-mat", "TI"],
  "/0202268 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"HyperlinkReturn"]
}], "BibliographyItem",
  CellTags->"Pennetta02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. A. Porras. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 58, 1086 (1998). "
}], "BibliographyItem",
  CellTags->"Porras98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. A. Porras, R. Borghi, M. Santarsierso. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 62, 5729 (2000). "
}], "BibliographyItem",
  CellTags->"Porras00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Prosen. ",
  StyleBox["Nonlin. Phenomena in Complex Syst.", "TI"],
  " 3, 260 (2000). "
}], "BibliographyItem",
  CellTags->"Prosen00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. A. Pullen, A. R. Edmonds. ",
  StyleBox["J. Phys.", "TI"],
  " A 14, L319 (1981). "
}], "BibliographyItem",
  CellTags->"Pullen81"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Radozycki. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/041115 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Radozycki04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. N. Rasband. ",
  StyleBox["Chaotic Dynamics of Nonlinear Systems", "TI"],
  ", Wiley, New York, 1990. "
}], "BibliographyItem",
  CellTags->"Rasband90"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. N. Reynolds, J. E. Pearson, S. Ponce\[Dash]Dawson. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 72, 2797 (1994). "
}], "BibliographyItem",
  CellTags->"Reynolds94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. N. Reynolds, J. E. Pearson, S. Ponce\[Dash]Dawson. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 56, 185 (1997). "
}], "BibliographyItem",
  CellTags->"Reynolds97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. Rivin. ",
  StyleBox["arXiv:math.PR", "TI"],
  "/0305252 (2003).    ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Rivin03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Russ, B. Sapoval, O. Haeberl\[EAcute]. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 55, 1413 (1997). "
}], "BibliographyItem",
  CellTags->"Russ97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Russ. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 64, 056240 (2001). "
}], "BibliographyItem",
  CellTags->"Russ01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Russ, B. Sapoval. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 65, 036614 (2002). "
}], "BibliographyItem",
  CellTags->"Russ02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Sakajo. ",
  StyleBox["Eur. J. Appl. Math.", "TI"],
  " 15, 39 (2004). "
}], "BibliographyItem",
  CellTags->"Sakajo04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Sapoval. ",
  StyleBox["Physica", "TI"],
  " D 38, 296 (1989). "
}], "BibliographyItem",
  CellTags->"Sapoval89"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Sapoval, T. Gobron, A. Margolina. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 67, 2974 (1991). "
}], "BibliographyItem",
  CellTags->"Sapoval91"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Sapoval, T. Gobron. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 47, 3013 (1993). "
}], "BibliographyItem",
  CellTags->"Sapoval93"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  B. Sapoval, O. Haeberle, S. Russ. ",
  StyleBox["J. Acoust. Soc. Am.", "TI"],
  " 102, 2014 (1997). "
}], "BibliographyItem",
  CellTags->"Sapoval97"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. G. M. Schmidt, B. K. Cheng, M. G. E. da Luz. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0211193 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Schmidt02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  K. W. Schwarz. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 38, 2398 (1988). "
}], "BibliographyItem",
  CellTags->"Schwarz88"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Scott. ",
  StyleBox["Nonlinear Science", "TI"],
  ", Oxford University Press, Oxford, 2003. "
}], "BibliographyItem",
  CellTags->"Scott03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  T. Shigehara. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 50, 4357 (1994). "
}], "BibliographyItem",
  CellTags->"Shigehara94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. G. Silvestrov, C. W. J. Beenakker. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 65, 035208 (2002). "
}], "BibliographyItem",
  CellTags->"Silvestrov02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. G. Silvestrov, J. Tworzydlo, C. W. J. Beenakker. ",
  StyleBox["Phys. Rev. ", "TI"],
  "E 67, 025204 (2003). "
}], "BibliographyItem",
  CellTags->"Silvestrov03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. N. Sneddon. ",
  StyleBox["Mixed Boundary Value Problems in Potential Theory", "TI"],
  ", North Holland, Amsterdam, 1966."
}], "BibliographyItem",
  CellTags->"Sneddon66"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. \[CapitalSHacek]ol\[IAcute]n, K. Segeth, I. Dolezel. ",
  StyleBox["Higher\[Hyphen]Order Finite Element Methods", "TI"],
  ", Chapman Hall, Boca Raton, 2004. "
}], "BibliographyItem",
  CellTags->"Solin04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Sridhar, A. Kudrolli. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 72, 2175 (1994). "
}], "BibliographyItem",
  CellTags->"Sridhar94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  I. Stakgold. ",
  StyleBox["Quart. J. Math.", "TI"],
  " 8, 169 (1950). "
}], "BibliographyItem",
  CellTags->"Stakgold50"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  O. Stenull, H.\[Hyphen]K. Janssen. ",
  StyleBox["arXiv:cond-mat", "TI"],
  "/0305217 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"HyperlinkReturn"]
}], "BibliographyItem",
  CellTags->"Stenull03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  J. P. Straley. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 39, 4531 (1989). "
}], "BibliographyItem",
  CellTags->"Straley89"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Takahashi, J. \[CapitalCHacek]\[IAcute]zek, J. Paldus. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 33, 1203 (1986)."
}], "BibliographyItem",
  CellTags->"Takahashi86"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  X. Tang, S. Lou, Y. Zhang. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 66, 046601 (2002). "
}], "BibliographyItem",
  CellTags->"Tang02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  F. Toscana, M. A. M. de Aguiar, A. M. O. de Almeida. ",
  StyleBox["Phys. Rev. Lett.", "TI"],
  " 86, 59 (2001). "
}], "BibliographyItem",
  CellTags->"Toscana01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Trzetrzelewski, J. Wosiek. ",
  StyleBox["arXiv:hep-th", "TI"],
  "/0308007 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Trzetrzelewski03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. Tsubota, T. Araki, S. K. Nemirovskii. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 62, 11751 (2000). "
}], "BibliographyItem",
  CellTags->"Tsubota00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. Ujevi\[CAcute], A. J. Roberts. ",
  StyleBox["arXiv:math.NA", "TI"],
  "/0303342 (2003).    ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Ujevic03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Y. Vernov. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0203003 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Vernov02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. Y. Vernov. ",
  StyleBox["arXiv:math-ph", "TI"],
  "/0312048 (2003).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Vernov03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  M. I. Vigo\[Dash]Aguiar, M. E. Sansaturio, J. M. Ferrandiz. ",
  StyleBox["J. Comput. Appl. Math.", "TI"],
  " 158, 213 (2003). "
}], "BibliographyItem",
  CellTags->"VigoAguiar03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  E. B. Vul, Y. G. Sinai, K. M. Khanin. ",
  StyleBox["Russian Math. Surv.", "TI"],
  " 39, 1 (1984). "
}], "BibliographyItem",
  CellTags->"Vul84"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  P. Walker. ",
  StyleBox["Proc. R. Soc. Lond.", "TI"],
  " 459, 2569 (2003). "
}], "BibliographyItem",
  CellTags->"Walker03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Y. C. Wang, R. S. Lakes. ",
  StyleBox["Am. J. Phys.", "TI"],
  " 72, 40 (2004). "
}], "BibliographyItem",
  CellTags->"Wang04"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. L. J. Wells, R. E. Overill. ",
  StyleBox["Int. J. Bifurc. Chaos", "TI"],
  " 4, 1041 (1994). "
}], "BibliographyItem",
  CellTags->"Wells94"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  N. M. Wigley. ",
  StyleBox["Am. Math. Monthly", "TI"],
  " 79, 1107 (1972). "
}], "BibliographyItem",
  CellTags->"Wigley72"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  A. Wirzba. ",
  StyleBox["Phys. Rep.", "TI"],
  " 309, 1 (1999). "
}], "BibliographyItem",
  CellTags->"Wirzba99"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  C.\[Hyphen]Y. Wong. ",
  StyleBox["arXiv:quant-ph", "TI"],
  "/0210112 (2002).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Wong02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H. Wu, D. W. L. Sprung, J. Martorell. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 51, 703 (1995). "
}], "BibliographyItem",
  CellTags->"Wu95"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  Z. Yosibash, M. Arad, A. Yakhot, G. Ben-Dor. ",
  StyleBox["Num. Methods Partial Diff. Eq.", "TI"],
  " 14, 281 (1998). "
}], "BibliographyItem",
  CellTags->"Yosibash98"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  H. Q. Yuan, U. Grimm, P. Repetowicz, M. Schreiber. ",
  StyleBox["Phys. Rev.", "TI"],
  " B 62, 15569 (2000). "
}], "BibliographyItem",
  CellTags->"Yuan00"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  G. Zanzatto. ",
  StyleBox["Acta Cryst.", "TI"],
  " A 52, 839 (1996). "
}], "BibliographyItem",
  CellTags->"Zanzatto96"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  S. M. Zeyman. ",
  StyleBox["Proc. Am. Math. Soc.", "TI"],
  " 95, 83 (1985). "
}], "BibliographyItem",
  CellTags->"Zeyman85"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. M. Ziff, J. M. Kincaid. ",
  StyleBox["J. Math. Phys.", "TI"],
  " 21, 161 (1980)."
}], "BibliographyItem",
  CellTags->"Ziff80"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  R. W. Ziolkowski, E. Heyman. ",
  StyleBox["Phys. Rev.", "TI"],
  " E 64, 056625 (2001). "
}], "BibliographyItem",
  CellTags->"Ziolkowski01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. H. Zurek. ",
  StyleBox["Nature", "TI"],
  " 412, 712 (2001). "
}], "BibliographyItem",
  CellTags->"Zurek01"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. H. Zurek. ",
  StyleBox["Los Alamos Sc.", "TI"],
  " n 27, 2 (2002). "
}], "BibliographyItem",
  CellTags->"Zurek02"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  W. H. Zurek. ",
  StyleBox["Rev. Mod. Phys.", "TI"],
  " 75, 715 (2003). "
}], "BibliographyItem",
  CellTags->"Zurek03"],

Cell[TextData[{
  ButtonBox["\[SixPointedStar]",
    ButtonStyle->"HyperlinkReturn"],
  
  CounterBox["BibliographyCounter"],
  "  K. Zyczkowski, W. Slomczynski. ",
  StyleBox["arXiv:cond-mat", "TI"],
  "/0405396 (2004).  ",
  ButtonBox["Get Preprint",
    ButtonStyle->"ArXivLink"]
}], "BibliographyItem",
  CellTags->"Zyczkowski04"]
}, Closed]]
},
FrontEndVersion->"5.0 for X",
ScreenRectangle->{{0, 1280}, {0, 1024}},
NotebookAutoSave->False,
AutoGeneratedPackage->None,
ScreenStyleEnvironment->"Reading",
PrintingStyleEnvironment->"Printout",
InitializationCellEvaluation->True,
InitializationCellWarning->False,
WindowSize->{600, 700},
WindowMargins->{{135, Automatic}, {Automatic, 33}},
PrintingPageRange->{Automatic, Automatic},
PageHeaders->{{Cell[ 
        TextData[ {
          CounterBox[ "Page"]}], "PageNumber"], Inherited, Cell[ 
        TextData[ {"Printed from the additions to THE", 
          StyleBox[ "MATHEMATICA", FontSlant -> "Italic"], " GUIDEBOOK"}], 
        "PageHeader"]}, {Cell[ 
        TextData[ {"CONCEPTS, EXAMPLES AND APPLICATIONS"}], "PageHeader"], 
      Inherited, Cell[ 
        TextData[ {
          CounterBox[ "Page"]}], "PageNumber"]}},
PageFooters->{{Inherited, Cell[ 
        TextData[ {"\[Copyright]   2004 Michael Trott"}], "PageFooter"], 
      Inherited}, {Inherited, Cell[ 
        TextData[ {"\[Copyright]   2004 Michael Trott"}], "PageFooter"], 
      Inherited}},
PageFooterLines->{True, True},
PrivateNotebookOptions->{"ShortBoxForm"->False},
ShowSelection->True,
CellLabelAutoDelete->False,
Magnification->1,
StyleDefinitions -> Notebook[{
  
  Cell[CellGroupData[{
  Cell[TextData[{
    "Style Definitions for\n",
    StyleBox["The Mathematica",
      FontSlant->"Italic"],
    " ",
    StyleBox["GuideBooks \n",
      FontSlant->"Italic"],
    "(",
    StyleBox["to Programming",
      FontSlant->"Italic"],
    ", ",
    StyleBox["Graphics",
      FontSlant->"Italic"],
    ", ",
    StyleBox["Numerics",
      FontSlant->"Italic"],
    ", and ",
    StyleBox["Symbolics",
      FontSlant->"Italic"],
    ")",
    StyleBox[" \n",
      FontSlant->"Italic"],
    "by Michael Trott (\[Copyright]  Springer\[Hyphen]Verlag, New York, \
2004)"
  }], "Subtitle"],
  
  Cell[CellGroupData[{
  
  Cell["Style Environment Names", "Subsubsection"],
  
  Cell[TextData[{
    "The three styles available for the electronic version of the ",
    StyleBox["Mathematica",
      FontSlant->"Italic"],
    " ",
    StyleBox["GuideBooks",
      FontSlant->"Italic"],
    " are ",
    StyleBox["Reading",
      FontWeight->"Bold"],
    ", ",
    StyleBox["AllBrackets",
      FontWeight->"Bold"],
    ", and ",
    StyleBox["Printout",
      FontWeight->"Bold"],
    ". ",
    StyleBox["Reading",
      FontWeight->"Bold"],
    " is recommended for reading the ",
    StyleBox["GuideBooks",
      FontSlant->"Italic"],
    ", ",
    StyleBox["AllBrackets",
      FontWeight->"Bold"],
    " is recommended style for working with the notebooks, such as \
annotating, adding, modifying and evaluating inputs and deleting outputs. ",
    StyleBox["Printing",
      FontWeight->"Bold"],
    " is recommended for making printouts.\n(The printed books were also \
generated directly from the notebooks using a more elaborate stylesheet that \
uses more fonts, different spacings, alignments and so on.)"
  }], "Text"],
  
  Cell[StyleData[All, "Reading"],
    PageWidth->WindowWidth,
    CellBracketOptions->{"Color"->GrayLevel[1]},
    ScriptMinSize->9],
  
  Cell[StyleData[All, "AllBrackets"],
    PageWidth->WindowWidth,
    ShowCellBracket->True,
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    ScriptMinSize->9],
  
  Cell[StyleData[All, "Printout"],
    PageWidth->PaperWidth,
    ScriptMinSize->5,
    PrivateFontOptions->{"FontType"->"Outline"}]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell["Notebook options", "Subsubsection"],
  
  Cell["\<\
The options defined for the style below will be used at the \
Notebook level.  \
\>", "Text"],
  
  Cell[StyleData["Notebook"],
    PageHeaders->{{Cell[ 
            TextData[ {
              CounterBox[ "Page"]}], "PageNumber"], None, Cell[ 
            TextData[ {"Printed from ", 
              StyleBox[ 
              "THE MATHEMATICA GUIDEBOOKS", FontSlant -> "Italic"]}], 
            "PageHeader"]}, {Cell[ 
            TextData[ {
              StyleBox[ "THE MATHEMATICA GUIDEBOOKS", FontSlant -> "Italic"], 
              " to PROGRAMMING\[LongDash]GRAPHICS\[LongDash]NUMERICS\
\[LongDash]SYMBOLICS"}], "PageHeader"], None, Cell[ 
            TextData[ {
              CounterBox[ "Page"]}], "PageNumber"]}},
    PageFooters->{{None, Cell[ 
            
            TextData[ {
              "\[Copyright]  2004   Springer\[Hyphen]Verlag New York, Inc."}],
             "PageFooter"], None}, {None, Cell[ 
            
            TextData[ {
              "\[Copyright]  2004   Springer\[Hyphen]Verlag New York, Inc."}],
             "PageFooter"], None}},
    PageHeaderLines->{True, True},
    PageFooterLines->{True, True},
    PrintingOptions->{"FirstPageHeader"->False,
    "FacingPages"->True},
    CellLabelAutoDelete->False,
    DefaultNewCellStyle->"ReaderInput",
    AutoItalicWords->{
      "Mathematica", "MathLink", "MathSource", "MathReader", "MathScript", 
        "GuideBook", "GuideBooks", "Arxiv"},
    StyleMenuListing->None]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Menu shortcut queue", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Text"],
    CellMargins->{{12, 4}, {2, 14}},
    CellHorizontalScrolling->True,
    TextJustification->1,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["Text", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Input"],
    PageWidth->800,
    CellMargins->{{60, 4}, {2, 6}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    CellLabelMargins->{{11, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    CounterIncrements->"Input",
    FontWeight->"Bold"],
  
  Cell[StyleData["Input", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[StyleData["CodeComment"],
    CellMargins->{{12, 4}, {0, 8}},
    CellHorizontalScrolling->True,
    ShowSpecialCharacters->Automatic,
    FontFamily->"Times",
    FontWeight->"Plain",
    FontColor->GrayLevel[0.299992]],
  
  Cell[StyleData["MR"],
    Hyphenation->True,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    FontFamily->"Courier",
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["TI"],
    Hyphenation->True,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    FontFamily->"Times",
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SolutionSubgroup"],
    CellMargins->{{12, 4}, {2, 14}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->0},
    CellGroupingRules->{"SectionGrouping", 40},
    CellHorizontalScrolling->True,
    TextJustification->1,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["SolutionSubgroup", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReaderAnnotation"],
    CellFrame->{{6, 0}, {0, 0}},
    CellMargins->{{60, 4}, {2, 14}},
    CellBracketOptions->{"Thickness"->2,
    "Color"->RGBColor[0, 0.299992, 0.299992]},
    CellHorizontalScrolling->True,
    CellFrameColor->RGBColor[0, 0.299992, 0.299992],
    CellFrameLabels->{{
      Cell[ "\[WarningSign]", "Text", FontColor -> RGBColor[ 
            0, 0.29999199999999998, 0.29999199999999998]], Inherited}, {
        Inherited, Inherited}},
    TextJustification->1,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["ReaderAnnotation", "Reading"],
    CellMargins->{{2, 0}, {0, 8}},
    CellBracketOptions->{"Color"->GrayLevel[1]}],
  
  Cell[StyleData["ReaderAnnotation", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Program"],
    CellMargins->{{31, 24}, {2, 2}},
    CellHorizontalScrolling->True,
    Hyphenation->False,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FontFamily->"Courier"],
  
  Cell[StyleData["Program", "Printout"],
    CellMargins->{{8, Inherited}, {Inherited, Inherited}},
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReaderInput"],
    PageWidth->800,
    CellFrame->{{6, 0}, {0, 0}},
    CellMargins->{{60, 4}, {2, 6}},
    CellBracketOptions->{"Thickness"->2,
    "Color"->RGBColor[0, 0.299992, 0.299992]},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    CellLabelMargins->{{11, Inherited}, {Inherited, Inherited}},
    CellFrameColor->RGBColor[0, 0.299992, 0.299992],
    CellFrameLabels->{{
      Cell[ "\[LightBulb]", "Text", FontColor -> RGBColor[ 
            0, 0.29999199999999998, 0.29999199999999998]], Inherited}, {
        Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    CounterIncrements->"Input",
    FontWeight->"Bold"],
  
  Cell[StyleData["ReaderInput", "Printout"],
    FontSize->9.5]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Headings", "Subsubsection"],
  
  Cell["\<\
The style \"SolutionSubgroup\" is  style Alt 7 in the menu \
shortcut queue.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["VolumeLabel"],
    CellMargins->{{12, 0}, {0, 0}},
    CellFrameMargins->{{8, 8}, {0, 6}},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Bold",
    FontColor->RGBColor[0, 0.6, 0.4],
    Background->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["VolumeLabel", "Printout"],
    CellMargins->{{2, 16}, {-1, 0}},
    PageBreakBelow->False,
    CellFrameMargins->{{8, 8}, {0, 6}},
    FontSize->10,
    FontColor->GrayLevel[0.700008],
    Background->GrayLevel[0.300008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ContentsVolumeLabel"],
    CellFrame->0.5,
    CellMargins->{{12, 0}, {4, 24}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->12},
    CellGroupingRules->{"SectionGrouping", 8},
    CellFrameMargins->{{8, 8}, {6, 6}},
    CellFrameColor->RGBColor[0, 0.500008, 0.4],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Bold",
    FontColor->RGBColor[0.300008, 0.6, 0.4]],
  
  Cell[StyleData["ContentsVolumeLabel", "Printout"],
    CellMargins->{{2, 0}, {0, 20}},
    PageBreakBelow->False,
    CellFrameMargins->{{12, 8}, {6, 6}},
    CellFrameColor->GrayLevel[0.500008],
    FontSize->10,
    FontColor->GrayLevel[0.300008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ChapterNumber"],
    CellMargins->{{12, 0}, {4, 0}},
    CellFrameMargins->{{8, 0}, {8, 36}},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->36,
    FontWeight->"Bold",
    FontSlant->"Italic",
    FontColor->GrayLevel[1],
    Background->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["ChapterNumber", "Printout"],
    CellMargins->{{2, 8}, {0, 0}},
    PageBreakBelow->False,
    FontSize->24,
    Background->GrayLevel[0.300008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Chapter"],
    CellFrame->{{0, 0}, {0.5, 0}},
    CellMargins->{{12, 4}, {16, 12}},
    CellFrameMargins->{{0, 0}, {36, 0}},
    CellFrameColor->RGBColor[0, 0.4, 0],
    FontFamily->"Helvetica",
    FontSize->42],
  
  Cell[StyleData["Chapter", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    CellFrameMargins->{{0, 0}, {24, 0}},
    CellFrameColor->GrayLevel[0],
    FontSize->32]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Section"],
    CellMargins->{{12, 4}, {2, 48}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->12},
    CellGroupingRules->{"SectionGrouping", 10},
    ParagraphIndent->-24,
    FontFamily->"Helvetica",
    FontSize->20,
    FontWeight->"Bold",
    FontSlant->"Italic",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["Section", "Printout"],
    CellMargins->{{2, 0}, {0, 42}},
    PageBreakBelow->False,
    ParagraphIndent->-18,
    FontSize->18,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SectionSpacer"],
    CellMargins->{{12, 4}, {-6, 10}},
    CellGroupingRules->{"SectionGrouping", 10},
    FontSize->12],
  
  Cell[StyleData["SectionSpacer", "Printout"],
    CellMargins->{{2, 0}, {0, 5}}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subsection"],
    CellDingbat->"\[FilledSquare]",
    CellMargins->{{26, 4}, {6, 26}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellGroupingRules->{"SectionGrouping", 20},
    CellFrameLabelMargins->6,
    FontFamily->"Helvetica",
    FontSize->16,
    FontWeight->"Bold"],
  
  Cell[StyleData["Subsection", "Printout"],
    CellMargins->{{16, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->14]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["MSUB1"],
    FontFamily->"Courier",
    FontSize->13],
  
  Cell[StyleData["MSUB1", "Printout"],
    FontSize->11]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Subsubsection"],
    CellMargins->{{12, 4}, {2, 18}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->18},
    CellGroupingRules->{"SectionGrouping", 30},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold"],
  
  Cell[StyleData["Subsubsection", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ExerciseHeading"],
    CellMargins->{{12, 4}, {2, 12}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->6},
    CellGroupingRules->{"SectionGrouping", 30},
    ParagraphIndent->-33,
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["ExerciseHeading", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ExerciseSubgroup"],
    CellMargins->{{12, 4}, {2, 14}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->0},
    CellGroupingRules->{"SectionGrouping", 40},
    CellHorizontalScrolling->True,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["ExerciseSubgroup", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SolutionHeading"],
    CellMargins->{{12, 4}, {2, 12}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->6},
    CellGroupingRules->{"SectionGrouping", 30},
    ParagraphIndent->-23,
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["SolutionHeading", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["EXNUM"],
    FontSize->12,
    FontWeight->"Bold",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["EXNUM", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ExerciseSpacer"],
    CellMargins->{{12, 4}, {2, 10}},
    CellGroupingRules->{"SectionGrouping", 30},
    CellHorizontalScrolling->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8},
    FontSize->12],
  
  Cell[StyleData["ExerciseSpacer", "Printout"],
    CellMargins->{{2, 0}, {0, 5}}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["OldAndNewInputs"],
    CellGroupingRules->{"SectionGrouping", 60},
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold",
    FontColor->GrayLevel[0.299992]],
  
  Cell[StyleData["OldAndNewInputs", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10,
    FontColor->GrayLevel[0.299992]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["OverviewSection"],
    CellMargins->{{12, 4}, {12, 36}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->16},
    CellGroupingRules->{"SectionGrouping", 10},
    CellFrameMargins->6,
    FontFamily->"Helvetica",
    FontSize->16,
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    Background->GrayLevel[0.100008]],
  
  Cell[StyleData["OverviewSection", "Printout"],
    CellMargins->{{2, 6}, {8, 28}},
    PageBreakBelow->False,
    FontSize->14]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ExercisesSection"],
    CellMargins->{{12, 100}, {12, 20}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->-6},
    CellGroupingRules->{"SectionGrouping", 10},
    CellFrameMargins->6,
    FontFamily->"Helvetica",
    FontSize->16,
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    Background->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["ExercisesSection", "Printout"],
    CellMargins->{{2, 100}, {8, 28}},
    PageBreakBelow->False,
    FontSize->14,
    Background->GrayLevel[0.300008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SolutionsSection"],
    CellMargins->{{12, 200}, {12, 36}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->-6},
    CellGroupingRules->{"SectionGrouping", 10},
    CellFrameMargins->6,
    FontFamily->"Helvetica",
    FontSize->16,
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    Background->RGBColor[0, 0.500008, 0.300008]],
  
  Cell[StyleData["SolutionsSection", "Printout"],
    CellMargins->{{2, 200}, {8, 28}},
    PageBreakBelow->False,
    FontSize->14,
    Background->GrayLevel[0.4]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReferencesSection"],
    CellMargins->{{12, 200}, {12, 36}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->10},
    CellGroupingRules->{"SectionGrouping", 10},
    CellFrameMargins->6,
    FontFamily->"Helvetica",
    FontSize->16,
    FontWeight->"Bold",
    FontSlant->"Italic",
    FontColor->GrayLevel[1],
    Background->RGBColor[0.4, 0.700008, 0.500008]],
  
  Cell[StyleData["ReferencesSection", "Printout"],
    CellMargins->{{2, 200}, {8, 28}},
    PageBreakBelow->False,
    FontSize->14,
    Background->GrayLevel[0.500008]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Text", "Subsubsection"],
  
  Cell["\<\
The frequently used style \"Text\" is style Alt 1 in the menu \
shortcut queue.
The frequently used style \"ReaderAnnotation\" is style Alt 7 in the menu \
shortcut queue.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ItemizedText"],
    CellMargins->{{12, 4}, {4, 4}},
    LineSpacing->{1, 3},
    ParagraphSpacing->{0, 6},
    ParagraphIndent->-16,
    CounterIncrements->"ItemizedText"],
  
  Cell[StyleData["ItemizedText", "Printout"],
    ParagraphIndent->-13,
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["PrintText"],
    ShowCellBracket->True,
    CellMargins->{{12, 4}, {2, 12}},
    CellGroupingRules->{"OutputGrouping", 10},
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    StyleMenuListing->None],
  
  Cell[StyleData["PrintText", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["PrivateAuthorComment"],
    CellFrame->{{6, 0}, {0, 0}},
    CellMargins->{{20, 4}, {2, 14}},
    CellBracketOptions->{"Thickness"->3,
    "Color"->RGBColor[1, 0.500008, 0]},
    CellHorizontalScrolling->True,
    CellFrameColor->RGBColor[1, 0.500008, 0],
    TextJustification->1,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["PrivateAuthorComment", "Reading"],
    CellMargins->{{10, 0}, {0, 8}},
    CellBracketOptions->{"Color"->GrayLevel[1]}],
  
  Cell[StyleData["PrivateAuthorComment", "Printout"],
    CellMargins->{{10, 0}, {0, 8}},
    FontSize->10]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Inline Formatting", "Subsubsection"],
  
  Cell["\<\
The frequently used style \"MR\" is  style Alt 4 in the menu \
shortcut queue.
The frequently used style \"TI\" is  style Alt 5 in the menu shortcut \
queue.\
\>", "Text"],
  
  Cell[StyleData["InlineFormula"],
    CellMargins->{{10, 4}, {0, 8}},
    CellHorizontalScrolling->True,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    ScriptLevel->1,
    SingleLetterItalics->True,
    SpanMaxSize->Infinity,
    FontFamily->"Times",
    GridBoxOptions->{ColumnWidths->Automatic}],
  
  Cell[StyleData["TR"],
    Hyphenation->True,
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Plain",
    FontSlant->"Plain"],
  
  Cell[StyleData["TB"],
    Hyphenation->True,
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["TBI"],
    Hyphenation->True,
    StyleMenuListing->None,
    FontFamily->"Times",
    FontWeight->"Bold",
    FontSlant->"Italic"],
  
  Cell[StyleData["MO"],
    Hyphenation->True,
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Plain",
    FontSlant->"Italic"],
  
  Cell[StyleData["MB"],
    Hyphenation->True,
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontWeight->"Bold",
    FontSlant->"Plain"],
  
  Cell[StyleData["IT"],
    StyleMenuListing->None,
    FontSlant->"Italic"],
  
  Cell[StyleData["ContentsItemDingbat"],
    CellSize->{37, 14},
    TextAlignment->Right,
    StyleMenuListing->None],
  
  Cell[StyleData["ContentsSubItemDingbat"],
    CellSize->{44, 13},
    TextAlignment->Right,
    StyleMenuListing->None]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Emphasis Boxes and Pictures", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ItemizedNoteBox"],
    CellFrame->{{12, 0}, {0, 0}},
    CellMargins->{{13, 71}, {2, 10}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{6, 6}, {3, 3}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    LineSpacing->{1.2, 1},
    StyleMenuListing->None,
    Background->RGBColor[0.700008, 0.900008, 0.700008]],
  
  Cell[StyleData["ItemizedNoteBox", "Printout"],
    CellFrame->{{9, 0}, {0, 0}},
    CellMargins->{{13, 71}, {2, 10}},
    CellFrameMargins->{{4, 4}, {3, 3}},
    CellFrameColor->GrayLevel[0.300008],
    FontSize->10,
    Background->GrayLevel[0.900008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["DescriptionTop"],
    CellFrame->{{0.5, 0.5}, {0, 3}},
    CellMargins->{{12, 65}, {-1, 7}},
    CellElementSpacings->{"CellMinHeight"->5},
    CellHorizontalScrolling->True,
    CellFrameMargins->False,
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    FontSize->5],
  
  Cell[StyleData["DescriptionTop", "Printout"],
    CellFrame->{{0.5, 0.5}, {0, 3}},
    CellMargins->{{2, 65}, {-1, 7}},
    CellElementSpacings->{"CellMinHeight"->5},
    CellFrameColor->GrayLevel[0],
    FontSize->5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["DescriptionBottom"],
    CellFrame->{{0.5, 0.5}, {0.5, 0}},
    CellMargins->{{12, 65}, {0, -7}},
    CellElementSpacings->{"CellMinHeight"->6},
    CellHorizontalScrolling->True,
    CellFrameMargins->3,
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    FontSize->6],
  
  Cell[StyleData["DescriptionBottom", "Printout"],
    CellMargins->{{2, 65}, {0, -7}},
    CellFrameColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["MathDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    PageBreakBelow->False,
    CellFrameMargins->{{10, 10}, {3, 5}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ParagraphSpacing->{0, 8},
    FontFamily->"Courier",
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["MathDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -1}},
    CellFrameColor->GrayLevel[0],
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["TopTextDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{10, 10}, {3, 5}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["TopTextDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -1}},
    CellFrameColor->GrayLevel[0],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["TextDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{49, 10}, {9, 3}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    FontFamily->"Times",
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["TextDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -1}},
    CellFrameMargins->{{24, 10}, {7, 2}},
    CellFrameColor->GrayLevel[0],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndentDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{49, 10}, {2, 3}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Plain",
    FontColor->RGBColor[0, 0.300008, 0.2],
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["IndentDescription", "Printout"],
    CellMargins->{{2, 65}, {-1, -1}},
    CellFrameMargins->{{24, 10}, {2, 3}},
    CellFrameColor->GrayLevel[0],
    FontSize->8,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndentTextDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{76, 10}, {8, 2}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["IndentTextDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -2}},
    CellFrameMargins->{{44, 10}, {6, 2}},
    CellFrameColor->GrayLevel[0],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["CenteredDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, 0}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{24, 10}, {6, 0}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    FontFamily->"Times",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["CenteredDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -1}},
    CellFrameMargins->{{24, 10}, {7, 2}},
    CellFrameColor->GrayLevel[0],
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["RemarkSubsection"],
    CellMargins->{{12, 4}, {2, 24}},
    FontFamily->"Helvetica",
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    Background->RGBColor[0, 0.500008, 0.300008]],
  
  Cell[StyleData["RemarkSubsection", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10,
    Background->GrayLevel[0.300008]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["RemarkOutMarker"],
    CellFrame->{{0, 0}, {8, 0}},
    CellMargins->{{12, 4}, {6, 2}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    FontSize->2],
  
  Cell[StyleData["RemarkOutMarker", "Printout"],
    CellFrame->{{0, 0}, {5, 0}},
    CellMargins->{{2, 0}, {0, 8}},
    PageBreakAbove->False,
    CellFrameColor->GrayLevel[0.300008]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Hyperlinks and Buttons", "Subsubsection"],
  
  Cell["\<\
The cells below define styles useful for making hypertext \
ButtonBoxes.  The \"Hyperlink\" style is for links within the same Notebook, \
or between Notebooks. \
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Hyperlink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["Hyperlink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReferenceHyperlink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->GrayLevel[0.2],
    FontVariations->{"Underline"->False},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["ReferenceHyperlink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ContentsLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0.4, 0.6],
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["ContentsLink", "AllBrackets"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0.4, 0.6],
    ButtonBoxOptions->{ButtonFunction:>Function[ {x, y}, 
        CompoundExpression[ 
          NotebookLocate[ y]]],
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["ContentsLink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ShowAnimationButton"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->9,
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonMinHeight->1.3,
    Background->RGBColor[0, 0.300008, 0.2],
    ButtonNote->None}],
  
  Cell[StyleData["ShowAnimationButton", "Printout"],
    FontSize->2,
    FontColor->GrayLevel[1],
    ButtonBoxOptions->{ButtonMinHeight->0.5,
    ButtonFrame->"None",
    Background->GrayLevel[1]}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["HyperlinkReturn"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>FrontEndExecute[ {
        FrontEnd`FrontEndToken[ "HyperlinkGoBack"]}],
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["HyperlinkReturn", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReferenceHyperlinkReturn"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->GrayLevel[0.2],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>FrontEndExecute[ {
        FrontEnd`FrontEndToken[ "HyperlinkGoBack"]}],
    Active->True,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["ReferenceHyperlinkReturn", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ArXivLink"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontSlant->"Italic",
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{
    ButtonFunction:>(
      Module[ {cell, aux1, aux2, buttons, nbData, newNB, 
        removeBeginningWhiteSpace}, 
        CompoundExpression[ 
          Set[ cell, 
            CompoundExpression[ 
              SelectionMove[ 
                ButtonNotebook[ ], All, ButtonCell], 
              NotebookRead[ 
                ButtonNotebook[ ]]]], 
          SetDelayed[ 
            removeBeginningWhiteSpace[ 
              Pattern[ string, 
                Blank[ ]]], 
            With[ {
              Set[ aux, 
                Part[ 
                  Split[ 
                    Characters[ string]], 1]]}, 
              If[ 
                SameQ[ 
                  Part[ aux, 1], " "], 
                StringDrop[ string, 
                  Length[ aux]], string]]], 
          Set[ aux1, 
            Cases[ cell, 
              Blank[ TextData], Infinity]], 
          Set[ aux2, 
            ReplaceAll[ 
              Part[ aux1, 1], TextData[ {
                BlankNullSequence[ ], 
                StyleBox[ 
                  Pattern[ subject, 
                    Blank[ ]], "TI"], 
                Pattern[ number, 
                  Blank[ ]], 
                BlankNullSequence[ ]}] :> StringReplace[ 
                StringJoin[ "/abs/", 
                  StringDrop[ subject, 6], 
                  StringTake[ number, 8]], "\[Dash]" -> "-"]]], 
          Set[ buttons, 
            Flatten[ {
              StyleBox[ 
                StringDrop[ aux2, 5], "TI", FontWeight -> "Bold"], 
              Apply[ 
                Function[ {y, z}, 
                  ButtonBox[ y, ButtonData -> {
                    URL[ z], None}, ButtonStyle -> "Hyperlink"]], 
                Map[ 
                  Function[ x, {
                    Part[ x, 1], 
                    StringJoin[ 
                      Part[ x, 2], aux2]}], {{"USA", "http://arXiv.org"}, {
                  "Australia", "http://au.arXiv.org"}, {"Brazil", 
                  "http://br.arXiv.org"}, {"China", "http://cn.arXiv.org"}, {
                  "France", "http://fr.arXiv.org"}, {"Germany", 
                  "http://de.arXiv.org"}, {"India", "http://in.arXiv.org"}, {
                  "Israel", "http://il.arXiv.org"}, {"Italy", 
                  "http://it.arXiv.org"}, {"Japan", "http://jp.arXiv.org"}, {
                  "Russia", "http://ru.arXiv.org"}, {"South Africa", 
                  "http://za.arXiv.org"}, {"South Korea", 
                  "http://kr.arXiv.org"}, {"Spain", "http://es.arXiv.org"}, {
                  "Taiwan", "http://tw.arXiv.org"}, {"U.K.", 
                  "http://uk.arXiv.org"}}], {1}], 
              ButtonBox[ 
                StyleBox[ "Close", FontWeight -> "Bold"], ButtonFunction :> 
                NotebookClose[ 
                  ButtonNotebook[ ]], ButtonEvaluator -> None, Active -> 
                True]}]], 
          Set[ newNB, 
            Notebook[ {
              Cell[ 
                BoxData[ 
                  GridBox[ 
                    Map[ List, buttons], RowSpacings -> 0.0, RowLines -> 
                    True]], "NotebookDefault", PageBreakAbove -> True, 
                FontFamily -> "Times", FontWeight -> "Plain"]}, Editable -> 
              False, WindowSize -> {Fit, Fit}, WindowTitle -> "ArXiv-Palette",
               WindowFrame -> "Palette", WindowFrameElements -> {}, 
              WindowElements -> {}, WindowClickSelect -> False, WindowTitle -> 
              None, ShowCellBracket -> False, CellMargins -> {{0.0, 0.0}, {
              0.0, 0.0}}, Active -> True, ShowCellLabel -> False, Background -> 
              GrayLevel[ 0.80000000000000004], Magnification -> 1.0]], 
          NotebookPut[ newNB]]]&),
    ButtonEvaluator->Automatic,
    Active->True,
    ButtonStyle->"Hyperlink",
    ButtonSource->Cell,
    ButtonFrame->"None",
    ButtonNote->ButtonData}],
  
  Cell[StyleData["ArXivLink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[StyleData["ArxivLinkStyle"],
    FontSlant->"Italic"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReferenceInstance"],
    StyleMenuListing->None,
    ButtonStyleMenuListing->Automatic,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonFrame->"None",
    ButtonNote->None}],
  
  Cell[StyleData["ReferenceInstance", "Printout"],
    FontColor->GrayLevel[1]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ReferenceInstanceArrowStyle"],
    StyleMenuListing->None,
    FontColor->RGBColor[0, 0, 1],
    Background->GrayLevel[1],
    FontVariations->{"Underline"->False}],
  
  Cell[StyleData["ReferenceInstanceArrowStyle", "Printout"],
    FontColor->GrayLevel[1]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["RefGuideLink"],
    StyleMenuListing->None,
    FontFamily->"Courier",
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "RefGuideLink", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["RefGuideLink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["GettingStartedLink"],
    StyleMenuListing->None,
    FontColor->RGBColor[0, 0, 1],
    FontVariations->{"Underline"->True},
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`HelpBrowserLookup[ "GettingStarted", #]}]&),
    Active->True,
    ButtonFrame->"None"}],
  
  Cell[StyleData["GettingStartedLink", "Printout"],
    FontColor->GrayLevel[0],
    FontVariations->{"Underline"->False}]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Input", "Subsubsection"],
  
  Cell["\<\
The frequently used style \"Input\" is style Alt 2 in the menu \
shortcut queue.
The frequently used style \"ReaderInput\" is style Alt 9 in the menu shortcut \
queue.
The frequently used style \"CodeComment\" is  style Alt 3 in the menu \
shortcut queue.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["StandardFormInput"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {2, 6}},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    CellLabelAutoDelete->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    ShowSpecialCharacters->True,
    FormatType->StandardForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    FontWeight->"Bold"],
  
  Cell[StyleData["StandardFormInput", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["RigidStandardFormInput"],
    PageWidth->Infinity,
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {2, 6}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    CellHorizontalScrolling->True,
    CellLabelAutoDelete->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    ShowSpecialCharacters->True,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    LanguageCategory->"Mathematica",
    FormatType->StandardForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    LineBreakWithin->False,
    FontWeight->"Bold"],
  
  Cell[StyleData["RigidStandardFormInput", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["SaveAndQuit"],
    PageWidth->800,
    CellMargins->{{50, 4}, {2, 6}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.6, 0.6]},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    CellLabelMargins->{{11, Inherited}, {Inherited, Inherited}},
    CellFrameLabels->{{
      Cell[ "\[CircleTimes]", "Text", FontColor -> RGBColor[ 
            0, 0.59999999999999998, 0.59999999999999998]], Inherited}, {
        Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    CounterIncrements->"Input",
    FontWeight->"Bold"],
  
  Cell[StyleData["SaveAndQuit", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Open  ]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Output/Print/Messages/Graphics", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Output"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {6, 2}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellEditDuplicate->True,
    CellGroupingRules->"OutputGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    CellLabelAutoDelete->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->StandardForm],
  
  Cell[StyleData["Output", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Message"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"OutputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    StyleMenuListing->None,
    FontSize->10,
    FontColor->RGBColor[0, 0.2, 0.6]],
  
  Cell[StyleData["Message", "Printout"],
    ShowCellBracket->False,
    FontSize->9,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Print"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"OutputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    FormatType->InputForm,
    StyleMenuListing->None],
  
  Cell[StyleData["Print", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Graphics"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"GraphicsGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    DefaultFormatType->DefaultFormatTypeForOutput,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    ImageSize->{Automatic, 200},
    StyleMenuListing->None,
    FontWeight->"Plain"],
  
  Cell[StyleData["Graphics", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Open  ]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["CellLabel"],
    StyleMenuListing->None,
    FontSize->9,
    FontWeight->"Plain",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["CellLabel", "Printout"],
    FontSize->6,
    FontColor->GrayLevel[0]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Equations and Formulas", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["DisplayFormula"],
    CellMargins->{{70, 4}, {2, 10}},
    CellHorizontalScrolling->True,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    ScriptLevel->0,
    SingleLetterItalics->True,
    SpanMaxSize->Infinity,
    StyleMenuListing->None,
    UnderoverscriptBoxOptions->{LimitsPositioning->True},
    GridBoxOptions->{ColumnWidths->Automatic,
    ColumnAlignments->{Left, Center}}],
  
  Cell[StyleData["DisplayFormula", "Printout"],
    CellMargins->{{34, Inherited}, {Inherited, Inherited}},
    FontSize->10]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Programs", "Subsubsection"],
  
  Cell["\<\
The frequently used style \"Program\" is style Alt 8 in the menu \
shortcut queue.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ProgramLabel"],
    CellFrame->{{0.5, 0.5}, {0, 0.5}},
    CellMargins->{{24, 24}, {2, 8}},
    PageBreakBelow->False,
    GroupPageBreakWithin->False,
    CellFrameMargins->{{6, 6}, {2, 3}},
    CellFrameColor->RGBColor[0, 0.300008, 0.2],
    LineSpacing->{1, 1},
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Bold"],
  
  Cell[StyleData["ProgramLabel", "Printout"],
    CellMargins->{{2, 0}, {2, 2}},
    FontSize->8]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ProgramBottom"],
    CellFrame->{{0.5, 0.5}, {0.5, 0}},
    CellMargins->{{24, 24}, {8, 2}},
    CellElementSpacings->{"CellMinHeight"->4},
    PageBreakAbove->False,
    CellFrameMargins->3,
    CellFrameColor->RGBColor[0, 0.300008, 0.2],
    FontSize->4],
  
  Cell[StyleData["ProgramBottom", "Printout"],
    CellMargins->{{2, 0}, {2, 2}}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ProgramButton"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->9,
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    ButtonBoxOptions->{ButtonFunction:>FrontEndExecute[ {
        FrontEnd`SelectionMove[ 
          ButtonNotebook[ ], All, ButtonCell], 
        FrontEnd`SelectionMove[ 
          ButtonNotebook[ ], Next, Cell], 
        FrontEnd`FrontEndToken[ 
          InputNotebook[ ], "Style", "Input"]}],
    Active->True,
    ButtonMinHeight->1.3,
    Background->RGBColor[0, 0.300008, 0.2],
    ButtonNote->None}],
  
  Cell[StyleData["ProgramButton", "Printout"],
    FontSize->2,
    FontColor->GrayLevel[1],
    ButtonBoxOptions->{ButtonMinHeight->0.5,
    ButtonFrame->"None",
    Background->GrayLevel[1]}]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Bibliography", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BibliographyItem"],
    CellMargins->{{12, 4}, {2, 12}},
    CellHorizontalScrolling->True,
    ParagraphSpacing->{0, 8},
    ParagraphIndent->-36,
    CounterIncrements->"BibliographyCounter",
    StyleMenuListing->None],
  
  Cell[StyleData["BibliographyItem", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Page Headers and Footers", "Subsubsection"],
  
  Cell[StyleData["PageHeader"],
    CellMargins->{{0, 0}, {2, 0}},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->7],
  
  Cell[StyleData["PageNumber"],
    CellMargins->{{0, 0}, {2, 0}},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->7,
    FontWeight->"Bold"],
  
  Cell[StyleData["PageFooter"],
    CellMargins->{{84, 84}, {2, 2}},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Chapter Overview Styles", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["Command"],
    CellMargins->{{13, 85}, {0, 12}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{10, 10}, {3, 5}},
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    FontFamily->"Courier",
    FontWeight->"Bold",
    FontColor->GrayLevel[1],
    Background->RGBColor[0, 0.500008, 0.300008]],
  
  Cell[StyleData["Command", "Printout"],
    CellMargins->{{2, 85}, {0, 8}},
    FontSize->9.5,
    Background->GrayLevel[0.4]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndentMathDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -6}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{72, 10}, {6, 0}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    FontFamily->"Courier",
    Background->GrayLevel[0.999893],
    GridBoxOptions->{ColumnWidths->{0.7, 0.3},
    ColumnAlignments->{Left}}],
  
  Cell[StyleData["IndentMathDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -6}},
    CellFrameMargins->{{44, 10}, {5, 0}},
    CellFrameColor->GrayLevel[0],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["TextDescription"],
    CellFrame->{{0.5, 0.5}, {0, 0}},
    CellMargins->{{12, 65}, {0, -1}},
    CellHorizontalScrolling->True,
    CellFrameMargins->{{49, 10}, {9, 3}},
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8},
    Background->GrayLevel[0.999893]],
  
  Cell[StyleData["TextDescription", "Printout"],
    CellMargins->{{2, 65}, {0, -1}},
    CellFrameMargins->{{24, 10}, {7, 2}},
    CellFrameColor->GrayLevel[0],
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["DescriptionBottom"],
    CellFrame->{{0.5, 0.5}, {0.5, 0}},
    CellMargins->{{12, 65}, {0, -7}},
    CellElementSpacings->{"CellMinHeight"->6},
    CellHorizontalScrolling->True,
    CellFrameMargins->3,
    CellFrameColor->RGBColor[0, 0.500008, 0.300008],
    FontSize->6],
  
  Cell[StyleData["DescriptionBottom", "Printout"],
    CellMargins->{{2, 65}, {0, -7}},
    CellFrameColor->GrayLevel[0]]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["BackChapter Styles", "Subsubsection"],
  
  Cell["\<\
The cells in this section define styles used in the solutions of \
the exercises. They are modifications of the corresponding styles from above, \
using in general smaller font sizes.\
\>", "Text"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterText"],
    CellMargins->{{12, 4}, {2, 14}},
    CellHorizontalScrolling->True,
    TextJustification->1,
    Hyphenation->True,
    LineSpacing->{1.2, 1},
    ParagraphSpacing->{0, 8},
    FontSize->12],
  
  Cell[StyleData["BackChapterText", "Printout"],
    CellMargins->{{2, 0}, {0, 8}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterItemizedText"],
    CellMargins->{{12, 4}, {4, 4}},
    LineSpacing->{1, 3},
    ParagraphSpacing->{0, 6},
    ParagraphIndent->-16,
    CounterIncrements->"ItemizedText"],
  
  Cell[StyleData["BackChapterItemizedText", "Printout"],
    ParagraphIndent->-13,
    FontSize->8]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterInput"],
    PageWidth->Infinity,
    CellMargins->{{60, 4}, {2, 6}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    Evaluatable->True,
    CellGroupingRules->"InputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    CellLabelMargins->{{11, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultInputFormatType,
    Hyphenation->True,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    AutoItalicWords->{},
    LanguageCategory->"Formula",
    FormatType->InputForm,
    ShowStringCharacters->True,
    NumberMarks->True,
    CounterIncrements->"Input",
    FontWeight->"Bold"],
  
  Cell[StyleData["BackChapterInput", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterOutput"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {6, 2}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellEditDuplicate->True,
    CellGroupingRules->"OutputGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    CellLabelAutoDelete->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    HyphenationOptions->{"HyphenationCharacter"->"\[Continuation]"},
    LanguageCategory->"Formula",
    FormatType->StandardForm],
  
  Cell[StyleData["BackChapterOutput", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterPrint"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"OutputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    FormatType->InputForm,
    StyleMenuListing->None],
  
  Cell[StyleData["BackChapterPrint", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterGraphics"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"GraphicsGrouping",
    CellHorizontalScrolling->True,
    PageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    DefaultFormatType->DefaultOutputFormatType,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    FontWeight->"Plain"],
  
  Cell[StyleData["BackChapterGraphics", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterDisplayFormula"],
    CellMargins->{{70, 4}, {2, 10}},
    CellHorizontalScrolling->True,
    ScriptLevel->0,
    SingleLetterItalics->True,
    SpanMaxSize->Infinity,
    UnderoverscriptBoxOptions->{LimitsPositioning->True},
    GridBoxOptions->{ColumnWidths->Automatic,
    ColumnAlignments->{Left, Center}}],
  
  Cell[StyleData["BackChapterDisplayFormula", "Printout"],
    CellMargins->{{34, Inherited}, {Inherited, Inherited}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterProgram"],
    CellMargins->{{31, 24}, {2, 2}},
    CellHorizontalScrolling->True,
    Hyphenation->False,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    StyleMenuListing->None,
    FontFamily->"Courier"],
  
  Cell[StyleData["BackChapterProgram", "Printout"],
    CellMargins->{{8, Inherited}, {Inherited, Inherited}},
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterPrintText"],
    ShowCellBracket->True,
    CellMargins->{{12, 4}, {2, 12}},
    CellGroupingRules->{"OutputGrouping", 10},
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    StyleMenuListing->None],
  
  Cell[StyleData["BackChapterPrintText", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterMessage"],
    ShowCellBracket->True,
    CellMargins->{{60, 4}, {4, 2}},
    CellGroupingRules->"OutputGrouping",
    PageBreakWithin->False,
    GroupPageBreakWithin->False,
    GeneratedCell->True,
    CellAutoOverwrite->True,
    ShowCellLabel->False,
    CellLabelMargins->{{14, Inherited}, {Inherited, Inherited}},
    DefaultFormatType->DefaultOutputFormatType,
    LanguageCategory->None,
    SpellingOptions->{"AlwaysStop"->{}},
    FormatType->InputForm,
    StyleMenuListing->None,
    FontColor->GrayLevel[0.500008]],
  
  Cell[StyleData["BackChapterMessage", "Printout"],
    ShowCellBracket->False,
    FontSize->9.5,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterProgramLabel"],
    CellFrame->{{0.5, 0.5}, {0, 0.5}},
    CellMargins->{{24, 24}, {2, 8}},
    PageBreakBelow->False,
    GroupPageBreakWithin->False,
    CellFrameMargins->{{6, 6}, {2, 3}},
    CellFrameColor->RGBColor[0, 0.300008, 0.2],
    LineSpacing->{1, 1},
    FontFamily->"Helvetica",
    FontSize->10,
    FontWeight->"Bold"],
  
  Cell[StyleData["BackChapterProgramLabel", "Printout"],
    CellMargins->{{2, 0}, {2, 6}},
    FontSize->8]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterProgramBottom"],
    CellFrame->{{0.5, 0.5}, {0.5, 0}},
    CellMargins->{{24, 24}, {8, 2}},
    CellElementSpacings->{"CellMinHeight"->4},
    PageBreakAbove->False,
    CellFrameMargins->3,
    CellFrameColor->RGBColor[0, 0.300008, 0.2],
    FontSize->4],
  
  Cell[StyleData["BackChapterProgramBottom", "Printout"],
    CellMargins->{{2, 0}, {2, 6}}]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterExerciseSubgroup"],
    CellMargins->{{12, 4}, {12, 12}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->0},
    CellGroupingRules->{"SectionGrouping", 40},
    CellHorizontalScrolling->True,
    ShowSpecialCharacters->Automatic,
    ParagraphSpacing->{0, 8}],
  
  Cell[StyleData["BackChapterExerciseSubgroup", "Printout"],
    CellMargins->{{2, 0}, {7, 7}},
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterExerciseHeading"],
    CellMargins->{{12, 4}, {2, 12}},
    CellBracketOptions->{"Color"->RGBColor[0, 0.300008, 0.700008]},
    CellElementSpacings->{"ClosedGroupTopMargin"->6},
    CellGroupingRules->{"SectionGrouping", 30},
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["BackChapterExerciseHeading", "Printout"],
    CellMargins->{{2, 0}, {0, 18}},
    PageBreakBelow->False,
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["BackChapterMSUB1"],
    FontFamily->"Courier",
    FontSize->13],
  
  Cell[StyleData["BackChapterMSUB1", "Printout"],
    FontSize->11]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Special styles used in the Table of Content", "Subsubsection"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["CHP"],
    FontSize->24,
    FontWeight->"Plain"],
  
  Cell[StyleData["CHP", "Printout"],
    FontSize->18,
    FontWeight->"Plain"]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["NUMCT"],
    FontSize->16,
    FontWeight->"Bold",
    FontSlant->"Italic",
    FontTracking->"Plain",
    FontColor->RGBColor[0, 0.300008, 0.2]],
  
  Cell[StyleData["NUMCT", "Printout"],
    FontSize->14,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["CHPCT"],
    FontSize->12,
    FontWeight->"Plain",
    FontSlant->"Italic",
    FontTracking->"Plain",
    FontColor->RGBColor[0, 0.300008, 0.2],
    FontVariations->{"Underline"->False,
    "Outline"->False,
    "Shadow"->False}],
  
  Cell[StyleData["CHPCT", "Printout"],
    FontSize->10,
    FontColor->GrayLevel[0]]
  }, Closed]],
  
  Cell[StyleData["BLT"],
    StyleMenuListing->None,
    FontSize->7,
    FontColor->RGBColor[0, 0.4, 0.6]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ContentsItem"],
    CellMargins->{{125, 4}, {2, 2}},
    CellElementSpacings->{"ClosedGroupTopMargin"->6},
    CellGroupingRules->{"SectionGrouping", 30},
    ParagraphIndent->-45,
    FontFamily->"Helvetica",
    FontSize->12,
    FontWeight->"Bold"],
  
  Cell[StyleData["ContentsItem", "Printout"],
    CellMargins->{{114, 0}, {0, 2}},
    PageBreakBelow->False,
    ParagraphIndent->-38,
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ContentsSubItem"],
    CellMargins->{{170, 4}, {2, 2}},
    CellElementSpacings->{"ClosedGroupTopMargin"->18},
    CellGroupingRules->{"SectionGrouping", 40},
    ParagraphIndent->-45,
    FontSize->12],
  
  Cell[StyleData["ContentsSubItem", "Printout"],
    CellMargins->{{150, 0}, {0, 2}},
    PageBreakBelow->False,
    ParagraphIndent->-38,
    FontSize->10]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["ContentsLinkList"],
    CellMargins->{{208, 4}, {2, 0}},
    CellElementSpacings->{"ClosedGroupTopMargin"->18},
    CellGroupingRules->{"SectionGrouping", 40},
    ParagraphIndent->0,
    FontFamily->"Helvetica",
    FontSize->9],
  
  Cell[StyleData["ContentsSubItem", "Printout"],
    CellMargins->{{150, 0}, {0, 2}},
    PageBreakBelow->False,
    ParagraphIndent->-38,
    FontSize->10]
  }, Closed]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell["Special styles used in the Index", "Subsubsection"],
  
  Cell[StyleData["IndexHead"],
    ShowGroupOpenCloseIcon->True,
    CellMargins->{{28, 4}, {2, 2}},
    CellElementSpacings->{"ClosedGroupTopMargin"->4},
    CellGroupingRules->{"SectionGrouping", 20},
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->14,
    FontWeight->"Bold"],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndexButton"],
    StyleMenuListing->None,
    FontFamily->"Helvetica",
    FontSize->11,
    FontWeight->"Bold",
    FontColor->RGBColor[1, 1, 0.8],
    ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
        FrontEnd`NotebookLocate[ #2]}]&),
    Active->True,
    ButtonMinHeight->1.3,
    ButtonFrame->"Palette",
    Background->RGBColor[0, 0.300008, 0.2],
    ButtonNote->ButtonData}],
  
  Cell[StyleData["IndexButton", "Printout"]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndexButtonBar"],
    CellMargins->{{10, 0}, {18, 2}},
    Evaluatable->False,
    CellGroupingRules->{"SectionGrouping", 20},
    CellFrameColor->RGBColor[0, 0.100008, 0.500008],
    StyleMenuListing->None],
  
  Cell[StyleData["IndexButtonBar", "Printout"]]
  }, Closed]],
  
  Cell[CellGroupData[{
  
  Cell[StyleData["IndexEntry"],
    CellMargins->{{30, 4}, {1, 1}},
    CellHorizontalScrolling->True,
    LineSpacing->{1, 0},
    ParagraphIndent->-60,
    FontSize->12],
  
  Cell[StyleData["IndexEntry", "Printout"],
    CellMargins->{{2, 0}, {1, 0}},
    FontSize->10]
  }, Closed]]
  }, Closed]]
  }, Open  ]]
  }]
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{
  "Index[09, Chladny figures]"->{
    Cell[77538, 2304, 469, 13, 70, "Text",
      CellTags->{
      "Index[09, Chladny figures]", "Index[09, {figures, Chladny ~}]", 
        "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"}]},
  "Index[09, {figures, Chladny ~}]"->{
    Cell[77538, 2304, 469, 13, 70, "Text",
      CellTags->{
      "Index[09, Chladny figures]", "Index[09, {figures, Chladny ~}]", 
        "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"}]},
  "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"->{
    Cell[77538, 2304, 469, 13, 70, "Text",
      CellTags->{
      "Index[09, Chladny figures]", "Index[09, {figures, Chladny ~}]", 
        "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"}]},
  "T[D[Vibrating Gosper Curve]]"->{
    Cell[634074, 18157, 724, 12, 70, "Text",
      CellTags->{
      "T[D[Vibrating Gosper Curve]]", "Index[12, {Gosper, curve}]", 
        "Index[12, {springs, along a Gosper curve}]"}]},
  "Index[12, {Gosper, curve}]"->{
    Cell[634074, 18157, 724, 12, 70, "Text",
      CellTags->{
      "T[D[Vibrating Gosper Curve]]", "Index[12, {Gosper, curve}]", 
        "Index[12, {springs, along a Gosper curve}]"}]},
  "Index[12, {springs, along a Gosper curve}]"->{
    Cell[634074, 18157, 724, 12, 70, "Text",
      CellTags->{
      "T[D[Vibrating Gosper Curve]]", "Index[12, {Gosper, curve}]", 
        "Index[12, {springs, along a Gosper curve}]"}]},
  "Index[12, {Cosper, spring chain}]"->{
    Cell[637843, 18261, 4630, 139, 70, "Text",
      CellTags->"Index[12, {Cosper, spring chain}]"]},
  "T[D[Sliding Spinning Disk]]"->{
    Cell[946158, 27222, 616, 18, 70, "Text",
      CellTags->{
      "T[D[Sliding Spinning Disk]]", 
        "Index[14, {disk, spinning and sliding ~}]"}]},
  "Index[14, {disk, spinning and sliding ~}]"->{
    Cell[946158, 27222, 616, 18, 70, "Text",
      CellTags->{
      "T[D[Sliding Spinning Disk]]", 
        "Index[14, {disk, spinning and sliding ~}]"}]},
  "T[Ref[1]]"->{
    Cell[1028001, 29420, 64, 1, 57, "ReferencesSection",
      CellTags->"T[Ref[1]]"]},
  "Abramson03"->{
    Cell[1028068, 29423, 270, 9, 70, "BibliographyItem",
      CellTags->"Abramson03"]},
  "Acedo03"->{
    Cell[1028341, 29434, 321, 11, 70, "BibliographyItem",
      CellTags->"Acedo03"]},
  "Adler78"->{
    Cell[1028665, 29447, 258, 9, 70, "BibliographyItem",
      CellTags->"Adler78"]},
  "Aguirre01"->{
    Cell[1028926, 29458, 294, 9, 70, "BibliographyItem",
      CellTags->"Aguirre01"]},
  "Aguirre03"->{
    Cell[1029223, 29469, 279, 9, 70, "BibliographyItem",
      CellTags->"Aguirre03"]},
  "Alonso03"->{
    Cell[1029505, 29480, 349, 11, 70, "BibliographyItem",
      CellTags->"Alonso03"]},
  "Angelo03"->{
    Cell[1029857, 29493, 274, 9, 70, "BibliographyItem",
      CellTags->"Angelo03"]},
  "Atakishiyev01"->{
    Cell[1030134, 29504, 302, 9, 70, "BibliographyItem",
      CellTags->"Atakishiyev01"]},
  "Atakishiyev03"->{
    Cell[1030439, 29515, 297, 9, 70, "BibliographyItem",
      CellTags->"Atakishiyev03"]},
  "Atakishiyev04"->{
    Cell[1030739, 29526, 348, 11, 70, "BibliographyItem",
      CellTags->"Atakishiyev04"]},
  "Azzam82"->{
    Cell[1031090, 29539, 264, 9, 70, "BibliographyItem",
      CellTags->"Azzam82"]},
  "Baake99"->{
    Cell[1031357, 29550, 332, 11, 70, "BibliographyItem",
      CellTags->"Baake99"]},
  "BaezDuarte03"->{
    Cell[1031692, 29563, 332, 11, 70, "BibliographyItem",
      CellTags->"BaezDuarte03"]},
  "Baker96"->{
    Cell[1032027, 29576, 316, 9, 70, "BibliographyItem",
      CellTags->"Baker96"]},
  "Balcou96"->{
    Cell[1032346, 29587, 293, 9, 70, "BibliographyItem",
      CellTags->"Balcou96"]},
  "Ballentine98"->{
    Cell[1032642, 29598, 273, 9, 70, "BibliographyItem",
      CellTags->"Ballentine98"]},
  "Baltes76"->{
    Cell[1032918, 29609, 301, 9, 70, "BibliographyItem",
      CellTags->"Baltes76"]},
  "Bajnok02"->{
    Cell[1033222, 29620, 278, 9, 70, "BibliographyItem",
      CellTags->"Bajnok02"]},
  "Barbashov67"->{
    Cell[1033503, 29631, 279, 9, 70, "BibliographyItem",
      CellTags->"Barbashov67"]},
  "Barlow90"->{
    Cell[1033785, 29642, 273, 9, 70, "BibliographyItem",
      CellTags->"Barlow90"]},
  "Barthelemy00"->{
    Cell[1034061, 29653, 318, 10, 70, "BibliographyItem",
      CellTags->"Barthelemy00"]},
  "Baruch10"->{
    Cell[1034382, 29665, 329, 10, 70, "BibliographyItem",
      CellTags->"Baruch10"]},
  "Bayfield99"->{
    Cell[1034714, 29677, 268, 9, 70, "BibliographyItem",
      CellTags->"Bayfield99"]},
  "Beaver04"->{
    Cell[1034985, 29688, 265, 9, 70, "BibliographyItem",
      CellTags->"Beaver04"]},
  "Bell70"->{
    Cell[1035253, 29699, 241, 9, 70, "BibliographyItem",
      CellTags->"Bell70"]},
  "Belloni03"->{
    Cell[1035497, 29710, 345, 11, 70, "BibliographyItem",
      CellTags->"Belloni03"]},
  "Belmonte01"->{
    Cell[1035845, 29723, 304, 9, 70, "BibliographyItem",
      CellTags->"Belmonte01"]},
  "Berezovoj03a"->{
    Cell[1036152, 29734, 352, 11, 70, "BibliographyItem",
      CellTags->"Berezovoj03a"]},
  "Berry79"->{
    Cell[1036507, 29747, 329, 9, 70, "BibliographyItem",
      CellTags->"Berry79"]},
  "Berry79b"->{
    Cell[1036839, 29758, 262, 9, 70, "BibliographyItem",
      CellTags->"Berry79b"]},
  "Besprosvany01"->{
    Cell[1037104, 29769, 261, 9, 70, "BibliographyItem",
      CellTags->"Besprosvany01"]},
  "Betchov65"->{
    Cell[1037368, 29780, 252, 9, 70, "BibliographyItem",
      CellTags->"Betchov65"]},
  "Bhattacharya02"->{
    Cell[1037623, 29791, 285, 9, 70, "BibliographyItem",
      CellTags->"Bhattacharya02"]},
  "BialnynickiBirula83"->{
    Cell[1037911, 29802, 362, 9, 70, "BibliographyItem",
      CellTags->"BialnynickiBirula83"]},
  "Blochintsev52"->{
    Cell[1038276, 29813, 262, 9, 70, "BibliographyItem",
      CellTags->"Blochintsev52"]},
  "Bode01"->{
    Cell[1038541, 29824, 313, 9, 70, "BibliographyItem",
      CellTags->"Bode01"]},
  "Bogomolny04"->{
    Cell[1038857, 29835, 326, 11, 70, "BibliographyItem",
      CellTags->"Bogomolny04"]},
  "Bolivar04"->{
    Cell[1039186, 29848, 301, 9, 70, "BibliographyItem",
      CellTags->"Bolivar04"]},
  "Borwein03"->{
    Cell[1039490, 29859, 329, 10, 70, "BibliographyItem",
      CellTags->"Borwein03"]},
  "Borwein04"->{
    Cell[1039822, 29871, 306, 9, 70, "BibliographyItem",
      CellTags->"Borwein04"]},
  "Bosanac83"->{
    Cell[1040131, 29882, 250, 9, 70, "BibliographyItem",
      CellTags->"Bosanac83"]},
  "Brack93"->{
    Cell[1040384, 29893, 287, 9, 70, "BibliographyItem",
      CellTags->"Brack93"]},
  "Brack98"->{
    Cell[1040674, 29904, 265, 9, 70, "BibliographyItem",
      CellTags->"Brack98"]},
  "Brenier04"->{
    Cell[1040942, 29915, 260, 9, 70, "BibliographyItem",
      CellTags->"Brenier04"]},
  "Breuer02"->{
    Cell[1041205, 29926, 321, 9, 70, "BibliographyItem",
      CellTags->"Breuer02"]},
  "Briggs91"->{
    Cell[1041529, 29937, 249, 9, 70, "BibliographyItem",
      CellTags->"Briggs91"]},
  "Brunelli97"->{
    Cell[1041781, 29948, 323, 11, 70, "BibliographyItem",
      CellTags->"Brunelli97"]},
  "Burchnall30"->{
    Cell[1042107, 29961, 281, 9, 70, "BibliographyItem",
      CellTags->"Burchnall30"]},
  "Buttke88"->{
    Cell[1042391, 29972, 255, 9, 70, "BibliographyItem",
      CellTags->"Buttke88"]},
  "Byron70"->{
    Cell[1042649, 29983, 315, 9, 70, "BibliographyItem",
      CellTags->"Byron70"]},
  "Camassa94"->{
    Cell[1042967, 29994, 276, 9, 70, "BibliographyItem",
      CellTags->"Camassa94"]},
  "Cametti02"->{
    Cell[1043246, 30005, 325, 11, 70, "BibliographyItem",
      CellTags->"Cametti02"]},
  "Caputo01"->{
    Cell[1043574, 30018, 280, 9, 70, "BibliographyItem",
      CellTags->"Caputo01"]},
  "Cardeso03"->{
    Cell[1043857, 30029, 293, 9, 70, "BibliographyItem",
      CellTags->"Cardeso03"]},
  "Cartwright02"->{
    Cell[1044153, 30040, 329, 11, 70, "BibliographyItem",
      CellTags->"Cartwright02"]},
  "Carvalho04"->{
    Cell[1044485, 30053, 298, 9, 70, "BibliographyItem",
      CellTags->"Carvalho04"]},
  "Casati96"->{
    Cell[1044786, 30064, 240, 9, 70, "BibliographyItem",
      CellTags->"Casati96"]},
  "CerrutiSola96"->{
    Cell[1045029, 30075, 277, 9, 70, "BibliographyItem",
      CellTags->"CerrutiSola96"]},
  "ChaosCador04"->{
    Cell[1045309, 30086, 289, 9, 70, "BibliographyItem",
      CellTags->"ChaosCador04"]},
  "Chate87"->{
    Cell[1045601, 30097, 273, 9, 70, "BibliographyItem",
      CellTags->"Chate87"]},
  "Chatteraj04"->{
    Cell[1045877, 30108, 289, 9, 70, "BibliographyItem",
      CellTags->"Chatteraj04"]},
  "Chellone71"->{
    Cell[1046169, 30119, 252, 9, 70, "BibliographyItem",
      CellTags->"Chellone71"]},
  "Christiansen90"->{
    Cell[1046424, 30130, 286, 9, 70, "BibliographyItem",
      CellTags->"Christiansen90"]},
  "Chang86"->{
    Cell[1046713, 30141, 267, 9, 70, "BibliographyItem",
      CellTags->"Chang86"]},
  "Chruscinski98"->{
    Cell[1046983, 30152, 267, 9, 70, "BibliographyItem",
      CellTags->"Chruscinski98"]},
  "Ciattoni04"->{
    Cell[1047253, 30163, 268, 9, 70, "BibliographyItem",
      CellTags->"Ciattoni04"],
    Cell[1048090, 30196, 278, 9, 70, "BibliographyItem",
      CellTags->"Ciattoni04"]},
  "Cieslinski86"->{
    Cell[1047524, 30174, 287, 9, 70, "BibliographyItem",
      CellTags->"Cieslinski86"]},
  "Chun03"->{
    Cell[1047814, 30185, 273, 9, 70, "BibliographyItem",
      CellTags->"Chun03"]},
  "Clarkson03"->{
    Cell[1048371, 30207, 273, 9, 70, "BibliographyItem",
      CellTags->"Clarkson03"]},
  "Cohen95"->{
    Cell[1048647, 30218, 286, 9, 70, "BibliographyItem",
      CellTags->"Cohen95"]},
  "Crampin99"->{
    Cell[1048936, 30229, 287, 9, 70, "BibliographyItem",
      CellTags->"Crampin99"]},
  "Crampin01"->{
    Cell[1049226, 30240, 272, 9, 70, "BibliographyItem",
      CellTags->"Crampin01"]},
  "Crampin02"->{
    Cell[1049501, 30251, 283, 9, 70, "BibliographyItem",
      CellTags->"Crampin02"]},
  "Crampin02b"->{
    Cell[1049787, 30262, 288, 9, 70, "BibliographyItem",
      CellTags->"Crampin02b"]},
  "Cuccietti02"->{
    Cell[1050078, 30273, 294, 9, 70, "BibliographyItem",
      CellTags->"Cuccietti02"]},
  "Cucchietti03"->{
    Cell[1050375, 30284, 362, 11, 70, "BibliographyItem",
      CellTags->"Cucchietti03"]},
  "Czirjak00"->{
    Cell[1050740, 30297, 305, 9, 70, "BibliographyItem",
      CellTags->"Czirjak00"]},
  "Denisov00"->{
    Cell[1051048, 30308, 256, 9, 70, "BibliographyItem",
      CellTags->"Denisov00"]},
  "DeSerio03"->{
    Cell[1051307, 30319, 250, 9, 70, "BibliographyItem",
      CellTags->"DeSerio03"]},
  "Dhar03"->{
    Cell[1051560, 30330, 343, 11, 70, "BibliographyItem",
      CellTags->"Dhar03"]},
  "Dowker04"->{
    Cell[1051906, 30343, 313, 11, 70, "BibliographyItem",
      CellTags->"Dowker04"]},
  "Driscoll97"->{
    Cell[1052222, 30356, 250, 9, 70, "BibliographyItem",
      CellTags->"Driscoll97"]},
  "Driscoll02"->{
    Cell[1052475, 30367, 322, 9, 70, "BibliographyItem",
      CellTags->"Driscoll02"]},
  "Driscoll03"->{
    Cell[1052800, 30378, 277, 9, 70, "BibliographyItem",
      CellTags->"Driscoll03"]},
  "Dubey79"->{
    Cell[1053080, 30389, 263, 9, 70, "BibliographyItem",
      CellTags->"Dubey79"]},
  "Duxbury95"->{
    Cell[1053346, 30400, 278, 9, 70, "BibliographyItem",
      CellTags->"Duxbury95"]},
  "Encinosa03"->{
    Cell[1053627, 30411, 264, 9, 70, "BibliographyItem",
      CellTags->"Encinosa03"]},
  "Encinosa04"->{
    Cell[1053894, 30422, 336, 11, 70, "BibliographyItem",
      CellTags->"Encinosa04"]},
  "Englisch91"->{
    Cell[1054233, 30435, 267, 9, 70, "BibliographyItem",
      CellTags->"Englisch91"]},
  "Ericksen84"->{
    Cell[1054503, 30446, 335, 9, 70, "BibliographyItem",
      CellTags->"Ericksen84"]},
  "Farkas03"->{
    Cell[1054841, 30457, 289, 9, 70, "BibliographyItem",
      CellTags->"Farkas03"]},
  "Feigenbaum78"->{
    Cell[1055133, 30468, 260, 9, 70, "BibliographyItem",
      CellTags->"Feigenbaum78"]},
  "Felder02"->{
    Cell[1055396, 30479, 335, 11, 70, "BibliographyItem",
      CellTags->"Felder02"]},
  "Felsenthal98"->{
    Cell[1055734, 30492, 351, 10, 70, "BibliographyItem",
      CellTags->"Felsenthal98"]},
  "Ferraro04"->{
    Cell[1056088, 30504, 252, 9, 70, "BibliographyItem",
      CellTags->"Ferraro04"]},
  "Foeldi03"->{
    Cell[1056343, 30515, 322, 10, 70, "BibliographyItem",
      CellTags->"Foeldi03"]},
  "Fornberg98"->{
    Cell[1056668, 30527, 249, 9, 70, "BibliographyItem",
      CellTags->"Fornberg98"]},
  "Fornberg99"->{
    Cell[1056920, 30538, 269, 9, 70, "BibliographyItem",
      CellTags->"Fornberg99"]},
  "Friesecke02"->{
    Cell[1057192, 30549, 267, 9, 70, "BibliographyItem",
      CellTags->"Friesecke02"]},
  "Friesecke03"->{
    Cell[1057462, 30560, 280, 9, 70, "BibliographyItem",
      CellTags->"Friesecke03"]},
  "Frisch03"->{
    Cell[1057745, 30571, 334, 11, 70, "BibliographyItem",
      CellTags->"Frisch03"]},
  "Galleani02"->{
    Cell[1058082, 30584, 264, 9, 70, "BibliographyItem",
      CellTags->"Galleani02"]},
  "Galleani02b"->{
    Cell[1058349, 30595, 267, 9, 70, "BibliographyItem",
      CellTags->"Galleani02b"]},
  "Gardiner00"->{
    Cell[1058619, 30606, 301, 9, 70, "BibliographyItem",
      CellTags->"Gardiner00"]},
  "Gaspard89"->{
    Cell[1058923, 30617, 265, 9, 70, "BibliographyItem",
      CellTags->"Gaspard89"]},
  "Gillet01"->{
    Cell[1059191, 30628, 273, 9, 70, "BibliographyItem",
      CellTags->"Gillet01"]},
  "Gladwell02"->{
    Cell[1059467, 30639, 272, 9, 70, "BibliographyItem",
      CellTags->"Gladwell02"]},
  "Goldman84"->{
    Cell[1059742, 30650, 254, 9, 70, "BibliographyItem",
      CellTags->"Goldman84"]},
  "Golovin03"->{
    Cell[1059999, 30661, 277, 9, 70, "BibliographyItem",
      CellTags->"Golovin03"]},
  "Goos47"->{
    Cell[1060279, 30672, 253, 9, 70, "BibliographyItem",
      CellTags->"Goos47"]},
  "Goos49"->{
    Cell[1060535, 30683, 265, 9, 70, "BibliographyItem",
      CellTags->"Goos49"]},
  "Greenbaum04"->{
    Cell[1060803, 30694, 354, 11, 70, "BibliographyItem",
      CellTags->"Greenbaum04"]},
  "Grosche98"->{
    Cell[1061160, 30707, 310, 9, 70, "BibliographyItem",
      CellTags->"Grosche98"]},
  "Gutierrez04"->{
    Cell[1061473, 30718, 324, 11, 70, "BibliographyItem",
      CellTags->"Gutierrez04"]},
  "Gutman04"->{
    Cell[1061800, 30731, 277, 9, 70, "BibliographyItem",
      CellTags->"Gutman04"]},
  "Habib98"->{
    Cell[1062080, 30742, 333, 11, 70, "BibliographyItem",
      CellTags->"Habib98"]},
  "Habib00"->{
    Cell[1062416, 30755, 365, 11, 70, "BibliographyItem",
      CellTags->"Habib00"]},
  "Hauswirth00"->{
    Cell[1062784, 30768, 315, 11, 70, "BibliographyItem",
      CellTags->"Hauswirth00"]},
  "Helmkamp94"->{
    Cell[1063102, 30781, 270, 9, 70, "BibliographyItem",
      CellTags->"Helmkamp94"]},
  "Hicks59"->{
    Cell[1063375, 30792, 261, 9, 70, "BibliographyItem",
      CellTags->"Hicks59"]},
  "Hinch91"->{
    Cell[1063639, 30803, 287, 9, 70, "BibliographyItem",
      CellTags->"Hinch91"]},
  "Hlushchuk03"->{
    Cell[1063929, 30814, 324, 11, 70, "BibliographyItem",
      CellTags->"Hlushchuk03"]},
  "Hobiki95"->{
    Cell[1064256, 30827, 274, 9, 70, "BibliographyItem",
      CellTags->"Hobiki95"]},
  "Hobiki96"->{
    Cell[1064533, 30838, 273, 9, 70, "BibliographyItem",
      CellTags->"Hobiki96"]},
  "Holm03"->{
    Cell[1064809, 30849, 323, 11, 70, "BibliographyItem",
      CellTags->"Holm03"]},
  "Holm03b"->{
    Cell[1065135, 30862, 264, 9, 70, "BibliographyItem",
      CellTags->"Holm03b"]},
  "Homolya03"->{
    Cell[1065402, 30873, 282, 9, 70, "BibliographyItem",
      CellTags->"Homolya03"]},
  "Homolya03b"->{
    Cell[1065687, 30884, 253, 9, 70, "BibliographyItem",
      CellTags->"Homolya03b"]},
  "Horvat03"->{
    Cell[1065943, 30895, 258, 9, 70, "BibliographyItem",
      CellTags->"Horvat03"]},
  "Horvat03b"->{
    Cell[1066204, 30906, 269, 9, 70, "BibliographyItem",
      CellTags->"Horvat03b"]},
  "Hu00"->{
    Cell[1066476, 30917, 281, 9, 70, "BibliographyItem",
      CellTags->"Hu00"]},
  "Huang04"->{
    Cell[1066760, 30928, 262, 9, 70, "BibliographyItem",
      CellTags->"Huang04"]},
  "Hyouguchi04"->{
    Cell[1067025, 30939, 282, 9, 70, "BibliographyItem",
      CellTags->"Hyouguchi04"]},
  "Ignatovich04"->{
    Cell[1067310, 30950, 260, 9, 70, "BibliographyItem",
      CellTags->"Ignatovich04"]},
  "Jacoboni04"->{
    Cell[1067573, 30961, 269, 9, 70, "BibliographyItem",
      CellTags->"Jacoboni04"]},
  "Jakobson04"->{
    Cell[1067845, 30972, 359, 11, 70, "BibliographyItem",
      CellTags->"Jakobson04"]},
  "Jacquod02"->{
    Cell[1068207, 30985, 345, 11, 70, "BibliographyItem",
      CellTags->"Jacquod02"]},
  "Jordan01"->{
    Cell[1068555, 30998, 324, 11, 70, "BibliographyItem",
      CellTags->"Jordan01"]},
  "Joshi75"->{
    Cell[1068882, 31011, 251, 9, 70, "BibliographyItem",
      CellTags->"Joshi75"]},
  "Kalhous04"->{
    Cell[1069136, 31022, 324, 10, 70, "BibliographyItem",
      CellTags->"Kalhous04"]},
  "Kallunki00"->{
    Cell[1069463, 31034, 262, 9, 70, "BibliographyItem",
      CellTags->"Kallunki00"]},
  "Karkuszewski00"->{
    Cell[1069728, 31045, 352, 11, 70, "BibliographyItem",
      CellTags->"Karkuszewski00"]},
  "Kenfack04"->{
    Cell[1070083, 31058, 261, 9, 70, "BibliographyItem",
      CellTags->"Kenfack04"]},
  "Kim03"->{
    Cell[1070347, 31069, 279, 9, 70, "BibliographyItem",
      CellTags->"Kim03"]},
  "Knowles04"->{
    Cell[1070629, 31080, 268, 9, 70, "BibliographyItem",
      CellTags->"Knowles04"]},
  "Knuth69"->{
    Cell[1070900, 31091, 298, 9, 70, "BibliographyItem",
      CellTags->"Knuth69"]},
  "Koch94"->{
    Cell[1071201, 31102, 265, 9, 70, "BibliographyItem",
      CellTags->"Koch94"]},
  "Kokubun98"->{
    Cell[1071469, 31113, 251, 9, 70, "BibliographyItem",
      CellTags->"Kokubun98"]},
  "Kong04"->{
    Cell[1071723, 31124, 258, 9, 70, "BibliographyItem",
      CellTags->"Kong04"]},
  "Koppenfels59"->{
    Cell[1071984, 31135, 315, 9, 70, "BibliographyItem",
      CellTags->"Koppenfels59"]},
  "Kostadt00"->{
    Cell[1072302, 31146, 273, 9, 70, "BibliographyItem",
      CellTags->"Kostadt00"]},
  "Krapivsky03"->{
    Cell[1072578, 31157, 331, 11, 70, "BibliographyItem",
      CellTags->"Krapivsky03"]},
  "Krug02"->{
    Cell[1072912, 31170, 241, 9, 70, "BibliographyItem",
      CellTags->"Krug02"]},
  "Kuttler84"->{
    Cell[1073156, 31181, 269, 9, 70, "BibliographyItem",
      CellTags->"Kuttler84"]},
  "Lai00"->{
    Cell[1073428, 31192, 277, 9, 70, "BibliographyItem",
      CellTags->"Lai00"]},
  "Lane95"->{
    Cell[1073708, 31203, 274, 9, 70, "BibliographyItem",
      CellTags->"Lane95"]},
  "Lanford82"->{
    Cell[1073985, 31214, 259, 9, 70, "BibliographyItem",
      CellTags->"Lanford82"]},
  "Lapidus96"->{
    Cell[1074247, 31225, 308, 9, 70, "BibliographyItem",
      CellTags->"Lapidus96"]},
  "LeBerre02"->{
    Cell[1074558, 31236, 302, 9, 70, "BibliographyItem",
      CellTags->"LeBerre02"]},
  "Lee95"->{
    Cell[1074863, 31247, 248, 9, 70, "BibliographyItem",
      CellTags->"Lee95"]},
  "Lee96"->{
    Cell[1075114, 31258, 245, 9, 70, "BibliographyItem",
      CellTags->"Lee96"]},
  "Lee97"->{
    Cell[1075362, 31269, 246, 9, 70, "BibliographyItem",
      CellTags->"Lee97"]},
  "Lee02"->{
    Cell[1075611, 31280, 251, 9, 70, "BibliographyItem",
      CellTags->"Lee02"]},
  "Lemos99"->{
    Cell[1075865, 31291, 323, 11, 70, "BibliographyItem",
      CellTags->"Lemos99"]},
  "Lesne98"->{
    Cell[1076191, 31304, 267, 9, 70, "BibliographyItem",
      CellTags->"Lesne98"]},
  "Liu01"->{
    Cell[1076461, 31315, 261, 9, 70, "BibliographyItem",
      CellTags->"Liu01"]},
  "Lopez03"->{
    Cell[1076725, 31326, 268, 9, 70, "BibliographyItem",
      CellTags->"Lopez03"]},
  "Lopez91"->{
    Cell[1076996, 31337, 252, 9, 70, "BibliographyItem",
      CellTags->"Lopez91"]},
  "Lopez02"->{
    Cell[1077251, 31348, 254, 9, 70, "BibliographyItem",
      CellTags->"Lopez02"]},
  "Lopuszanski99"->{
    Cell[1077508, 31359, 319, 9, 70, "BibliographyItem",
      CellTags->"Lopuszanski99"]},
  "Lorente04"->{
    Cell[1077830, 31370, 311, 11, 70, "BibliographyItem",
      CellTags->"Lorente04"]},
  "Lou02"->{
    Cell[1078144, 31383, 263, 9, 70, "BibliographyItem",
      CellTags->"Lou02"]},
  "Loutsenko02"->{
    Cell[1078410, 31394, 317, 11, 70, "BibliographyItem",
      CellTags->"Loutsenko02"]},
  "Loutsenko03"->{
    Cell[1078730, 31407, 317, 11, 70, "BibliographyItem",
      CellTags->"Loutsenko03"]},
  "Lu04"->{
    Cell[1079050, 31420, 255, 9, 70, "BibliographyItem",
      CellTags->"Lu04"],
    Cell[1079308, 31431, 274, 9, 70, "BibliographyItem",
      CellTags->"Lu04"]},
  "Lyubomudrov03"->{
    Cell[1079585, 31442, 295, 9, 70, "BibliographyItem",
      CellTags->"Lyubomudrov03"]},
  "MacMahon78"->{
    Cell[1079883, 31453, 279, 9, 70, "BibliographyItem",
      CellTags->"MacMahon78"]},
  "Maitra00"->{
    Cell[1080165, 31464, 254, 9, 70, "BibliographyItem",
      CellTags->"Maitra00"]},
  "Malhotra02"->{
    Cell[1080422, 31475, 290, 9, 70, "BibliographyItem",
      CellTags->"Malhotra02"]},
  "Marder04"->{
    Cell[1080715, 31486, 309, 11, 70, "BibliographyItem",
      CellTags->"Marder04"]},
  "Mattila95"->{
    Cell[1081027, 31499, 317, 9, 70, "BibliographyItem",
      CellTags->"Mattila95"]},
  "McCartin04"->{
    Cell[1081347, 31510, 266, 9, 70, "BibliographyItem",
      CellTags->"McCartin04"]},
  "McDonald88"->{
    Cell[1081616, 31521, 271, 9, 70, "BibliographyItem",
      CellTags->"McDonald88"]},
  "Menski03"->{
    Cell[1081890, 31532, 255, 9, 70, "BibliographyItem",
      CellTags->"Menski03"]},
  "Monteoliva00"->{
    Cell[1082148, 31543, 272, 9, 70, "BibliographyItem",
      CellTags->"Monteoliva00"]},
  "Monteoliva01"->{
    Cell[1082423, 31554, 270, 9, 70, "BibliographyItem",
      CellTags->"Monteoliva01"]},
  "MoralesRuiz01"->{
    Cell[1082696, 31565, 272, 9, 70, "BibliographyItem",
      CellTags->"MoralesRuiz01"]},
  "Muratov96"->{
    Cell[1082971, 31576, 268, 9, 70, "BibliographyItem",
      CellTags->"Muratov96"]},
  "Muratov01"->{
    Cell[1083242, 31587, 270, 9, 70, "BibliographyItem",
      CellTags->"Muratov01"]},
  "Netrusov03"->{
    Cell[1083515, 31598, 325, 11, 70, "BibliographyItem",
      CellTags->"Netrusov03"]},
  "Nieto70"->{
    Cell[1083843, 31611, 252, 9, 70, "BibliographyItem",
      CellTags->"Nieto70"]},
  "Noid80"->{
    Cell[1084098, 31622, 293, 9, 70, "BibliographyItem",
      CellTags->"Noid80"]},
  "Novaes03"->{
    Cell[1084394, 31633, 284, 9, 70, "BibliographyItem",
      CellTags->"Novaes03"]},
  "Nye03"->{
    Cell[1084681, 31644, 241, 9, 70, "BibliographyItem",
      CellTags->"Nye03"]},
  "O'Connell03"->{
    Cell[1084925, 31655, 271, 9, 70, "BibliographyItem",
      CellTags->"O'Connell03"]},
  "Okada03"->{
    Cell[1085199, 31666, 289, 9, 70, "BibliographyItem",
      CellTags->"Okada03"]},
  "Ota03"->{
    Cell[1085491, 31677, 313, 11, 70, "BibliographyItem",
      CellTags->"Ota03"]},
  "Parekh95"->{
    Cell[1085807, 31690, 278, 9, 70, "BibliographyItem",
      CellTags->"Parekh95"]},
  "Pattanayak92"->{
    Cell[1086088, 31701, 275, 9, 70, "BibliographyItem",
      CellTags->"Pattanayak92"]},
  "Pattanyak03"->{
    Cell[1086366, 31712, 294, 9, 70, "BibliographyItem",
      CellTags->"Pattanyak03"]},
  "Pennetta02"->{
    Cell[1086663, 31723, 365, 11, 70, "BibliographyItem",
      CellTags->"Pennetta02"]},
  "Porras98"->{
    Cell[1087031, 31736, 252, 9, 70, "BibliographyItem",
      CellTags->"Porras98"]},
  "Porras00"->{
    Cell[1087286, 31747, 280, 9, 70, "BibliographyItem",
      CellTags->"Porras00"]},
  "Prosen00"->{
    Cell[1087569, 31758, 269, 9, 70, "BibliographyItem",
      CellTags->"Prosen00"]},
  "Pullen81"->{
    Cell[1087841, 31769, 265, 9, 70, "BibliographyItem",
      CellTags->"Pullen81"]},
  "Radozycki04"->{
    Cell[1088109, 31780, 315, 11, 70, "BibliographyItem",
      CellTags->"Radozycki04"]},
  "Rasband90"->{
    Cell[1088427, 31793, 286, 9, 70, "BibliographyItem",
      CellTags->"Rasband90"]},
  "Reynolds94"->{
    Cell[1088716, 31804, 298, 9, 70, "BibliographyItem",
      CellTags->"Reynolds94"]},
  "Reynolds97"->{
    Cell[1089017, 31815, 293, 9, 70, "BibliographyItem",
      CellTags->"Reynolds97"]},
  "Rivin03"->{
    Cell[1089313, 31826, 309, 11, 70, "BibliographyItem",
      CellTags->"Rivin03"]},
  "Russ97"->{
    Cell[1089625, 31839, 278, 9, 70, "BibliographyItem",
      CellTags->"Russ97"]},
  "Russ01"->{
    Cell[1089906, 31850, 247, 9, 70, "BibliographyItem",
      CellTags->"Russ01"]},
  "Russ02"->{
    Cell[1090156, 31861, 259, 9, 70, "BibliographyItem",
      CellTags->"Russ02"]},
  "Sakajo04"->{
    Cell[1090418, 31872, 254, 9, 70, "BibliographyItem",
      CellTags->"Sakajo04"]},
  "Sapoval89"->{
    Cell[1090675, 31883, 247, 9, 70, "BibliographyItem",
      CellTags->"Sapoval89"]},
  "Sapoval91"->{
    Cell[1090925, 31894, 280, 9, 70, "BibliographyItem",
      CellTags->"Sapoval91"]},
  "Sapoval93"->{
    Cell[1091208, 31905, 262, 9, 70, "BibliographyItem",
      CellTags->"Sapoval93"]},
  "Sapoval97"->{
    Cell[1091473, 31916, 281, 9, 70, "BibliographyItem",
      CellTags->"Sapoval97"]},
  "Schmidt02"->{
    Cell[1091757, 31927, 348, 11, 70, "BibliographyItem",
      CellTags->"Schmidt02"]},
  "Schwarz88"->{
    Cell[1092108, 31940, 254, 9, 70, "BibliographyItem",
      CellTags->"Schwarz88"]},
  "Scott03"->{
    Cell[1092365, 31951, 275, 9, 70, "BibliographyItem",
      CellTags->"Scott03"]},
  "Shigehara94"->{
    Cell[1092643, 31962, 255, 9, 70, "BibliographyItem",
      CellTags->"Shigehara94"]},
  "Silvestrov02"->{
    Cell[1092901, 31973, 286, 9, 70, "BibliographyItem",
      CellTags->"Silvestrov02"]},
  "Silvestrov03"->{
    Cell[1093190, 31984, 296, 9, 70, "BibliographyItem",
      CellTags->"Silvestrov03"]},
  "Sneddon66"->{
    Cell[1093489, 31995, 306, 9, 70, "BibliographyItem",
      CellTags->"Sneddon66"]},
  "Solin04"->{
    Cell[1093798, 32006, 340, 9, 70, "BibliographyItem",
      CellTags->"Solin04"]},
  "Sridhar94"->{
    Cell[1094141, 32017, 268, 9, 70, "BibliographyItem",
      CellTags->"Sridhar94"]},
  "Stakgold50"->{
    Cell[1094412, 32028, 254, 9, 70, "BibliographyItem",
      CellTags->"Stakgold50"]},
  "Stenull03"->{
    Cell[1094669, 32039, 341, 11, 70, "BibliographyItem",
      CellTags->"Stenull03"]},
  "Straley89"->{
    Cell[1095013, 32052, 254, 9, 70, "BibliographyItem",
      CellTags->"Straley89"]},
  "Takahashi86"->{
    Cell[1095270, 32063, 298, 9, 70, "BibliographyItem",
      CellTags->"Takahashi86"]},
  "Tang02"->{
    Cell[1095571, 32074, 265, 9, 70, "BibliographyItem",
      CellTags->"Tang02"]},
  "Toscana01"->{
    Cell[1095839, 32085, 294, 9, 70, "BibliographyItem",
      CellTags->"Toscana01"]},
  "Trzetrzelewski03"->{
    Cell[1096136, 32096, 335, 11, 70, "BibliographyItem",
      CellTags->"Trzetrzelewski03"]},
  "Tsubota00"->{
    Cell[1096474, 32109, 281, 9, 70, "BibliographyItem",
      CellTags->"Tsubota00"]},
  "Ujevic03"->{
    Cell[1096758, 32120, 334, 11, 70, "BibliographyItem",
      CellTags->"Ujevic03"]},
  "Vernov02"->{
    Cell[1097095, 32133, 312, 11, 70, "BibliographyItem",
      CellTags->"Vernov02"]},
  "Vernov03"->{
    Cell[1097410, 32146, 312, 11, 70, "BibliographyItem",
      CellTags->"Vernov03"]},
  "VigoAguiar03"->{
    Cell[1097725, 32159, 312, 9, 70, "BibliographyItem",
      CellTags->"VigoAguiar03"]},
  "Vul84"->{
    Cell[1098040, 32170, 277, 9, 70, "BibliographyItem",
      CellTags->"Vul84"]},
  "Walker03"->{
    Cell[1098320, 32181, 257, 9, 70, "BibliographyItem",
      CellTags->"Walker03"]},
  "Wang04"->{
    Cell[1098580, 32192, 259, 9, 70, "BibliographyItem",
      CellTags->"Wang04"]},
  "Wells94"->{
    Cell[1098842, 32203, 276, 9, 70, "BibliographyItem",
      CellTags->"Wells94"]},
  "Wigley72"->{
    Cell[1099121, 32214, 257, 9, 70, "BibliographyItem",
      CellTags->"Wigley72"]},
  "Wirzba99"->{
    Cell[1099381, 32225, 245, 9, 70, "BibliographyItem",
      CellTags->"Wirzba99"]},
  "Wong02"->{
    Cell[1099629, 32236, 317, 11, 70, "BibliographyItem",
      CellTags->"Wong02"]},
  "Wu95"->{
    Cell[1099949, 32249, 271, 9, 70, "BibliographyItem",
      CellTags->"Wu95"]},
  "Yosibash98"->{
    Cell[1100223, 32260, 302, 9, 70, "BibliographyItem",
      CellTags->"Yosibash98"]},
  "Yuan00"->{
    Cell[1100528, 32271, 288, 9, 70, "BibliographyItem",
      CellTags->"Yuan00"]},
  "Zanzatto96"->{
    Cell[1100819, 32282, 253, 9, 70, "BibliographyItem",
      CellTags->"Zanzatto96"]},
  "Zeyman85"->{
    Cell[1101075, 32293, 258, 9, 70, "BibliographyItem",
      CellTags->"Zeyman85"]},
  "Ziff80"->{
    Cell[1101336, 32304, 263, 9, 70, "BibliographyItem",
      CellTags->"Ziff80"]},
  "Ziolkowski01"->{
    Cell[1101602, 32315, 273, 9, 70, "BibliographyItem",
      CellTags->"Ziolkowski01"]},
  "Zurek01"->{
    Cell[1101878, 32326, 244, 9, 70, "BibliographyItem",
      CellTags->"Zurek01"]},
  "Zurek02"->{
    Cell[1102125, 32337, 251, 9, 70, "BibliographyItem",
      CellTags->"Zurek02"]},
  "Zurek03"->{
    Cell[1102379, 32348, 252, 9, 70, "BibliographyItem",
      CellTags->"Zurek03"]},
  "Zyczkowski04"->{
    Cell[1102634, 32359, 334, 11, 70, "BibliographyItem",
      CellTags->"Zyczkowski04"]}
  }
*)

(*CellTagsIndex
CellTagsIndex->{
  {"Index[09, Chladny figures]", 1167268, 34606},
  {"Index[09, {figures, Chladny ~}]", 1167511, 34611},
  {"Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]", 1167779, \
34616},
  {"T[D[Vibrating Gosper Curve]]", 1168019, 34621},
  {"Index[12, {Gosper, curve}]", 1168242, 34626},
  {"Index[12, {springs, along a Gosper curve}]", 1168481, 34631},
  {"Index[12, {Cosper, spring chain}]", 1168711, 34636},
  {"T[D[Sliding Spinning Disk]]", 1168848, 34639},
  {"Index[14, {disk, spinning and sliding ~}]", 1169054, 34644},
  {"T[Ref[1]]", 1169228, 34649},
  {"Abramson03", 1169334, 34652},
  {"Acedo03", 1169438, 34655},
  {"Adler78", 1169540, 34658},
  {"Aguirre01", 1169643, 34661},
  {"Aguirre03", 1169748, 34664},
  {"Alonso03", 1169852, 34667},
  {"Angelo03", 1169956, 34670},
  {"Atakishiyev01", 1170064, 34673},
  {"Atakishiyev03", 1170177, 34676},
  {"Atakishiyev04", 1170290, 34679},
  {"Azzam82", 1170398, 34682},
  {"Baake99", 1170499, 34685},
  {"BaezDuarte03", 1170606, 34688},
  {"Baker96", 1170713, 34691},
  {"Balcou96", 1170815, 34694},
  {"Ballentine98", 1170922, 34697},
  {"Baltes76", 1171029, 34700},
  {"Bajnok02", 1171132, 34703},
  {"Barbashov67", 1171238, 34706},
  {"Barlow90", 1171344, 34709},
  {"Barthelemy00", 1171451, 34712},
  {"Baruch10", 1171559, 34715},
  {"Bayfield99", 1171665, 34718},
  {"Beaver04", 1171770, 34721},
  {"Bell70", 1171871, 34724},
  {"Belloni03", 1171973, 34727},
  {"Belmonte01", 1172080, 34730},
  {"Berezovoj03a", 1172189, 34733},
  {"Berry79", 1172296, 34736},
  {"Berry79b", 1172398, 34739},
  {"Besprosvany01", 1172506, 34742},
  {"Betchov65", 1172615, 34745},
  {"Bhattacharya02", 1172725, 34748},
  {"BialnynickiBirula83", 1172845, 34751},
  {"Blochintsev52", 1172964, 34754},
  {"Bode01", 1173070, 34757},
  {"Bogomolny04", 1173174, 34760},
  {"Bolivar04", 1173282, 34763},
  {"Borwein03", 1173387, 34766},
  {"Borwein04", 1173493, 34769},
  {"Bosanac83", 1173598, 34772},
  {"Brack93", 1173701, 34775},
  {"Brack98", 1173802, 34778},
  {"Brenier04", 1173905, 34781},
  {"Breuer02", 1174009, 34784},
  {"Briggs91", 1174112, 34787},
  {"Brunelli97", 1174217, 34790},
  {"Burchnall30", 1174326, 34793},
  {"Buttke88", 1174432, 34796},
  {"Byron70", 1174534, 34799},
  {"Camassa94", 1174637, 34802},
  {"Cametti02", 1174742, 34805},
  {"Caputo01", 1174847, 34808},
  {"Cardeso03", 1174951, 34811},
  {"Cartwright02", 1175059, 34814},
  {"Carvalho04", 1175169, 34817},
  {"Casati96", 1175274, 34820},
  {"CerrutiSola96", 1175382, 34823},
  {"ChaosCador04", 1175494, 34826},
  {"Chate87", 1175600, 34829},
  {"Chatteraj04", 1175705, 34832},
  {"Chellone71", 1175813, 34835},
  {"Christiansen90", 1175924, 34838},
  {"Chang86", 1176032, 34841},
  {"Chruscinski98", 1176139, 34844},
  {"Ciattoni04", 1176249, 34847},
  {"Cieslinski86", 1176446, 34852},
  {"Chun03", 1176551, 34855},
  {"Clarkson03", 1176654, 34858},
  {"Cohen95", 1176758, 34861},
  {"Crampin99", 1176861, 34864},
  {"Crampin01", 1176966, 34867},
  {"Crampin02", 1177071, 34870},
  {"Crampin02b", 1177177, 34873},
  {"Cuccietti02", 1177285, 34876},
  {"Cucchietti03", 1177395, 34879},
  {"Czirjak00", 1177504, 34882},
  {"Denisov00", 1177609, 34885},
  {"DeSerio03", 1177714, 34888},
  {"Dhar03", 1177816, 34891},
  {"Dowker04", 1177918, 34894},
  {"Driscoll97", 1178024, 34897},
  {"Driscoll02", 1178131, 34900},
  {"Driscoll03", 1178238, 34903},
  {"Dubey79", 1178342, 34906},
  {"Duxbury95", 1178445, 34909},
  {"Encinosa03", 1178551, 34912},
  {"Encinosa04", 1178658, 34915},
  {"Englisch91", 1178766, 34918},
  {"Ericksen84", 1178873, 34921},
  {"Farkas03", 1178978, 34924},
  {"Feigenbaum78", 1179085, 34927},
  {"Felder02", 1179192, 34930},
  {"Felsenthal98", 1179300, 34933},
  {"Ferraro04", 1179409, 34936},
  {"Foeldi03", 1179513, 34939},
  {"Fornberg98", 1179619, 34942},
  {"Fornberg99", 1179726, 34945},
  {"Friesecke02", 1179834, 34948},
  {"Friesecke03", 1179943, 34951},
  {"Frisch03", 1180049, 34954},
  {"Galleani02", 1180155, 34957},
  {"Galleani02b", 1180263, 34960},
  {"Gardiner00", 1180371, 34963},
  {"Gaspard89", 1180477, 34966},
  {"Gillet01", 1180581, 34969},
  {"Gladwell02", 1180686, 34972},
  {"Goldman84", 1180792, 34975},
  {"Golovin03", 1180897, 34978},
  {"Goos47", 1180999, 34981},
  {"Goos49", 1181098, 34984},
  {"Greenbaum04", 1181202, 34987},
  {"Grosche98", 1181310, 34990},
  {"Gutierrez04", 1181417, 34993},
  {"Gutman04", 1181524, 34996},
  {"Habib98", 1181626, 34999},
  {"Habib00", 1181728, 35002},
  {"Hauswirth00", 1181834, 35005},
  {"Helmkamp94", 1181943, 35008},
  {"Hicks59", 1182047, 35011},
  {"Hinch91", 1182148, 35014},
  {"Hlushchuk03", 1182253, 35017},
  {"Hobiki95", 1182360, 35020},
  {"Hobiki96", 1182463, 35023},
  {"Holm03", 1182564, 35026},
  {"Holm03b", 1182665, 35029},
  {"Homolya03", 1182768, 35032},
  {"Homolya03b", 1182874, 35035},
  {"Horvat03", 1182979, 35038},
  {"Horvat03b", 1183083, 35041},
  {"Hu00", 1183183, 35044},
  {"Huang04", 1183281, 35047},
  {"Hyouguchi04", 1183386, 35050},
  {"Ignatovich04", 1183496, 35053},
  {"Jacoboni04", 1183605, 35056},
  {"Jakobson04", 1183712, 35059},
  {"Jacquod02", 1183819, 35062},
  {"Jordan01", 1183924, 35065},
  {"Joshi75", 1184027, 35068},
  {"Kalhous04", 1184130, 35071},
  {"Kallunki00", 1184237, 35074},
  {"Karkuszewski00", 1184348, 35077},
  {"Kenfack04", 1184459, 35080},
  {"Kim03", 1184560, 35083},
  {"Knowles04", 1184661, 35086},
  {"Knuth69", 1184764, 35089},
  {"Koch94", 1184864, 35092},
  {"Kokubun98", 1184966, 35095},
  {"Kong04", 1185068, 35098},
  {"Koppenfels59", 1185173, 35101},
  {"Kostadt00", 1185281, 35104},
  {"Krapivsky03", 1185388, 35107},
  {"Krug02", 1185493, 35110},
  {"Kuttler84", 1185595, 35113},
  {"Lai00", 1185696, 35116},
  {"Lane95", 1185794, 35119},
  {"Lanford82", 1185896, 35122},
  {"Lapidus96", 1186001, 35125},
  {"LeBerre02", 1186106, 35128},
  {"Lee95", 1186207, 35131},
  {"Lee96", 1186304, 35134},
  {"Lee97", 1186401, 35137},
  {"Lee02", 1186498, 35140},
  {"Lemos99", 1186597, 35143},
  {"Lesne98", 1186699, 35146},
  {"Liu01", 1186798, 35149},
  {"Lopez03", 1186897, 35152},
  {"Lopez91", 1186998, 35155},
  {"Lopez02", 1187099, 35158},
  {"Lopuszanski99", 1187206, 35161},
  {"Lorente04", 1187315, 35164},
  {"Lou02", 1187417, 35167},
  {"Loutsenko02", 1187520, 35170},
  {"Loutsenko03", 1187630, 35173},
  {"Lu04", 1187733, 35176},
  {"Lyubomudrov03", 1187919, 35181},
  {"MacMahon78", 1188029, 35184},
  {"Maitra00", 1188134, 35187},
  {"Malhotra02", 1188239, 35190},
  {"Marder04", 1188344, 35193},
  {"Mattila95", 1188449, 35196},
  {"McCartin04", 1188555, 35199},
  {"McDonald88", 1188662, 35202},
  {"Menski03", 1188767, 35205},
  {"Monteoliva00", 1188874, 35208},
  {"Monteoliva01", 1188985, 35211},
  {"MoralesRuiz01", 1189097, 35214},
  {"Muratov96", 1189206, 35217},
  {"Muratov01", 1189311, 35220},
  {"Netrusov03", 1189417, 35223},
  {"Nieto70", 1189522, 35226},
  {"Noid80", 1189622, 35229},
  {"Novaes03", 1189723, 35232},
  {"Nye03", 1189823, 35235},
  {"O'Connell03", 1189926, 35238},
  {"Okada03", 1190031, 35241},
  {"Ota03", 1190130, 35244},
  {"Parekh95", 1190231, 35247},
  {"Pattanayak92", 1190338, 35250},
  {"Pattanyak03", 1190448, 35253},
  {"Pennetta02", 1190556, 35256},
  {"Porras98", 1190662, 35259},
  {"Porras00", 1190765, 35262},
  {"Prosen00", 1190868, 35265},
  {"Pullen81", 1190971, 35268},
  {"Radozycki04", 1191077, 35271},
  {"Rasband90", 1191185, 35274},
  {"Reynolds94", 1191291, 35277},
  {"Reynolds97", 1191398, 35280},
  {"Rivin03", 1191502, 35283},
  {"Russ97", 1191603, 35286},
  {"Russ01", 1191702, 35289},
  {"Russ02", 1191801, 35292},
  {"Sakajo04", 1191902, 35295},
  {"Sapoval89", 1192006, 35298},
  {"Sapoval91", 1192111, 35301},
  {"Sapoval93", 1192216, 35304},
  {"Sapoval97", 1192321, 35307},
  {"Schmidt02", 1192426, 35310},
  {"Schwarz88", 1192532, 35313},
  {"Scott03", 1192635, 35316},
  {"Shigehara94", 1192740, 35319},
  {"Silvestrov02", 1192850, 35322},
  {"Silvestrov03", 1192961, 35325},
  {"Sneddon66", 1193069, 35328},
  {"Solin04", 1193172, 35331},
  {"Sridhar94", 1193275, 35334},
  {"Stakgold50", 1193381, 35337},
  {"Stenull03", 1193487, 35340},
  {"Straley89", 1193593, 35343},
  {"Takahashi86", 1193700, 35346},
  {"Tang02", 1193804, 35349},
  {"Toscana01", 1193906, 35352},
  {"Trzetrzelewski03", 1194018, 35355},
  {"Tsubota00", 1194131, 35358},
  {"Ujevic03", 1194235, 35361},
  {"Vernov02", 1194339, 35364},
  {"Vernov03", 1194443, 35367},
  {"VigoAguiar03", 1194551, 35370},
  {"Vul84", 1194655, 35373},
  {"Walker03", 1194755, 35376},
  {"Wang04", 1194856, 35379},
  {"Wells94", 1194956, 35382},
  {"Wigley72", 1195058, 35385},
  {"Wirzba99", 1195161, 35388},
  {"Wong02", 1195262, 35391},
  {"Wu95", 1195360, 35394},
  {"Yosibash98", 1195461, 35397},
  {"Yuan00", 1195564, 35400},
  {"Zanzatto96", 1195667, 35403},
  {"Zeyman85", 1195772, 35406},
  {"Ziff80", 1195873, 35409},
  {"Ziolkowski01", 1195978, 35412},
  {"Zurek01", 1196084, 35415},
  {"Zurek02", 1196185, 35418},
  {"Zurek03", 1196286, 35421},
  {"Zyczkowski04", 1196392, 35424}
  }
*)

(*NotebookFileOutline
Notebook[{
Cell[1754, 51, 203, 5, 62, "VolumeLabel"],
Cell[1960, 58, 229, 7, 115, "ChapterNumber"],

Cell[CellGroupData[{
Cell[2214, 69, 26, 0, 78, "Section"],
Cell[2243, 71, 440, 15, 70, "Text"],
Cell[2686, 88, 254, 7, 70, "Text"],
Cell[2943, 97, 383, 8, 70, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[3363, 110, 45, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[3433, 114, 170, 6, 70, "ExerciseHeading"],
Cell[3606, 122, 2094, 62, 70, "Text"],

Cell[CellGroupData[{
Cell[5725, 188, 365, 10, 70, "SolutionSubgroup"],
Cell[6093, 200, 928, 16, 70, "Input"],
Cell[7024, 218, 99, 3, 70, "Text"],
Cell[7126, 223, 72, 3, 70, "Input"],
Cell[7201, 228, 100, 3, 70, "Text"],
Cell[7304, 233, 74, 3, 70, "Input"],
Cell[7381, 238, 272, 7, 70, "Text"],
Cell[7656, 247, 309, 8, 70, "Input"],
Cell[7968, 257, 256, 6, 70, "Text"],
Cell[8227, 265, 213, 5, 70, "Input"],
Cell[8443, 272, 87, 3, 70, "Text"],
Cell[8533, 277, 254, 6, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[8836, 289, 200, 6, 70, "ExerciseHeading"],
Cell[9039, 297, 162, 4, 70, "Text"],

Cell[CellGroupData[{
Cell[9226, 305, 78, 0, 70, "SolutionSubgroup"],
Cell[9307, 307, 173, 4, 70, "Input"],
Cell[9483, 313, 368, 10, 70, "Input"],
Cell[9854, 325, 940, 16, 70, "Input"],
Cell[10797, 343, 490, 10, 70, "Input"],
Cell[11290, 355, 94, 3, 70, "Text"],
Cell[11387, 360, 96, 3, 70, "Input"],
Cell[11486, 365, 179, 6, 70, "Text"],
Cell[11668, 373, 100, 3, 70, "Input"],
Cell[11771, 378, 360, 10, 70, "Text"],
Cell[12134, 390, 61, 0, 70, "Input"],
Cell[12198, 392, 394, 8, 70, "Input"],
Cell[12595, 402, 341, 8, 70, "Text"],
Cell[12939, 412, 393, 7, 70, "Input"],
Cell[13335, 421, 227, 7, 70, "Text"],
Cell[13565, 430, 568, 11, 70, "Input"],
Cell[14136, 443, 225, 6, 70, "Input"],
Cell[14364, 451, 48, 0, 70, "Text"],
Cell[14415, 453, 73, 0, 70, "Input"],
Cell[14491, 455, 383, 12, 70, "ProgramLabel"],
Cell[14877, 469, 116, 4, 70, "Program"],
Cell[14996, 475, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[15070, 481, 186, 6, 70, "ExerciseHeading"],
Cell[15259, 489, 279, 5, 70, "Text"],

Cell[CellGroupData[{
Cell[15563, 498, 969, 26, 70, "SolutionSubgroup"],
Cell[16535, 526, 891, 16, 70, "Input"],
Cell[17429, 544, 161, 4, 70, "Text"],
Cell[17593, 550, 435, 8, 70, "Input"],
Cell[18031, 560, 422, 14, 70, "ProgramLabel"],
Cell[18456, 576, 438, 8, 70, "Program"],
Cell[18897, 586, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[18983, 593, 45, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[19053, 597, 198, 6, 70, "ExerciseHeading"],
Cell[19254, 605, 132, 3, 70, "Text"],

Cell[CellGroupData[{
Cell[19411, 612, 1363, 46, 70, "SolutionSubgroup"],
Cell[20777, 660, 814, 13, 70, "Input"],
Cell[21594, 675, 503, 13, 70, "Text"],
Cell[22100, 690, 297, 7, 70, "Input"],
Cell[22400, 699, 162, 4, 70, "Text"],
Cell[22565, 705, 1109, 18, 70, "Input"],
Cell[23677, 725, 149, 4, 70, "Input"],
Cell[23829, 731, 400, 13, 70, "ProgramLabel"],
Cell[24232, 746, 82, 3, 70, "Program"],
Cell[24317, 751, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[24391, 757, 182, 6, 70, "ExerciseHeading"],
Cell[24576, 765, 219, 4, 70, "Text"],

Cell[CellGroupData[{
Cell[24820, 773, 177, 4, 70, "SolutionSubgroup"],
Cell[25000, 779, 1601, 27, 70, "Input"],
Cell[26604, 808, 529, 11, 70, "Text"],
Cell[27136, 821, 337, 8, 70, "Input"],
Cell[27476, 831, 666, 25, 70, "Text"],
Cell[28145, 858, 327, 5, 70, "Input"],
Cell[28475, 865, 431, 12, 70, "Text"],
Cell[28909, 879, 890, 14, 70, "Input"],
Cell[29802, 895, 806, 14, 70, "Input"],
Cell[30611, 911, 623, 19, 70, "Text"],
Cell[31237, 932, 247, 5, 70, "Input"],
Cell[31487, 939, 163, 5, 70, "Text"],
Cell[31653, 946, 181, 5, 70, "Input"],
Cell[31837, 953, 387, 13, 70, "Text"],
Cell[32227, 968, 785, 13, 70, "Input"],
Cell[33015, 983, 134, 4, 70, "Input"],
Cell[33152, 989, 475, 9, 70, "Text"],
Cell[33630, 1000, 1578, 25, 70, "Input"],
Cell[35211, 1027, 263, 7, 70, "Text"],
Cell[35477, 1036, 527, 9, 70, "Input"],
Cell[36007, 1047, 48, 0, 70, "Text"],
Cell[36058, 1049, 161, 5, 70, "Input"],
Cell[36222, 1056, 381, 12, 70, "ProgramLabel"],
Cell[36606, 1070, 124, 4, 70, "Program"],
Cell[36733, 1076, 25, 0, 70, "ProgramBottom"],
Cell[36761, 1078, 552, 18, 70, "Text"],
Cell[37316, 1098, 906, 16, 70, "Input"],
Cell[38225, 1116, 251, 5, 70, "Input"],
Cell[38479, 1123, 174, 4, 70, "Input"],
Cell[38656, 1129, 112, 3, 70, "Text"],
Cell[38771, 1134, 314, 6, 70, "Input"],
Cell[39088, 1142, 166, 4, 70, "Input"],
Cell[39257, 1148, 305, 6, 70, "Input"],
Cell[39565, 1156, 129, 4, 70, "Input"],
Cell[39697, 1162, 219, 6, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[39965, 1174, 201, 6, 70, "ExerciseHeading"],
Cell[40169, 1182, 121, 3, 70, "Text"],

Cell[CellGroupData[{
Cell[40315, 1189, 210, 5, 70, "SolutionSubgroup"],
Cell[40528, 1196, 474, 10, 70, "Input"],
Cell[41005, 1208, 606, 14, 70, "Text"],
Cell[41614, 1224, 904, 18, 70, "Input"],
Cell[42521, 1244, 720, 20, 70, "Text"],
Cell[43244, 1266, 122, 4, 70, "Input"],
Cell[43369, 1272, 603, 17, 70, "Text"],
Cell[43975, 1291, 167, 4, 70, "Input"],
Cell[44145, 1297, 619, 12, 70, "Input"],
Cell[44767, 1311, 142, 3, 70, "Text"],
Cell[44912, 1316, 107, 3, 70, "Input"],
Cell[45022, 1321, 334, 9, 70, "Text"],
Cell[45359, 1332, 185, 5, 70, "Input"],
Cell[45547, 1339, 425, 7, 70, "Text"],
Cell[45975, 1348, 229, 5, 70, "Text"],
Cell[46207, 1355, 454, 8, 70, "Input"],
Cell[46664, 1365, 190, 4, 70, "Text"],
Cell[46857, 1371, 366, 7, 70, "Input"],
Cell[47226, 1380, 119, 4, 70, "Text"],
Cell[47348, 1386, 94, 3, 70, "Input"],
Cell[47445, 1391, 452, 8, 70, "Text"],
Cell[47900, 1401, 1555, 27, 70, "Input"],
Cell[49458, 1430, 98, 3, 70, "Text"],
Cell[49559, 1435, 607, 11, 70, "Input"],
Cell[50169, 1448, 166, 5, 70, "Text"],
Cell[50338, 1455, 101, 3, 70, "Input"],
Cell[50442, 1460, 93, 3, 70, "Text"],
Cell[50538, 1465, 418, 7, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[51005, 1478, 238, 9, 70, "ExerciseHeading"],
Cell[51246, 1489, 223, 4, 70, "Text"],

Cell[CellGroupData[{
Cell[51494, 1497, 292, 9, 70, "SolutionSubgroup"],
Cell[51789, 1508, 382, 9, 70, "Input"],
Cell[52174, 1519, 65, 0, 70, "Text"],
Cell[52242, 1521, 113, 4, 70, "Input"],
Cell[52358, 1527, 334, 9, 70, "Text"],
Cell[52695, 1538, 307, 6, 70, "Input"],
Cell[53005, 1546, 184, 4, 70, "Text"],
Cell[53192, 1552, 226, 5, 70, "Input"],
Cell[53421, 1559, 73, 0, 70, "Input"],
Cell[53497, 1561, 178, 5, 70, "Text"],
Cell[53678, 1568, 91, 3, 70, "Input"],
Cell[53772, 1573, 217, 5, 70, "Input"],
Cell[53992, 1580, 70, 0, 70, "Input"],
Cell[54065, 1582, 215, 8, 70, "Text"],
Cell[54283, 1592, 104, 3, 70, "Input"],
Cell[54390, 1597, 249, 6, 70, "Text"],
Cell[54642, 1605, 1693, 30, 70, "Input"],
Cell[56338, 1637, 137, 3, 70, "Text"],
Cell[56478, 1642, 120, 3, 70, "Input"],
Cell[56601, 1647, 197, 4, 70, "Text"],
Cell[56801, 1653, 729, 12, 70, "Input"],
Cell[57533, 1667, 514, 9, 70, "Input"],
Cell[58050, 1678, 48, 0, 70, "Input"],
Cell[58101, 1680, 185, 4, 70, "Text"],
Cell[58289, 1686, 115, 4, 70, "Input"],
Cell[58407, 1692, 105, 3, 70, "Text"],
Cell[58515, 1697, 627, 13, 70, "Input"],
Cell[59145, 1712, 204, 4, 70, "Text"],
Cell[59352, 1718, 162, 4, 70, "Input"],
Cell[59517, 1724, 50, 0, 70, "Text"],
Cell[59570, 1726, 47, 0, 70, "Input"],
Cell[59620, 1728, 191, 4, 70, "Text"],
Cell[59814, 1734, 240, 7, 70, "Input"],
Cell[60057, 1743, 228, 8, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[60334, 1757, 177, 6, 70, "ExerciseHeading"],
Cell[60514, 1765, 3417, 108, 70, "Text"],
Cell[63934, 1875, 157, 6, 70, "Text"],
Cell[64094, 1883, 1718, 49, 70, "DisplayFormula"],
Cell[65815, 1934, 156, 6, 70, "Text"],
Cell[65974, 1942, 1986, 55, 70, "DisplayFormula"],
Cell[67963, 1999, 824, 24, 70, "Text"],
Cell[68790, 2025, 344, 10, 70, "Text"],
Cell[69137, 2037, 480, 15, 70, "Text"],

Cell[CellGroupData[{
Cell[69642, 2056, 139, 3, 70, "SolutionSubgroup"],
Cell[69784, 2061, 212, 6, 70, "Input"],
Cell[69999, 2069, 104, 3, 70, "Input"],
Cell[70106, 2074, 130, 3, 70, "Text"],
Cell[70239, 2079, 331, 7, 70, "Input"],
Cell[70573, 2088, 129, 3, 70, "Text"],
Cell[70705, 2093, 492, 10, 70, "Input"],
Cell[71200, 2105, 147, 3, 70, "Text"],
Cell[71350, 2110, 251, 7, 70, "Input"],
Cell[71604, 2119, 401, 7, 70, "Input"],
Cell[72008, 2128, 224, 6, 70, "Input"],
Cell[72235, 2136, 148, 3, 70, "Text"],
Cell[72386, 2141, 160, 4, 70, "Input"],
Cell[72549, 2147, 147, 3, 70, "Input"],
Cell[72699, 2152, 226, 7, 70, "Text"],
Cell[72928, 2161, 164, 5, 70, "Input"],
Cell[73095, 2168, 100, 3, 70, "Input"],
Cell[73198, 2173, 212, 8, 70, "Text"],
Cell[73413, 2183, 420, 9, 70, "Input"],
Cell[73836, 2194, 50, 0, 70, "Text"],
Cell[73889, 2196, 212, 6, 70, "Input"],
Cell[74104, 2204, 326, 6, 70, "Text"],
Cell[74433, 2212, 258, 5, 70, "Input"],
Cell[74694, 2219, 697, 13, 70, "Input"],
Cell[75394, 2234, 771, 14, 70, "Input"],
Cell[76168, 2250, 92, 3, 70, "Text"],
Cell[76263, 2255, 271, 6, 70, "Input"],
Cell[76537, 2263, 52, 0, 70, "Text"],
Cell[76592, 2265, 383, 12, 70, "ProgramLabel"],
Cell[76978, 2279, 207, 4, 70, "Program"],
Cell[77188, 2285, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[77274, 2292, 45, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[77344, 2296, 191, 6, 70, "ExerciseHeading"],
Cell[77538, 2304, 469, 13, 70, "Text",
  CellTags->{
  "Index[09, Chladny figures]", "Index[09, {figures, Chladny ~}]", 
    "Index[09, {vibrating membrane, square\[Hyphen]shaped ~}]"}],
Cell[78010, 2319, 1119, 31, 70, "DisplayFormula"],
Cell[79132, 2352, 483, 14, 70, "Text"],

Cell[CellGroupData[{
Cell[79640, 2370, 214, 5, 70, "SolutionSubgroup"],
Cell[79857, 2377, 259, 6, 70, "Input"],
Cell[80119, 2385, 189, 6, 70, "Text"],
Cell[80311, 2393, 30, 0, 70, "Input"],
Cell[80344, 2395, 70, 0, 70, "Text"],
Cell[80417, 2397, 171, 5, 70, "Input"],
Cell[80591, 2404, 533, 18, 70, "Text"],
Cell[81127, 2424, 1015, 16, 70, "Input"],
Cell[82145, 2442, 69, 0, 70, "Input"],
Cell[82217, 2444, 48, 0, 70, "Text"],
Cell[82268, 2446, 420, 14, 70, "ProgramLabel"],
Cell[82691, 2462, 126, 4, 70, "Program"],
Cell[82820, 2468, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[82894, 2474, 247, 9, 70, "ExerciseHeading"],
Cell[83144, 2485, 246, 7, 70, "Text"],

Cell[CellGroupData[{
Cell[83415, 2496, 695, 24, 70, "SolutionSubgroup"],
Cell[84113, 2522, 368, 8, 70, "Input"],
Cell[84484, 2532, 291, 9, 70, "Text"],
Cell[84778, 2543, 288, 7, 70, "Input"],
Cell[85069, 2552, 137, 5, 70, "Text"],
Cell[85209, 2559, 88, 3, 70, "Input"],
Cell[85300, 2564, 368, 12, 70, "Text"],
Cell[85671, 2578, 150, 4, 70, "Input"],
Cell[85824, 2584, 174, 5, 70, "Text"],
Cell[86001, 2591, 392, 8, 70, "Input"],
Cell[86396, 2601, 79, 2, 70, "Input"],
Cell[86478, 2605, 262, 8, 70, "Text"],
Cell[86743, 2615, 160, 4, 70, "Input"],
Cell[86906, 2621, 299, 11, 70, "Text"],
Cell[87208, 2634, 416, 8, 70, "Input"],
Cell[87627, 2644, 109, 3, 70, "Text"],
Cell[87739, 2649, 110, 3, 70, "Input"],
Cell[87852, 2654, 203, 6, 70, "Text"],
Cell[88058, 2662, 720, 11, 70, "Input"],
Cell[88781, 2675, 1345, 25, 70, "Input"],
Cell[90129, 2702, 48, 0, 70, "Text"],
Cell[90180, 2704, 202, 6, 70, "Input"],
Cell[90385, 2712, 384, 12, 70, "ProgramLabel"],
Cell[90772, 2726, 109, 4, 70, "Program"],
Cell[90884, 2732, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[90958, 2738, 180, 6, 70, "ExerciseHeading"],
Cell[91141, 2746, 104, 3, 70, "Text"],

Cell[CellGroupData[{
Cell[91270, 2753, 938, 27, 70, "SolutionSubgroup"],
Cell[92211, 2782, 294, 6, 70, "Input"],
Cell[92508, 2790, 107, 3, 70, "Input"],
Cell[92618, 2795, 1162, 26, 70, "Text"],
Cell[93783, 2823, 3006, 55, 70, "Input"],
Cell[96792, 2880, 236, 5, 70, "Text"],
Cell[97031, 2887, 406, 9, 70, "Input"],
Cell[97440, 2898, 66, 0, 70, "Text"],
Cell[97509, 2900, 106, 3, 70, "Input"],
Cell[97618, 2905, 69, 0, 70, "Text"],
Cell[97690, 2907, 366, 8, 70, "Input"],
Cell[98059, 2917, 289, 7, 70, "Text"],
Cell[98351, 2926, 336, 6, 70, "Input"],
Cell[98690, 2934, 174, 4, 70, "Text"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[98925, 2945, 45, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[98995, 2949, 192, 6, 70, "ExerciseHeading"],
Cell[99190, 2957, 1065, 36, 70, "Text"],

Cell[CellGroupData[{
Cell[100280, 2997, 791, 25, 70, "SolutionSubgroup"],
Cell[101074, 3024, 876, 16, 70, "Input"],
Cell[101953, 3042, 696, 21, 70, "Text"],
Cell[102652, 3065, 207, 5, 70, "Input"],
Cell[102862, 3072, 249, 6, 70, "Input"],
Cell[103114, 3080, 322, 11, 70, "Text"],
Cell[103439, 3093, 267, 7, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[103755, 3106, 185, 6, 70, "ExerciseHeading"],
Cell[103943, 3114, 1242, 34, 70, "Text"],

Cell[CellGroupData[{
Cell[105210, 3152, 461, 14, 70, "SolutionSubgroup"],
Cell[105674, 3168, 60, 0, 70, "Input"],
Cell[105737, 3170, 475, 11, 70, "Input"],
Cell[106215, 3183, 135, 3, 70, "Input"],
Cell[106353, 3188, 522, 17, 70, "Text"],
Cell[106878, 3207, 450, 8, 70, "Input"],
Cell[107331, 3217, 635, 11, 70, "Input"],
Cell[107969, 3230, 144, 5, 70, "Text"],
Cell[108116, 3237, 222, 5, 70, "Input"],
Cell[108341, 3244, 186, 4, 70, "Text"],
Cell[108530, 3250, 117, 3, 70, "Input"],
Cell[108650, 3255, 430, 8, 70, "Text"],
Cell[109083, 3265, 2215, 40, 70, "Input"],
Cell[111301, 3307, 228, 6, 70, "Text"],
Cell[111532, 3315, 276, 5, 70, "Input"],
Cell[111811, 3322, 295, 6, 70, "Text"],
Cell[112109, 3330, 1338, 24, 70, "Input"],
Cell[113450, 3356, 135, 3, 70, "Text"],
Cell[113588, 3361, 323, 6, 70, "Input"],
Cell[113914, 3369, 160, 4, 70, "Text"],
Cell[114077, 3375, 402, 13, 70, "ProgramLabel"],
Cell[114482, 3390, 301, 7, 70, "Program"],
Cell[114786, 3399, 25, 0, 70, "ProgramBottom"],
Cell[114814, 3401, 873, 26, 70, "Text"],
Cell[115690, 3429, 279, 7, 70, "Input"],
Cell[115972, 3438, 74, 0, 70, "Text"],
Cell[116049, 3440, 318, 8, 70, "Input"],
Cell[116370, 3450, 708, 23, 70, "Text"],
Cell[117081, 3475, 340, 6, 70, "Input"],
Cell[117424, 3483, 923, 25, 70, "Text"],
Cell[118350, 3510, 740, 12, 70, "Input"],
Cell[119093, 3524, 119, 3, 70, "Text"],
Cell[119215, 3529, 97, 3, 70, "Input"],
Cell[119315, 3534, 290, 5, 70, "Text"],
Cell[119608, 3541, 932, 15, 70, "Input"],
Cell[120543, 3558, 176, 6, 70, "Text"],
Cell[120722, 3566, 47, 0, 70, "Input"],
Cell[120772, 3568, 134, 3, 70, "Text"],
Cell[120909, 3573, 274, 5, 70, "Input"],
Cell[121186, 3580, 848, 14, 70, "Input"],
Cell[122037, 3596, 58, 0, 70, "Input"],
Cell[122098, 3598, 618, 14, 70, "Text"],
Cell[122719, 3614, 250, 6, 70, "Input"],
Cell[122972, 3622, 177, 6, 70, "Text"],
Cell[123152, 3630, 117, 3, 70, "Input"],
Cell[123272, 3635, 313, 8, 70, "Text"],
Cell[123588, 3645, 152, 3, 70, "Input"],
Cell[123743, 3650, 314, 9, 70, "Text"],
Cell[124060, 3661, 49, 0, 70, "Input"],
Cell[124112, 3663, 62, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[124223, 3669, 179, 6, 70, "ExerciseHeading"],
Cell[124405, 3677, 710, 14, 70, "Text"],

Cell[CellGroupData[{
Cell[125140, 3695, 391, 11, 70, "SolutionSubgroup"],
Cell[125534, 3708, 647, 14, 70, "Input"],
Cell[126184, 3724, 67, 0, 70, "Input"],
Cell[126254, 3726, 411, 9, 70, "Input"],
Cell[126668, 3737, 3358, 94, 70, "Text"],
Cell[130029, 3833, 299, 10, 70, "Text"],
Cell[130331, 3845, 97, 3, 70, "Input"],
Cell[130431, 3850, 99, 3, 70, "Text"],
Cell[130533, 3855, 245, 5, 70, "Input"],
Cell[130781, 3862, 279, 9, 70, "Text"],
Cell[131063, 3873, 608, 10, 70, "Input"],
Cell[131674, 3885, 258, 5, 70, "Input"],
Cell[131935, 3892, 362, 10, 70, "Text"],
Cell[132300, 3904, 430, 7, 70, "Input"],
Cell[132733, 3913, 226, 5, 70, "Text"],
Cell[132962, 3920, 250, 5, 70, "Input"],
Cell[133215, 3927, 295, 7, 70, "Text"],
Cell[133513, 3936, 236, 6, 70, "Input"],
Cell[133752, 3944, 311, 8, 70, "Text"],
Cell[134066, 3954, 174, 4, 70, "Input"],
Cell[134243, 3960, 71, 0, 70, "Text"],
Cell[134317, 3962, 166, 4, 70, "Input"],
Cell[134486, 3968, 173, 4, 70, "Text"],
Cell[134662, 3974, 337, 8, 70, "Input"],
Cell[135002, 3984, 138, 3, 70, "Text"],
Cell[135143, 3989, 563, 9, 70, "Input"],
Cell[135709, 4000, 160, 4, 70, "Text"],
Cell[135872, 4006, 198, 4, 70, "Input"],
Cell[136073, 4012, 205, 4, 70, "Input"],
Cell[136281, 4018, 200, 4, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[136530, 4028, 177, 6, 70, "ExerciseHeading"],

Cell[CellGroupData[{
Cell[136732, 4038, 757, 21, 70, "SolutionSubgroup"],
Cell[137492, 4061, 138, 3, 70, "Text"],
Cell[137633, 4066, 94, 3, 70, "Input"],
Cell[137730, 4071, 106, 4, 70, "Text"],
Cell[137839, 4077, 208, 4, 70, "Input"],
Cell[138050, 4083, 294, 10, 70, "Text"],
Cell[138347, 4095, 466, 8, 70, "Input"],
Cell[138816, 4105, 554, 19, 70, "Text"],
Cell[139373, 4126, 320, 6, 70, "Input"],
Cell[139696, 4134, 531, 9, 70, "Input"],
Cell[140230, 4145, 489, 12, 70, "Text"],
Cell[140722, 4159, 744, 13, 70, "Input"],
Cell[141469, 4174, 122, 4, 70, "Text"],
Cell[141594, 4180, 999, 17, 70, "Input"],
Cell[142596, 4199, 621, 15, 70, "Text"],
Cell[143220, 4216, 191, 5, 70, "Input"],
Cell[143414, 4223, 1003, 19, 70, "Input"],
Cell[144420, 4244, 384, 9, 70, "Text"],
Cell[144807, 4255, 436, 7, 70, "Input"],
Cell[145246, 4264, 239, 5, 70, "Input"],
Cell[145488, 4271, 403, 9, 70, "Text"],
Cell[145894, 4282, 1213, 21, 70, "Input"],
Cell[147110, 4305, 169, 4, 70, "Text"],
Cell[147282, 4311, 370, 8, 70, "Input"],
Cell[147655, 4321, 110, 3, 70, "Text"],
Cell[147768, 4326, 311, 6, 70, "Input"],
Cell[148082, 4334, 496, 10, 70, "Input"],
Cell[148581, 4346, 191, 4, 70, "Text"],
Cell[148775, 4352, 844, 13, 70, "Input"],
Cell[149622, 4367, 1054, 16, 70, "Input"],
Cell[150679, 4385, 138, 4, 70, "Text"],
Cell[150820, 4391, 323, 8, 70, "Input"],
Cell[151146, 4401, 230, 5, 70, "Text"],
Cell[151379, 4408, 1621, 27, 70, "Input"],
Cell[153003, 4437, 149, 3, 70, "Text"],
Cell[153155, 4442, 337, 7, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[153541, 4455, 189, 6, 70, "ExerciseHeading"],
Cell[153733, 4463, 357, 6, 70, "Text"],

Cell[CellGroupData[{
Cell[154115, 4473, 476, 11, 70, "SolutionSubgroup"],
Cell[154594, 4486, 67, 0, 70, "Input"],
Cell[154664, 4488, 919, 14, 70, "Input"],
Cell[155586, 4504, 587, 11, 70, "Input"],
Cell[156176, 4517, 233, 9, 70, "Text"],
Cell[156412, 4528, 172, 4, 70, "Input"],
Cell[156587, 4534, 76, 0, 70, "Input"],
Cell[156666, 4536, 333, 8, 70, "Text"],
Cell[157002, 4546, 281, 6, 70, "Input"],
Cell[157286, 4554, 119, 3, 70, "Input"],
Cell[157408, 4559, 211, 4, 70, "Text"],
Cell[157622, 4565, 239, 6, 70, "Input"],
Cell[157864, 4573, 186, 4, 70, "Text"],
Cell[158053, 4579, 154, 4, 70, "Input"],
Cell[158210, 4585, 55, 0, 70, "Text"],
Cell[158268, 4587, 564, 11, 70, "Input"],
Cell[158835, 4600, 209, 4, 70, "Text"],
Cell[159047, 4606, 206, 5, 70, "Input"],
Cell[159256, 4613, 1216, 34, 70, "Text"],
Cell[160475, 4649, 1022, 18, 70, "Input"],
Cell[161500, 4669, 138, 3, 70, "Text"],
Cell[161641, 4674, 200, 5, 70, "Input"],
Cell[161844, 4681, 132, 5, 70, "Input"],
Cell[161979, 4688, 169, 4, 70, "Text"],
Cell[162151, 4694, 188, 4, 70, "Input"],
Cell[162342, 4700, 418, 10, 70, "Text"],
Cell[162763, 4712, 1207, 21, 70, "Input"],
Cell[163973, 4735, 1009, 18, 70, "Input"],
Cell[164985, 4755, 132, 4, 70, "Text"],
Cell[165120, 4761, 262, 5, 70, "Input"],
Cell[165385, 4768, 563, 9, 70, "Text"],
Cell[165951, 4779, 53, 0, 70, "Input"],
Cell[166007, 4781, 234, 5, 70, "Text"],
Cell[166244, 4788, 455, 9, 70, "Input"],
Cell[166702, 4799, 359, 6, 70, "Text"],
Cell[167064, 4807, 471, 9, 70, "Input"],
Cell[167538, 4818, 282, 9, 70, "Text"],
Cell[167823, 4829, 68, 0, 70, "Input"],
Cell[167894, 4831, 336, 8, 70, "Text"],
Cell[168233, 4841, 374, 10, 70, "Text"],
Cell[168610, 4853, 277, 7, 70, "Input"],
Cell[168890, 4862, 285, 6, 70, "Input"],
Cell[169178, 4870, 231, 5, 70, "Input"],
Cell[169412, 4877, 132, 3, 70, "Text"],
Cell[169547, 4882, 266, 5, 70, "Input"],
Cell[169816, 4889, 178, 4, 70, "Input"],
Cell[169997, 4895, 185, 4, 70, "Text"],
Cell[170185, 4901, 531, 10, 70, "Input"],
Cell[170719, 4913, 525, 10, 70, "Input"],
Cell[171247, 4925, 74, 0, 70, "Text"],
Cell[171324, 4927, 338, 9, 70, "Input"],
Cell[171665, 4938, 1121, 40, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[172835, 4984, 168, 6, 70, "ExerciseHeading"],
Cell[173006, 4992, 249, 5, 70, "Text"],

Cell[CellGroupData[{
Cell[173280, 5001, 164, 4, 70, "SolutionSubgroup"],
Cell[173447, 5007, 694, 22, 70, "Text"],
Cell[174144, 5031, 1029, 16, 70, "Input"],
Cell[175176, 5049, 636, 21, 70, "Text"],
Cell[175815, 5072, 439, 9, 70, "Input"],
Cell[176257, 5083, 123, 4, 70, "Text"],
Cell[176383, 5089, 262, 5, 70, "Input"],
Cell[176648, 5096, 157, 4, 70, "Text"],
Cell[176808, 5102, 1493, 22, 70, "Input"],
Cell[178304, 5126, 184, 5, 70, "Text"],
Cell[178491, 5133, 286, 6, 70, "Input"],
Cell[178780, 5141, 606, 23, 70, "Text"],
Cell[179389, 5166, 172, 4, 70, "Input"],
Cell[179564, 5172, 383, 12, 70, "Text"],
Cell[179950, 5186, 1168, 18, 70, "Input"],
Cell[181121, 5206, 125, 3, 70, "Text"],
Cell[181249, 5211, 365, 6, 70, "Input"],
Cell[181617, 5219, 205, 4, 70, "Text"],
Cell[181825, 5225, 482, 8, 70, "Input"],
Cell[182310, 5235, 407, 15, 70, "Text"],
Cell[182720, 5252, 287, 8, 70, "Text"],
Cell[183010, 5262, 235, 5, 70, "Input"],
Cell[183248, 5269, 246, 5, 70, "Text"],
Cell[183497, 5276, 1151, 18, 70, "Input"],
Cell[184651, 5296, 773, 22, 70, "Text"],
Cell[185427, 5320, 252, 7, 70, "Input"],
Cell[185682, 5329, 419, 16, 70, "Text"],
Cell[186104, 5347, 321, 6, 70, "Input"],
Cell[186428, 5355, 308, 9, 70, "Text"],
Cell[186739, 5366, 167, 5, 70, "Input"],
Cell[186909, 5373, 1371, 21, 70, "Input"],
Cell[188283, 5396, 252, 5, 70, "Text"],
Cell[188538, 5403, 239, 6, 70, "Input"],
Cell[188780, 5411, 256, 8, 70, "Text"],
Cell[189039, 5421, 474, 11, 70, "Input"],
Cell[189516, 5434, 563, 17, 70, "Text"],
Cell[190082, 5453, 196, 5, 70, "Input"],
Cell[190281, 5460, 604, 14, 70, "Text"],
Cell[190888, 5476, 626, 12, 70, "Input"],
Cell[191517, 5490, 319, 9, 70, "Text"],
Cell[191839, 5501, 503, 8, 70, "Input"],
Cell[192345, 5511, 689, 23, 70, "Text"],
Cell[193037, 5536, 749, 15, 70, "Input"],
Cell[193789, 5553, 224, 4, 70, "Text"],
Cell[194016, 5559, 249, 5, 70, "Input"],
Cell[194268, 5566, 175, 5, 70, "Text"],
Cell[194446, 5573, 1222, 19, 70, "Input"],
Cell[195671, 5594, 476, 8, 70, "Text"],
Cell[196150, 5604, 769, 12, 70, "Input"],
Cell[196922, 5618, 180, 4, 70, "Text"],
Cell[197105, 5624, 160, 5, 70, "Input"],
Cell[197268, 5631, 231, 5, 70, "Text"],
Cell[197502, 5638, 1466, 25, 70, "Input"],
Cell[198971, 5665, 364, 6, 70, "Text"],
Cell[199338, 5673, 1254, 18, 70, "Input"],
Cell[200595, 5693, 246, 8, 70, "Text"],
Cell[200844, 5703, 227, 5, 70, "Input"],
Cell[201074, 5710, 114, 3, 70, "Text"],
Cell[201191, 5715, 119, 3, 70, "Input"],
Cell[201313, 5720, 218, 5, 70, "Text"],
Cell[201534, 5727, 1171, 19, 70, "Input"],
Cell[202708, 5748, 1465, 52, 70, "Text"],
Cell[204176, 5802, 404, 7, 70, "Input"],
Cell[204583, 5811, 419, 15, 70, "Text"],
Cell[205005, 5828, 427, 10, 70, "Input"],
Cell[205435, 5840, 91, 3, 70, "Text"],
Cell[205529, 5845, 303, 6, 70, "Input"],
Cell[205835, 5853, 1357, 20, 70, "Input"],
Cell[207195, 5875, 136, 3, 70, "Text"],
Cell[207334, 5880, 496, 8, 70, "Input"],
Cell[207833, 5890, 435, 17, 70, "Text"],
Cell[208271, 5909, 302, 5, 70, "Input"],
Cell[208576, 5916, 369, 6, 70, "Input"],
Cell[208948, 5924, 1199, 19, 70, "Input"],
Cell[210150, 5945, 198, 7, 70, "Text"],
Cell[210351, 5954, 430, 8, 70, "Input"],
Cell[210784, 5964, 327, 8, 70, "Text"],
Cell[211114, 5974, 260, 5, 70, "Input"],
Cell[211377, 5981, 2077, 69, 70, "Text"],
Cell[213457, 6052, 1015, 15, 70, "Input"],
Cell[214475, 6069, 373, 8, 70, "Text"],
Cell[214851, 6079, 2587, 41, 70, "Input"],
Cell[217441, 6122, 1213, 33, 70, "Text"],
Cell[218657, 6157, 253, 6, 70, "Input"],
Cell[218913, 6165, 424, 14, 70, "ProgramLabel"],
Cell[219340, 6181, 257, 6, 70, "Program"],
Cell[219600, 6189, 25, 0, 70, "ProgramBottom"],
Cell[219628, 6191, 692, 26, 70, "Text"],
Cell[220323, 6219, 921, 32, 70, "Text"],
Cell[221247, 6253, 889, 26, 70, "DisplayFormula"],
Cell[222139, 6281, 178, 5, 70, "Text"],
Cell[222320, 6288, 1670, 43, 70, "DisplayFormula"],
Cell[223993, 6333, 219, 5, 70, "Text"],
Cell[224215, 6340, 96, 3, 70, "Input"],
Cell[224314, 6345, 435, 9, 70, "Input"],
Cell[224752, 6356, 1619, 25, 70, "Input"],
Cell[226374, 6383, 52, 0, 70, "Text"],
Cell[226429, 6385, 180, 4, 70, "Input"],
Cell[226612, 6391, 185, 4, 70, "Input"],
Cell[226800, 6397, 62, 0, 70, "Text"],
Cell[226865, 6399, 143, 4, 70, "Input"],
Cell[227011, 6405, 629, 21, 70, "Text"],
Cell[227643, 6428, 2363, 83, 70, "Text"],
Cell[230009, 6513, 156, 6, 70, "ProgramLabel"],
Cell[230168, 6521, 1862, 30, 70, "Program"],
Cell[232033, 6553, 25, 0, 70, "ProgramBottom"],
Cell[232061, 6555, 280, 9, 70, "Text"],
Cell[232344, 6566, 770, 29, 70, "Text"],
Cell[233117, 6597, 156, 6, 70, "ProgramLabel"],
Cell[233276, 6605, 1731, 27, 70, "Program"],
Cell[235010, 6634, 25, 0, 70, "ProgramBottom"],
Cell[235038, 6636, 352, 9, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[235439, 6651, 175, 6, 70, "ExerciseHeading"],
Cell[235617, 6659, 2246, 68, 70, "Text"],
Cell[237866, 6729, 1414, 36, 70, "DisplayFormula"],

Cell[CellGroupData[{
Cell[239305, 6769, 533, 19, 70, "SolutionSubgroup"],
Cell[239841, 6790, 339, 6, 70, "Text"],
Cell[240183, 6798, 59, 0, 70, "Input"],
Cell[240245, 6800, 174, 4, 70, "Text"],
Cell[240422, 6806, 1199, 38, 70, "Text"],
Cell[241624, 6846, 723, 13, 70, "Input"],
Cell[242350, 6861, 110, 3, 70, "Text"],
Cell[242463, 6866, 36, 0, 70, "Input"],
Cell[242502, 6868, 36, 0, 70, "Input"],
Cell[242541, 6870, 665, 24, 70, "Text"],
Cell[243209, 6896, 602, 12, 70, "Input"],
Cell[243814, 6910, 205, 4, 70, "Text"],
Cell[244022, 6916, 55, 0, 70, "Input"],
Cell[244080, 6918, 55, 0, 70, "Input"],
Cell[244138, 6920, 295, 7, 70, "Text"],
Cell[244436, 6929, 244, 6, 70, "Input"],
Cell[244683, 6937, 257, 5, 70, "Input"],
Cell[244943, 6944, 795, 21, 70, "Text"],
Cell[245741, 6967, 266, 6, 70, "Input"],
Cell[246010, 6975, 480, 12, 70, "Text"],
Cell[246493, 6989, 222, 5, 70, "Input"],
Cell[246718, 6996, 259, 6, 70, "Text"],
Cell[246980, 7004, 267, 8, 70, "Input"],
Cell[247250, 7014, 348, 6, 70, "Text"],
Cell[247601, 7022, 217, 5, 70, "Input"],
Cell[247821, 7029, 121, 3, 70, "Input"],
Cell[247945, 7034, 498, 8, 70, "Input"],
Cell[248446, 7044, 217, 5, 70, "Text"],
Cell[248666, 7051, 92, 3, 70, "Input"],
Cell[248761, 7056, 134, 4, 70, "Input"],
Cell[248898, 7062, 754, 16, 70, "Text"],
Cell[249655, 7080, 492, 9, 70, "Input"],
Cell[250150, 7091, 1743, 31, 70, "Input"],
Cell[251896, 7124, 54, 0, 70, "Text"],
Cell[251953, 7126, 435, 8, 70, "Input"],
Cell[252391, 7136, 124, 3, 70, "Text"],
Cell[252518, 7141, 184, 4, 70, "Input"],
Cell[252705, 7147, 580, 18, 70, "Text"],
Cell[253288, 7167, 217, 5, 70, "Input"],
Cell[253508, 7174, 542, 9, 70, "Input"],
Cell[254053, 7185, 260, 6, 70, "Text"],
Cell[254316, 7193, 345, 10, 70, "Input"],
Cell[254664, 7205, 253, 5, 70, "Text"],
Cell[254920, 7212, 97, 3, 70, "Input"],
Cell[255020, 7217, 126, 3, 70, "Text"],
Cell[255149, 7222, 227, 5, 70, "Input"],
Cell[255379, 7229, 436, 11, 70, "Text"],
Cell[255818, 7242, 53, 0, 70, "Input"],
Cell[255874, 7244, 143, 3, 70, "Text"],
Cell[256020, 7249, 497, 9, 70, "Input"],
Cell[256520, 7260, 70, 0, 70, "Text"],
Cell[256593, 7262, 442, 8, 70, "Input"],
Cell[257038, 7272, 376, 8, 70, "Text"],
Cell[257417, 7282, 193, 5, 70, "Input"],
Cell[257613, 7289, 575, 13, 70, "Text"],
Cell[258191, 7304, 1381, 23, 70, "Input"],
Cell[259575, 7329, 275, 7, 70, "Text"],
Cell[259853, 7338, 70, 0, 70, "Input"],
Cell[259926, 7340, 133, 3, 70, "Input"],
Cell[260062, 7345, 105, 3, 70, "Text"],
Cell[260170, 7350, 227, 4, 70, "Input"],
Cell[260400, 7356, 412, 10, 70, "Text"],
Cell[260815, 7368, 157, 4, 70, "Input"],
Cell[260975, 7374, 411, 9, 70, "Text"],
Cell[261389, 7385, 232, 5, 70, "Input"],
Cell[261624, 7392, 174, 4, 70, "Input"],
Cell[261801, 7398, 900, 23, 70, "Text"],
Cell[262704, 7423, 181, 5, 70, "Input"],
Cell[262888, 7430, 450, 9, 70, "Text"],
Cell[263341, 7441, 183, 5, 70, "Input"],
Cell[263527, 7448, 364, 8, 70, "Text"],
Cell[263894, 7458, 730, 13, 70, "Input"],
Cell[264627, 7473, 312, 5, 70, "Input"],
Cell[264942, 7480, 71, 0, 70, "Text"],
Cell[265016, 7482, 107, 3, 70, "Input"],
Cell[265126, 7487, 255, 5, 70, "Text"],
Cell[265384, 7494, 107, 3, 70, "Input"],
Cell[265494, 7499, 307, 11, 70, "Text"],
Cell[265804, 7512, 144, 4, 70, "Input"],
Cell[265951, 7518, 918, 17, 70, "Text"],
Cell[266872, 7537, 571, 10, 70, "Input"],
Cell[267446, 7549, 331, 6, 70, "Input"],
Cell[267780, 7557, 645, 11, 70, "Input"],
Cell[268428, 7570, 894, 15, 70, "Input"],
Cell[269325, 7587, 66, 0, 70, "Text"],
Cell[269394, 7589, 121, 4, 70, "Input"],
Cell[269518, 7595, 121, 4, 70, "Input"],
Cell[269642, 7601, 121, 4, 70, "Input"],
Cell[269766, 7607, 1369, 28, 70, "Text"],
Cell[271138, 7637, 265, 6, 70, "Input"],
Cell[271406, 7645, 1606, 28, 70, "Input"],
Cell[273015, 7675, 33, 0, 70, "Input"],
Cell[273051, 7677, 265, 5, 70, "Text"],
Cell[273319, 7684, 192, 5, 70, "Input"],
Cell[273514, 7691, 470, 14, 70, "Text"],
Cell[273987, 7707, 190, 5, 70, "Input"],
Cell[274180, 7714, 968, 33, 70, "Text"],
Cell[275151, 7749, 317, 7, 70, "Input"],
Cell[275471, 7758, 385, 9, 70, "Input"],
Cell[275859, 7769, 935, 35, 70, "Text"],
Cell[276797, 7806, 284, 5, 70, "Text"],
Cell[277084, 7813, 1781, 28, 70, "Input"],
Cell[278868, 7843, 190, 4, 70, "Input"],
Cell[279061, 7849, 255, 5, 70, "Text"],
Cell[279319, 7856, 296, 7, 70, "Input"],
Cell[279618, 7865, 1277, 45, 70, "Text"],
Cell[280898, 7912, 504, 9, 70, "Input"],
Cell[281405, 7923, 523, 16, 70, "Text"],
Cell[281931, 7941, 51, 0, 70, "Input"],
Cell[281985, 7943, 133, 3, 70, "Text"],
Cell[282121, 7948, 303, 7, 70, "Input"],
Cell[282427, 7957, 97, 3, 70, "Text"],
Cell[282527, 7962, 148, 3, 70, "Input"],
Cell[282678, 7967, 186, 4, 70, "Input"],
Cell[282867, 7973, 504, 14, 70, "Input"],
Cell[283374, 7989, 222, 5, 70, "Input"],
Cell[283599, 7996, 287, 5, 70, "Text"],
Cell[283889, 8003, 1290, 21, 70, "Input"],
Cell[285182, 8026, 118, 3, 70, "Text"],
Cell[285303, 8031, 63, 0, 70, "Input"],
Cell[285369, 8033, 551, 15, 70, "Text"],
Cell[285923, 8050, 42, 0, 70, "Input"],
Cell[285968, 8052, 324, 8, 70, "Text"],
Cell[286295, 8062, 226, 4, 70, "Input"],
Cell[286524, 8068, 408, 11, 70, "Text"],
Cell[286935, 8081, 97, 3, 70, "Input"],
Cell[287035, 8086, 231, 5, 70, "Text"],
Cell[287269, 8093, 348, 6, 70, "Input"],
Cell[287620, 8101, 54, 0, 70, "Text"],
Cell[287677, 8103, 140, 4, 70, "Input"],
Cell[287820, 8109, 116, 3, 70, "Text"],
Cell[287939, 8114, 150, 4, 70, "Input"],
Cell[288092, 8120, 2000, 58, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[290141, 8184, 190, 6, 70, "ExerciseHeading"],
Cell[290334, 8192, 483, 17, 70, "InlineFormula"],
Cell[290820, 8211, 1295, 34, 70, "DisplayFormula"],
Cell[292118, 8247, 299, 10, 70, "Text"],
Cell[292420, 8259, 975, 26, 70, "DisplayFormula"],
Cell[293398, 8287, 2050, 77, 70, "Text"],
Cell[295451, 8366, 253, 9, 70, "Text"],
Cell[295707, 8377, 984, 25, 70, "DisplayFormula"],
Cell[296694, 8404, 650, 22, 70, "Text"],
Cell[297347, 8428, 1696, 42, 70, "DisplayFormula"],
Cell[299046, 8472, 104, 3, 70, "Text"],
Cell[299153, 8477, 539, 14, 70, "DisplayFormula"],
Cell[299695, 8493, 471, 13, 70, "Text"],

Cell[CellGroupData[{
Cell[300191, 8510, 1399, 40, 70, "SolutionSubgroup"],
Cell[301593, 8552, 168, 4, 70, "Input"],
Cell[301764, 8558, 314, 5, 70, "Text"],
Cell[302081, 8565, 1265, 20, 70, "Input"],
Cell[303349, 8587, 1355, 36, 70, "Text"],
Cell[304707, 8625, 728, 14, 70, "Input"],
Cell[305438, 8641, 131, 3, 70, "Text"],
Cell[305572, 8646, 297, 7, 70, "Input"],
Cell[305872, 8655, 888, 18, 70, "Text"],
Cell[306763, 8675, 191, 4, 70, "Input"],
Cell[306957, 8681, 1194, 33, 70, "Text"],
Cell[308154, 8716, 164, 4, 70, "Input"],
Cell[308321, 8722, 140, 3, 70, "Text"],
Cell[308464, 8727, 414, 7, 70, "Input"],
Cell[308881, 8736, 4047, 135, 70, "Text"],
Cell[312931, 8873, 2628, 71, 70, "DisplayFormula"],
Cell[315562, 8946, 2172, 60, 70, "Text"],
Cell[317737, 9008, 1550, 26, 70, "Input"],
Cell[319290, 9036, 749, 23, 70, "Text"],
Cell[320042, 9061, 531, 9, 70, "Input"],
Cell[320576, 9072, 712, 12, 70, "Input"],
Cell[321291, 9086, 3061, 108, 70, "Text"],
Cell[324355, 9196, 111, 3, 70, "Input"],
Cell[324469, 9201, 596, 11, 70, "Input"],
Cell[325068, 9214, 130, 3, 70, "Text"],
Cell[325201, 9219, 284, 7, 70, "Input"],
Cell[325488, 9228, 562, 17, 70, "Text"],
Cell[326053, 9247, 1015, 16, 70, "Input"],
Cell[327071, 9265, 537, 12, 70, "Text"],
Cell[327611, 9279, 492, 12, 70, "Text"],
Cell[328106, 9293, 64, 0, 70, "Input"],
Cell[328173, 9295, 103, 3, 70, "Input"],
Cell[328279, 9300, 1255, 37, 70, "Text"],
Cell[329537, 9339, 434, 8, 70, "Input"],
Cell[329974, 9349, 299, 5, 70, "Text"],
Cell[330276, 9356, 1598, 28, 70, "Input"],
Cell[331877, 9386, 672, 17, 70, "Text"],
Cell[332552, 9405, 246, 6, 70, "Input"],
Cell[332801, 9413, 416, 10, 70, "Text"],
Cell[333220, 9425, 1353, 23, 70, "Input"],
Cell[334576, 9450, 251, 6, 70, "Text"],
Cell[334830, 9458, 365, 8, 70, "Input"],
Cell[335198, 9468, 426, 14, 70, "ProgramLabel"],
Cell[335627, 9484, 119, 3, 70, "Program"],
Cell[335749, 9489, 25, 0, 70, "ProgramBottom"],
Cell[335777, 9491, 718, 16, 70, "Text"],
Cell[336498, 9509, 374, 8, 70, "Input"],
Cell[336875, 9519, 1270, 43, 70, "Text"],
Cell[338148, 9564, 446, 9, 70, "Input"],
Cell[338597, 9575, 292, 10, 70, "Text"],
Cell[338892, 9587, 1725, 65, 70, "Text"],
Cell[340620, 9654, 2567, 96, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[343236, 9756, 194, 6, 70, "ExerciseHeading"],
Cell[343433, 9764, 230, 8, 70, "Text"],
Cell[343666, 9774, 1375, 32, 70, "DisplayFormula"],
Cell[345044, 9808, 748, 26, 70, "Text"],

Cell[CellGroupData[{
Cell[345817, 9838, 154, 3, 70, "SolutionSubgroup"],
Cell[345974, 9843, 234, 5, 70, "Input"],
Cell[346211, 9850, 59, 0, 70, "Input"],
Cell[346273, 9852, 1960, 63, 70, "Text"],
Cell[348236, 9917, 456, 9, 70, "Input"],
Cell[348695, 9928, 740, 13, 70, "Input"],
Cell[349438, 9943, 519, 17, 70, "Text"],
Cell[349960, 9962, 1523, 24, 70, "Input"],
Cell[351486, 9988, 468, 15, 70, "Text"],
Cell[351957, 10005, 585, 10, 70, "Input"],
Cell[352545, 10017, 277, 9, 70, "Text"],
Cell[352825, 10028, 399, 13, 70, "ProgramLabel"],
Cell[353227, 10043, 109, 3, 70, "Program"],
Cell[353339, 10048, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[353413, 10054, 191, 6, 70, "ExerciseHeading"],
Cell[353607, 10062, 1300, 39, 70, "Text"],

Cell[CellGroupData[{
Cell[354932, 10105, 369, 10, 70, "SolutionSubgroup"],
Cell[355304, 10117, 150, 3, 70, "Input"],
Cell[355457, 10122, 1029, 31, 70, "Text"],
Cell[356489, 10155, 1223, 19, 70, "Input"],
Cell[357715, 10176, 548, 10, 70, "Input"],
Cell[358266, 10188, 1195, 20, 70, "Text"],
Cell[359464, 10210, 3050, 50, 70, "Input"],
Cell[362517, 10262, 258, 7, 70, "Text"],
Cell[362778, 10271, 242, 5, 70, "Input"],
Cell[363023, 10278, 340, 8, 70, "Text"],
Cell[363366, 10288, 100, 3, 70, "Input"],
Cell[363469, 10293, 75, 0, 70, "Text"],
Cell[363547, 10295, 93, 3, 70, "Input"],
Cell[363643, 10300, 496, 10, 70, "Text"],
Cell[364142, 10312, 131, 4, 70, "Input"],
Cell[364276, 10318, 248, 7, 70, "Text"],
Cell[364527, 10327, 86, 3, 70, "Input"],
Cell[364616, 10332, 335, 6, 70, "Text"],
Cell[364954, 10340, 726, 13, 70, "Input"],
Cell[365683, 10355, 286, 6, 70, "Input"],
Cell[365972, 10363, 336, 6, 70, "Text"],
Cell[366311, 10371, 1330, 21, 70, "Input"],
Cell[367644, 10394, 384, 12, 70, "Text"],
Cell[368031, 10408, 414, 9, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[368494, 10423, 184, 6, 70, "ExerciseHeading"],
Cell[368681, 10431, 635, 22, 70, "Text"],
Cell[369319, 10455, 967, 26, 70, "Input",
  Evaluatable->False],
Cell[370289, 10483, 1277, 38, 70, "Text"],

Cell[CellGroupData[{
Cell[371591, 10525, 354, 11, 70, "SolutionSubgroup"],
Cell[371948, 10538, 138, 4, 70, "Input"],
Cell[372089, 10544, 223, 5, 70, "Input"],
Cell[372315, 10551, 1965, 57, 70, "Text"],
Cell[374283, 10610, 265, 5, 70, "Input"],
Cell[374551, 10617, 376, 12, 70, "Text"],
Cell[374930, 10631, 742, 12, 70, "Input"],
Cell[375675, 10645, 421, 11, 70, "Text"],
Cell[376099, 10658, 253, 6, 70, "Input"],
Cell[376355, 10666, 91, 3, 70, "Text"],
Cell[376449, 10671, 511, 11, 70, "Input"],
Cell[376963, 10684, 432, 13, 70, "Text"],
Cell[377398, 10699, 171, 4, 70, "Input"],
Cell[377572, 10705, 181, 4, 70, "Input"],
Cell[377756, 10711, 198, 4, 70, "Input"],
Cell[377957, 10717, 360, 6, 70, "Input"],
Cell[378320, 10725, 554, 10, 70, "Input"],
Cell[378877, 10737, 449, 8, 70, "Text"],
Cell[379329, 10747, 380, 7, 70, "Input"],
Cell[379712, 10756, 175, 4, 70, "Input"],
Cell[379890, 10762, 134, 4, 70, "Input"],
Cell[380027, 10768, 229, 8, 70, "Text"],
Cell[380259, 10778, 261, 5, 70, "Input"],
Cell[380523, 10785, 181, 4, 70, "Input"],
Cell[380707, 10791, 183, 4, 70, "Text"],
Cell[380893, 10797, 358, 8, 70, "Input"],
Cell[381254, 10807, 192, 5, 70, "Input"],
Cell[381449, 10814, 370, 6, 70, "Input"],
Cell[381822, 10822, 458, 8, 70, "Input"],
Cell[382283, 10832, 169, 4, 70, "Text"],
Cell[382455, 10838, 316, 8, 70, "Input"],
Cell[382774, 10848, 126, 3, 70, "Text"],
Cell[382903, 10853, 896, 16, 70, "Input"],
Cell[383802, 10871, 121, 3, 70, "Text"],
Cell[383926, 10876, 349, 6, 70, "Input"],
Cell[384278, 10884, 4021, 70, 70, "Input"],
Cell[388302, 10956, 1180, 22, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[389531, 10984, 164, 6, 70, "ExerciseHeading"],
Cell[389698, 10992, 2757, 88, 70, "Text"],

Cell[CellGroupData[{
Cell[392480, 11084, 1021, 27, 70, "SolutionSubgroup"],
Cell[393504, 11113, 1380, 29, 70, "Text"],
Cell[394887, 11144, 385, 7, 70, "Input"],
Cell[395275, 11153, 1459, 25, 70, "Input"],
Cell[396737, 11180, 119, 4, 70, "Text"],
Cell[396859, 11186, 71, 0, 70, "Input"],
Cell[396933, 11188, 132, 3, 70, "Text"],
Cell[397068, 11193, 61, 0, 70, "Input"],
Cell[397132, 11195, 40, 0, 70, "Input"],
Cell[397175, 11197, 55, 0, 70, "Text"],
Cell[397233, 11199, 1735, 55, 70, "Input"],
Cell[398971, 11256, 182, 4, 70, "Text"],
Cell[399156, 11262, 97, 3, 70, "Input"],
Cell[399256, 11267, 122, 3, 70, "Text"],
Cell[399381, 11272, 172, 4, 70, "Input"],
Cell[399556, 11278, 132, 3, 70, "Input"],
Cell[399691, 11283, 190, 4, 70, "Text"],
Cell[399884, 11289, 95, 3, 70, "Input"],
Cell[399982, 11294, 353, 7, 70, "Text"],
Cell[400338, 11303, 216, 5, 70, "Input"],
Cell[400557, 11310, 433, 15, 70, "Text"],
Cell[400993, 11327, 281, 6, 70, "Input"],
Cell[401277, 11335, 274, 5, 70, "Text"],
Cell[401554, 11342, 730, 12, 70, "Input"],
Cell[402287, 11356, 271, 5, 70, "Text"],
Cell[402561, 11363, 300, 6, 70, "Input"],
Cell[402864, 11371, 590, 11, 70, "Text"],
Cell[403457, 11384, 228, 5, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[403734, 11395, 182, 6, 70, "ExerciseHeading"],
Cell[403919, 11403, 134, 3, 70, "Text"],
Cell[404056, 11408, 2171, 54, 70, "DisplayFormula"],
Cell[406230, 11464, 563, 18, 70, "Text"],
Cell[406796, 11484, 1353, 43, 70, "Text"],

Cell[CellGroupData[{
Cell[408174, 11531, 633, 19, 70, "SolutionSubgroup"],
Cell[408810, 11552, 791, 12, 70, "Input"],
Cell[409604, 11566, 56, 0, 70, "Text"],
Cell[409663, 11568, 41, 0, 70, "Input"],
Cell[409707, 11570, 617, 24, 70, "Text"],
Cell[410327, 11596, 291, 5, 70, "Input"],
Cell[410621, 11603, 394, 13, 70, "Text"],
Cell[411018, 11618, 34, 0, 70, "Input"],
Cell[411055, 11620, 736, 19, 70, "Text"],
Cell[411794, 11641, 1599, 26, 70, "Input"],
Cell[413396, 11669, 1201, 33, 70, "Text"],
Cell[414600, 11704, 2099, 32, 70, "Input"],
Cell[416702, 11738, 251, 5, 70, "Text"],
Cell[416956, 11745, 631, 11, 70, "Input"],
Cell[417590, 11758, 1007, 21, 70, "Text"],
Cell[418600, 11781, 137, 4, 70, "Input"],
Cell[418740, 11787, 380, 12, 70, "ProgramLabel"],
Cell[419123, 11801, 77, 0, 70, "Program"],
Cell[419203, 11803, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[419289, 11810, 45, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[419359, 11814, 245, 9, 70, "ExerciseHeading"],
Cell[419607, 11825, 409, 15, 70, "Text"],
Cell[420019, 11842, 517, 13, 70, "DisplayFormula"],
Cell[420539, 11857, 231, 7, 70, "Text"],
Cell[420773, 11866, 1014, 27, 70, "DisplayFormula"],
Cell[421790, 11895, 418, 15, 70, "Text"],

Cell[CellGroupData[{
Cell[422233, 11914, 388, 8, 70, "SolutionSubgroup"],
Cell[422624, 11924, 138, 4, 70, "Input"],
Cell[422765, 11930, 106, 3, 70, "Text"],
Cell[422874, 11935, 1636, 42, 70, "DisplayFormula"],
Cell[424513, 11979, 722, 22, 70, "Text"],
Cell[425238, 12003, 2762, 70, 70, "DisplayFormula"],
Cell[428003, 12075, 1623, 48, 70, "Text"],
Cell[429629, 12125, 1257, 38, 70, "Text"],
Cell[430889, 12165, 827, 15, 70, "Input"],
Cell[431719, 12182, 303, 10, 70, "Text"],
Cell[432025, 12194, 561, 10, 70, "Input"],
Cell[432589, 12206, 343, 8, 70, "Text"],
Cell[432935, 12216, 308, 8, 70, "Input"],
Cell[433246, 12226, 113, 3, 70, "Text"],
Cell[433362, 12231, 583, 10, 70, "Input"],
Cell[433948, 12243, 137, 3, 70, "Text"],
Cell[434088, 12248, 269, 5, 70, "Input"],
Cell[434360, 12255, 566, 16, 70, "Text"],
Cell[434929, 12273, 120, 4, 70, "Input"],
Cell[435052, 12279, 460, 13, 70, "Text"],
Cell[435515, 12294, 122, 3, 70, "Input"],
Cell[435640, 12299, 598, 21, 70, "Text"],
Cell[436241, 12322, 92, 3, 70, "Input"],
Cell[436336, 12327, 126, 4, 70, "Input"],
Cell[436465, 12333, 226, 8, 70, "Text"],
Cell[436694, 12343, 124, 4, 70, "Input"],
Cell[436821, 12349, 569, 15, 70, "Text"],
Cell[437393, 12366, 1129, 19, 70, "Input"],
Cell[438525, 12387, 40, 0, 70, "Input"],
Cell[438568, 12389, 386, 14, 70, "Text"],
Cell[438957, 12405, 28, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[439034, 12411, 186, 6, 70, "ExerciseHeading"],
Cell[439223, 12419, 340, 10, 70, "Text"],
Cell[439566, 12431, 1269, 34, 70, "DisplayFormula"],

Cell[CellGroupData[{
Cell[440860, 12469, 1210, 29, 70, "SolutionSubgroup"],
Cell[442073, 12500, 1727, 35, 70, "Input"],
Cell[443803, 12537, 174, 4, 70, "Text"],
Cell[443980, 12543, 158, 4, 70, "Input"],
Cell[444141, 12549, 250, 5, 70, "Text"],
Cell[444394, 12556, 157, 4, 70, "Input"],
Cell[444554, 12562, 116, 3, 70, "Text"],
Cell[444673, 12567, 157, 6, 70, "ProgramLabel"],
Cell[444833, 12575, 256, 6, 70, "Program"],
Cell[445092, 12583, 25, 0, 70, "ProgramBottom"],
Cell[445120, 12585, 1154, 28, 70, "Input"],
Cell[446277, 12615, 49, 0, 70, "Text"],
Cell[446329, 12617, 43, 0, 70, "Input"],
Cell[446375, 12619, 235, 8, 70, "Text"],
Cell[446613, 12629, 421, 8, 70, "Input"],
Cell[447037, 12639, 64, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[447150, 12645, 342, 13, 70, "ExerciseHeading"],
Cell[447495, 12660, 369, 12, 70, "Text"],

Cell[CellGroupData[{
Cell[447889, 12676, 396, 11, 70, "SolutionSubgroup"],
Cell[448288, 12689, 437, 9, 70, "Input"],
Cell[448728, 12700, 169, 4, 70, "Text"],
Cell[448900, 12706, 999, 17, 70, "Input"],
Cell[449902, 12725, 510, 16, 70, "Text"],
Cell[450415, 12743, 337, 7, 70, "Input"],
Cell[450755, 12752, 660, 13, 70, "Text"],
Cell[451418, 12767, 3191, 51, 70, "Input"],
Cell[454612, 12820, 825, 29, 70, "Text"],
Cell[455440, 12851, 100, 3, 70, "Input"],
Cell[455543, 12856, 229, 8, 70, "Text"],
Cell[455775, 12866, 63, 0, 70, "Input"],
Cell[455841, 12868, 120, 3, 70, "Text"],
Cell[455964, 12873, 421, 14, 70, "ProgramLabel"],
Cell[456388, 12889, 286, 6, 70, "Program"],
Cell[456677, 12897, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[456763, 12904, 46, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[456834, 12908, 197, 6, 70, "ExerciseHeading"],
Cell[457034, 12916, 4141, 138, 70, "Text"],

Cell[CellGroupData[{
Cell[461200, 13058, 906, 29, 70, "SolutionSubgroup"],
Cell[462109, 13089, 283, 7, 70, "Input"],
Cell[462395, 13098, 204, 4, 70, "Text"],
Cell[462602, 13104, 70, 2, 70, "Input"],
Cell[462675, 13108, 88, 3, 70, "Text"],
Cell[462766, 13113, 61, 2, 70, "Input"],
Cell[462830, 13117, 276, 7, 70, "Text"],
Cell[463109, 13126, 191, 4, 70, "Input"],
Cell[463303, 13132, 428, 12, 70, "Text"],
Cell[463734, 13146, 214, 5, 70, "Input"],
Cell[463951, 13153, 74, 0, 70, "Input"],
Cell[464028, 13155, 955, 30, 70, "Text"],
Cell[464986, 13187, 425, 8, 70, "Input"],
Cell[465414, 13197, 305, 10, 70, "Text"],
Cell[465722, 13209, 42, 0, 70, "Input"],
Cell[465767, 13211, 192, 4, 70, "Input"],
Cell[465962, 13217, 274, 8, 70, "Text"],
Cell[466239, 13227, 114, 3, 70, "Input"],
Cell[466356, 13232, 77, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[466482, 13238, 183, 6, 70, "ExerciseHeading"],
Cell[466668, 13246, 239, 8, 70, "Text"],
Cell[466910, 13256, 2059, 51, 70, "DisplayFormula"],
Cell[468972, 13309, 1041, 33, 70, "Text"],
Cell[470016, 13344, 1413, 39, 70, "Text"],

Cell[CellGroupData[{
Cell[471454, 13387, 633, 16, 70, "SolutionSubgroup"],
Cell[472090, 13405, 1285, 25, 70, "Input"],
Cell[473378, 13432, 98, 3, 70, "Input"],
Cell[473479, 13437, 602, 17, 70, "Text"],
Cell[474084, 13456, 130, 3, 70, "Input"],
Cell[474217, 13461, 71, 0, 70, "Text"],
Cell[474291, 13463, 42, 0, 70, "Input"],
Cell[474336, 13465, 42, 0, 70, "Input"],
Cell[474381, 13467, 42, 0, 70, "Input"],
Cell[474426, 13469, 169, 6, 70, "Text"],
Cell[474598, 13477, 43, 0, 70, "Input"],
Cell[474644, 13479, 526, 17, 70, "Text"],
Cell[475173, 13498, 130, 3, 70, "Input"],
Cell[475306, 13503, 261, 10, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[475616, 13519, 179, 6, 70, "ExerciseHeading"],
Cell[475798, 13527, 753, 23, 70, "Text"],
Cell[476554, 13552, 1973, 49, 70, "DisplayFormula"],
Cell[478530, 13603, 1026, 30, 70, "Text"],

Cell[CellGroupData[{
Cell[479581, 13637, 754, 21, 70, "SolutionSubgroup"],
Cell[480338, 13660, 1313, 23, 70, "Input"],
Cell[481654, 13685, 266, 9, 70, "Text"],
Cell[481923, 13696, 102, 3, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[482074, 13705, 185, 6, 70, "ExerciseHeading"],
Cell[482262, 13713, 389, 15, 70, "Text"],
Cell[482654, 13730, 1247, 32, 70, "DisplayFormula"],
Cell[483904, 13764, 3575, 114, 70, "Text"],

Cell[CellGroupData[{
Cell[487504, 13882, 371, 10, 70, "SolutionSubgroup"],
Cell[487878, 13894, 305, 8, 70, "Input"],
Cell[488186, 13904, 188, 7, 70, "Text"],
Cell[488377, 13913, 31, 0, 70, "Input"],
Cell[488411, 13915, 31, 0, 70, "Input"],
Cell[488445, 13917, 31, 0, 70, "Input"],
Cell[488479, 13919, 190, 7, 70, "Text"],
Cell[488672, 13928, 51, 0, 70, "Input"],
Cell[488726, 13930, 932, 35, 70, "Text"],
Cell[489661, 13967, 145, 4, 70, "Input"],
Cell[489809, 13973, 473, 14, 70, "Text"],
Cell[490285, 13989, 101, 3, 70, "Input"],
Cell[490389, 13994, 101, 3, 70, "Input"],
Cell[490493, 13999, 292, 9, 70, "Text"],
Cell[490788, 14010, 387, 9, 70, "Input"],
Cell[491178, 14021, 214, 6, 70, "Text"],
Cell[491395, 14029, 708, 12, 70, "Input"],
Cell[492106, 14043, 180, 6, 70, "Text"],
Cell[492289, 14051, 189, 4, 70, "Input"],
Cell[492481, 14057, 208, 6, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[492738, 14069, 218, 6, 70, "ExerciseHeading"],
Cell[492959, 14077, 292, 8, 70, "Text"],
Cell[493254, 14087, 1100, 29, 70, "DisplayFormula"],
Cell[494357, 14118, 400, 16, 70, "Text"],
Cell[494760, 14136, 687, 22, 70, "Text"],

Cell[CellGroupData[{
Cell[495472, 14162, 256, 8, 70, "SolutionSubgroup"],
Cell[495731, 14172, 272, 5, 70, "Input"],
Cell[496006, 14179, 181, 7, 70, "Text"],
Cell[496190, 14188, 64, 0, 70, "Input"],
Cell[496257, 14190, 302, 5, 70, "Text"],
Cell[496562, 14197, 1803, 44, 70, "DisplayFormula"],
Cell[498368, 14243, 623, 19, 70, "Text"],
Cell[498994, 14264, 600, 10, 70, "Input"],
Cell[499597, 14276, 54, 0, 70, "Text"],
Cell[499654, 14278, 103, 3, 70, "Input"],
Cell[499760, 14283, 64, 0, 70, "Input"],
Cell[499827, 14285, 258, 10, 70, "Text"],
Cell[500088, 14297, 105, 3, 70, "Input"],
Cell[500196, 14302, 175, 4, 70, "Text"],
Cell[500374, 14308, 94, 4, 70, "Input"],
Cell[500471, 14314, 136, 3, 70, "Text"],
Cell[500610, 14319, 1735, 43, 70, "DisplayFormula"],
Cell[502348, 14364, 144, 4, 70, "Input"],
Cell[502495, 14370, 110, 3, 70, "Text"],
Cell[502608, 14375, 234, 5, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[502891, 14386, 184, 6, 70, "ExerciseHeading"],
Cell[503078, 14394, 190, 5, 70, "Text"],
Cell[503271, 14401, 1568, 36, 70, "DisplayFormula"],
Cell[504842, 14439, 1656, 39, 70, "DisplayFormula"],
Cell[506501, 14480, 291, 8, 70, "Text"],
Cell[506795, 14490, 593, 11, 70, "Input"],
Cell[507391, 14503, 49, 0, 70, "Text"],
Cell[507443, 14505, 372, 7, 70, "Input"],
Cell[507818, 14514, 482, 10, 70, "Input"],
Cell[508303, 14526, 502, 17, 70, "Text"],
Cell[508808, 14545, 145, 4, 70, "Input"],
Cell[508956, 14551, 223, 5, 70, "Input"],
Cell[509182, 14558, 229, 7, 70, "Text"],
Cell[509414, 14567, 255, 5, 70, "Input"],
Cell[509672, 14574, 102, 3, 70, "Text"],
Cell[509777, 14579, 57, 0, 70, "Input"],
Cell[509837, 14581, 161, 4, 70, "Input"],
Cell[510001, 14587, 241, 5, 70, "Input"],
Cell[510245, 14594, 581, 18, 70, "Text"],
Cell[510829, 14614, 74, 0, 70, "Input"],
Cell[510906, 14616, 195, 5, 70, "Input"],
Cell[511104, 14623, 32, 0, 70, "Input"],
Cell[511139, 14625, 150, 3, 70, "Text"],
Cell[511292, 14630, 263, 5, 70, "Input"],
Cell[511558, 14637, 262, 9, 70, "Text"],
Cell[511823, 14648, 374, 8, 70, "Input"],
Cell[512200, 14658, 268, 9, 70, "Text"],
Cell[512471, 14669, 377, 8, 70, "Input"],
Cell[512851, 14679, 106, 3, 70, "Input"],
Cell[512960, 14684, 280, 7, 70, "Text"],
Cell[513243, 14693, 200, 5, 70, "Input"],
Cell[513446, 14700, 572, 13, 70, "Input"],
Cell[514021, 14715, 407, 12, 70, "Text"],
Cell[514431, 14729, 51, 0, 70, "Input"],
Cell[514485, 14731, 508, 11, 70, "Input"],
Cell[514996, 14744, 234, 6, 70, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[515267, 14755, 182, 6, 70, "ExerciseHeading"],
Cell[515452, 14763, 2414, 83, 70, "Text"],

Cell[CellGroupData[{
Cell[517891, 14850, 624, 20, 70, "SolutionSubgroup"],
Cell[518518, 14872, 378, 10, 70, "Input"],
Cell[518899, 14884, 237, 10, 70, "Text"],
Cell[519139, 14896, 34, 0, 70, "Input"],
Cell[519176, 14898, 61, 0, 70, "Input"],
Cell[519240, 14900, 595, 19, 70, "Text"],
Cell[519838, 14921, 1029, 17, 70, "Input"],
Cell[520870, 14940, 35, 0, 70, "Input"],
Cell[520908, 14942, 464, 17, 70, "Text"],
Cell[521375, 14961, 1718, 56, 70, "Text"],
Cell[523096, 15019, 604, 11, 70, "Input"],
Cell[523703, 15032, 409, 8, 70, "Input"],
Cell[524115, 15042, 347, 14, 70, "Text"],
Cell[524465, 15058, 92, 3, 70, "Input"],
Cell[524560, 15063, 747, 20, 70, "Text"],
Cell[525310, 15085, 583, 10, 70, "Input"],
Cell[525896, 15097, 313, 7, 70, "Text"],
Cell[526212, 15106, 704, 12, 70, "Input"],
Cell[526919, 15120, 225, 9, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[527193, 15135, 192, 6, 70, "ExerciseHeading"],
Cell[527388, 15143, 2825, 86, 70, "Text"],
Cell[530216, 15231, 3340, 90, 70, "DisplayFormula"],
Cell[533559, 15323, 1574, 53, 70, "Text"],

Cell[CellGroupData[{
Cell[535158, 15380, 155, 4, 70, "SolutionSubgroup"],
Cell[535316, 15386, 274, 5, 70, "Input"],
Cell[535593, 15393, 526, 12, 70, "Text"],
Cell[536122, 15407, 361, 8, 70, "Input"],
Cell[536486, 15417, 570, 16, 70, "Text"],
Cell[537059, 15435, 221, 5, 70, "Input"],
Cell[537283, 15442, 344, 12, 70, "Text"],
Cell[537630, 15456, 92, 3, 70, "Input"],
Cell[537725, 15461, 1104, 30, 70, "Text"],
Cell[538832, 15493, 316, 6, 70, "Input"],
Cell[539151, 15501, 487, 14, 70, "Text"],
Cell[539641, 15517, 307, 6, 70, "Input"],
Cell[539951, 15525, 257, 7, 70, "Text"],
Cell[540211, 15534, 150, 3, 70, "Input"],
Cell[540364, 15539, 1602, 38, 70, "Text"],
Cell[541969, 15579, 1795, 30, 70, "Input"],
Cell[543767, 15611, 159, 5, 70, "Text"],
Cell[543929, 15618, 55, 0, 70, "Input"],
Cell[543987, 15620, 520, 11, 70, "Text"],
Cell[544510, 15633, 402, 13, 70, "ProgramLabel"],
Cell[544915, 15648, 131, 4, 70, "Program"],
Cell[545049, 15654, 25, 0, 70, "ProgramBottom"],
Cell[545077, 15656, 125, 3, 70, "Text"],
Cell[545205, 15661, 295, 6, 70, "Input"],
Cell[545503, 15669, 199, 4, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[545751, 15679, 180, 6, 70, "ExerciseHeading"],
Cell[545934, 15687, 4207, 119, 70, "Text"],

Cell[CellGroupData[{
Cell[550166, 15810, 761, 27, 70, "SolutionSubgroup"],
Cell[550930, 15839, 509, 10, 70, "Input"],
Cell[551442, 15851, 305, 9, 70, "Text"],
Cell[551750, 15862, 1003, 23, 70, "DisplayFormula"],
Cell[552756, 15887, 1539, 46, 70, "Text"],
Cell[554298, 15935, 136, 4, 70, "Input"],
Cell[554437, 15941, 234, 6, 70, "Input"],
Cell[554674, 15949, 580, 19, 70, "Text"],
Cell[555257, 15970, 313, 7, 70, "Input"],
Cell[555573, 15979, 558, 21, 70, "Text"],
Cell[556134, 16002, 89, 3, 70, "Input"],
Cell[556226, 16007, 590, 20, 70, "Text"],
Cell[556819, 16029, 148, 3, 70, "Input"],
Cell[556970, 16034, 1654, 54, 70, "Text"],
Cell[558627, 16090, 235, 5, 70, "Input"],
Cell[558865, 16097, 148, 3, 70, "Text"],
Cell[559016, 16102, 154, 4, 70, "Input"],
Cell[559173, 16108, 322, 11, 70, "Text"],
Cell[559498, 16121, 97, 3, 70, "Input"],
Cell[559598, 16126, 123, 3, 70, "Text"],
Cell[559724, 16131, 106, 3, 70, "Input"],
Cell[559833, 16136, 128, 3, 70, "Text"],
Cell[559964, 16141, 224, 5, 70, "Input"],
Cell[560191, 16148, 575, 20, 70, "Text"],
Cell[560769, 16170, 650, 11, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[561468, 16187, 178, 6, 70, "ExerciseHeading"],
Cell[561649, 16195, 1649, 53, 70, "Text"],

Cell[CellGroupData[{
Cell[563323, 16252, 1039, 31, 70, "SolutionSubgroup"],
Cell[564365, 16285, 1058, 19, 70, "Input"],
Cell[565426, 16306, 217, 6, 70, "Text"],
Cell[565646, 16314, 262, 6, 70, "Input"],
Cell[565911, 16322, 96, 3, 70, "Text"],
Cell[566010, 16327, 226, 6, 70, "Input"],
Cell[566239, 16335, 95, 3, 70, "Text"],
Cell[566337, 16340, 295, 8, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[566681, 16354, 175, 6, 70, "ExerciseHeading"],
Cell[566859, 16362, 1642, 54, 70, "Text"],
Cell[568504, 16418, 221, 4, 70, "Text"],

Cell[CellGroupData[{
Cell[568750, 16426, 953, 24, 70, "SolutionSubgroup"],
Cell[569706, 16452, 582, 20, 70, "Text"],
Cell[570291, 16474, 59, 0, 70, "Input"],
Cell[570353, 16476, 98, 3, 70, "Input"],
Cell[570454, 16481, 916, 15, 70, "Input"],
Cell[571373, 16498, 111, 3, 70, "Text"],
Cell[571487, 16503, 74, 2, 70, "Input"],
Cell[571564, 16507, 206, 6, 70, "Text"],
Cell[571773, 16515, 342, 6, 70, "Input"],
Cell[572118, 16523, 476, 17, 70, "Text"],
Cell[572597, 16542, 509, 9, 70, "Input"],
Cell[573109, 16553, 1017, 16, 70, "Input"],
Cell[574129, 16571, 786, 20, 70, "Text"],
Cell[574918, 16593, 147, 4, 70, "Input"],
Cell[575068, 16599, 112, 3, 70, "Text"],
Cell[575183, 16604, 638, 10, 70, "Input"],
Cell[575824, 16616, 285, 7, 70, "Text"],
Cell[576112, 16625, 119, 3, 70, "Input"],
Cell[576234, 16630, 207, 5, 70, "Input"],
Cell[576444, 16637, 102, 3, 70, "Text"],
Cell[576549, 16642, 314, 7, 70, "Input"],
Cell[576866, 16651, 322, 12, 70, "Text"],
Cell[577191, 16665, 350, 6, 70, "Input"],
Cell[577544, 16673, 347, 6, 70, "Input"],
Cell[577894, 16681, 94, 3, 70, "Text"],
Cell[577991, 16686, 899, 16, 70, "Input"],
Cell[578893, 16704, 1391, 32, 70, "Text"],
Cell[580287, 16738, 199, 4, 70, "Input"],
Cell[580489, 16744, 1597, 27, 70, "Input"],
Cell[582089, 16773, 299, 5, 70, "Text"],
Cell[582391, 16780, 43, 0, 70, "Input"],
Cell[582437, 16782, 554, 11, 70, "Text"],
Cell[582994, 16795, 1398, 24, 70, "Input"],
Cell[584395, 16821, 282, 5, 70, "Text"],
Cell[584680, 16828, 321, 8, 70, "Input"],
Cell[585004, 16838, 159, 4, 70, "Text"],
Cell[585166, 16844, 355, 9, 70, "Input"],
Cell[585524, 16855, 583, 19, 70, "Text"],
Cell[586110, 16876, 650, 12, 70, "Input"],
Cell[586763, 16890, 447, 7, 70, "Text"],
Cell[587213, 16899, 268, 6, 70, "Input"],
Cell[587484, 16907, 340, 9, 70, "Text"],
Cell[587827, 16918, 242, 5, 70, "Input"],
Cell[588072, 16925, 475, 9, 70, "Text"],
Cell[588550, 16936, 607, 10, 70, "Input"],
Cell[589160, 16948, 138, 3, 70, "Text"],
Cell[589301, 16953, 61, 0, 70, "Input"],
Cell[589365, 16955, 60, 0, 70, "Input"],
Cell[589428, 16957, 466, 8, 70, "Text"],
Cell[589897, 16967, 61, 0, 70, "Input"],
Cell[589961, 16969, 60, 0, 70, "Input"],
Cell[590024, 16971, 1069, 30, 70, "Text"],
Cell[591096, 17003, 97, 3, 70, "Input"],
Cell[591196, 17008, 97, 3, 70, "Input"],
Cell[591296, 17013, 97, 3, 70, "Input"],
Cell[591396, 17018, 807, 25, 70, "Text"],
Cell[592206, 17045, 311, 6, 70, "Input"],
Cell[592520, 17053, 946, 23, 70, "Text"],
Cell[593469, 17078, 116, 4, 70, "Input"],
Cell[593588, 17084, 434, 12, 70, "Text"],
Cell[594025, 17098, 61, 0, 70, "Input"],
Cell[594089, 17100, 60, 0, 70, "Input"],
Cell[594152, 17102, 329, 11, 70, "Text"],
Cell[594484, 17115, 347, 9, 70, "Text"],
Cell[594834, 17126, 263, 5, 70, "Input"],
Cell[595100, 17133, 221, 4, 70, "Text"],
Cell[595324, 17139, 1056, 20, 70, "Input"],
Cell[596383, 17161, 417, 10, 70, "Text"],
Cell[596803, 17173, 1927, 33, 70, "Input"],
Cell[598733, 17208, 61, 0, 70, "Text"],
Cell[598797, 17210, 144, 3, 70, "Input"],
Cell[598944, 17215, 289, 7, 70, "Input"],
Cell[599236, 17224, 417, 8, 70, "Text"],
Cell[599656, 17234, 975, 17, 70, "Input"],
Cell[600634, 17253, 440, 7, 70, "Text"],
Cell[601077, 17262, 293, 7, 70, "Input"],
Cell[601373, 17271, 180, 4, 70, "Text"],
Cell[601556, 17277, 144, 3, 70, "Input"],
Cell[601703, 17282, 289, 7, 70, "Input"],
Cell[601995, 17291, 713, 11, 70, "Text"],
Cell[602711, 17304, 718, 13, 70, "Input"],
Cell[603432, 17319, 3858, 61, 70, "Input"],
Cell[607293, 17382, 96, 3, 70, "Text"],
Cell[607392, 17387, 241, 6, 70, "Input"],
Cell[607636, 17395, 343, 11, 70, "Text"],
Cell[607982, 17408, 239, 6, 70, "Input"],
Cell[608224, 17416, 513, 15, 70, "Text"],
Cell[608740, 17433, 685, 18, 70, "Text"],
Cell[609428, 17453, 1520, 26, 70, "Input"],
Cell[610951, 17481, 410, 10, 70, "Text"],
Cell[611364, 17493, 313, 6, 70, "Input"],
Cell[611680, 17501, 1136, 19, 70, "Input"],
Cell[612819, 17522, 374, 6, 70, "Text"],
Cell[613196, 17530, 178, 5, 70, "Input"],
Cell[613377, 17537, 307, 7, 70, "Input"],
Cell[613687, 17546, 76, 0, 70, "Text"],
Cell[613766, 17548, 178, 5, 70, "Input"],
Cell[613947, 17555, 307, 7, 70, "Input"],
Cell[614257, 17564, 365, 10, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[614671, 17580, 282, 10, 70, "ExerciseHeading"],
Cell[614956, 17592, 1131, 36, 70, "Text"],

Cell[CellGroupData[{
Cell[616112, 17632, 724, 24, 70, "SolutionSubgroup"],
Cell[616839, 17658, 153, 4, 70, "Input"],
Cell[616995, 17664, 380, 9, 70, "Text"],
Cell[617378, 17675, 199, 5, 70, "Input"],
Cell[617580, 17682, 21, 0, 70, "Input"],
Cell[617604, 17684, 338, 6, 70, "Text"],
Cell[617945, 17692, 448, 9, 70, "Input"],
Cell[618396, 17703, 37, 0, 70, "Input"],
Cell[618436, 17705, 681, 20, 70, "Text"],
Cell[619120, 17727, 282, 7, 70, "Input"],
Cell[619405, 17736, 205, 5, 70, "Text"],
Cell[619613, 17743, 841, 15, 70, "Input"],
Cell[620457, 17760, 158, 4, 70, "Text"],
Cell[620618, 17766, 128, 3, 70, "Input"],
Cell[620749, 17771, 171, 4, 70, "Text"],
Cell[620923, 17777, 2243, 50, 70, "DisplayFormula"],
Cell[623169, 17829, 343, 11, 70, "Text"],
Cell[623515, 17842, 599, 11, 70, "Input"],
Cell[624117, 17855, 66, 0, 70, "Text"],
Cell[624186, 17857, 2644, 68, 70, "DisplayFormula"],
Cell[626833, 17927, 943, 25, 70, "Text"],
Cell[627779, 17954, 192, 5, 70, "Input"],
Cell[627974, 17961, 464, 9, 70, "Input"],
Cell[628441, 17972, 103, 3, 70, "Text"],
Cell[628547, 17977, 29, 0, 70, "Input"],
Cell[628579, 17979, 803, 27, 70, "Text"],
Cell[629385, 18008, 750, 13, 70, "Input"],
Cell[630138, 18023, 54, 0, 70, "Text"],
Cell[630195, 18025, 47, 0, 70, "Input"],
Cell[630245, 18027, 129, 3, 70, "Text"],
Cell[630377, 18032, 96, 3, 70, "Input"],
Cell[630476, 18037, 213, 5, 70, "Input"],
Cell[630692, 18044, 137, 3, 70, "Text"],
Cell[630832, 18049, 128, 4, 70, "Input"],
Cell[630963, 18055, 39, 0, 70, "Text"],
Cell[631005, 18057, 37, 0, 70, "Input"],
Cell[631045, 18059, 142, 3, 70, "Text"],
Cell[631190, 18064, 182, 4, 70, "Input"],
Cell[631375, 18070, 440, 16, 70, "Text"],
Cell[631818, 18088, 115, 3, 70, "Text"],
Cell[631936, 18093, 647, 11, 70, "Input"],
Cell[632586, 18106, 243, 5, 70, "Text"],
Cell[632832, 18113, 300, 7, 70, "Input"],
Cell[633135, 18122, 195, 4, 70, "Text"],
Cell[633333, 18128, 132, 4, 70, "Input"],
Cell[633468, 18134, 380, 8, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[633897, 18148, 174, 7, 70, "ExerciseHeading"],
Cell[634074, 18157, 724, 12, 70, "Text",
  CellTags->{
  "T[D[Vibrating Gosper Curve]]", "Index[12, {Gosper, curve}]", 
    "Index[12, {springs, along a Gosper curve}]"}],

Cell[CellGroupData[{
Cell[634823, 18173, 176, 4, 70, "SolutionSubgroup"],
Cell[635002, 18179, 631, 13, 70, "Input"],
Cell[635636, 18194, 187, 4, 70, "Input"],
Cell[635826, 18200, 75, 0, 70, "Text"],
Cell[635904, 18202, 314, 6, 70, "Input"],
Cell[636221, 18210, 156, 4, 70, "Input"],
Cell[636380, 18216, 169, 4, 70, "Text"],
Cell[636552, 18222, 82, 3, 70, "Input"],
Cell[636637, 18227, 151, 4, 70, "Input"],
Cell[636791, 18233, 716, 13, 70, "Input"],
Cell[637510, 18248, 185, 5, 70, "Text"],
Cell[637698, 18255, 142, 4, 70, "Input"],
Cell[637843, 18261, 4630, 139, 70, "Text",
  CellTags->"Index[12, {Cosper, spring chain}]"],
Cell[642476, 18402, 516, 8, 70, "Input"],
Cell[642995, 18412, 471, 15, 70, "Text"],
Cell[643469, 18429, 274, 5, 70, "Input"],
Cell[643746, 18436, 74, 0, 70, "Text"],
Cell[643823, 18438, 56, 0, 70, "Input"],
Cell[643882, 18440, 644, 21, 70, "Text"],
Cell[644529, 18463, 723, 12, 70, "Input"],
Cell[645255, 18477, 528, 9, 70, "Input"],
Cell[645786, 18488, 473, 15, 70, "Text"],
Cell[646262, 18505, 198, 7, 70, "Input"],
Cell[646463, 18514, 72, 0, 70, "Input"],
Cell[646538, 18516, 443, 8, 70, "Text"],
Cell[646984, 18526, 208, 5, 70, "Input"],
Cell[647195, 18533, 620, 16, 70, "Text"],
Cell[647818, 18551, 518, 9, 70, "Input"],
Cell[648339, 18562, 217, 4, 70, "Text"],
Cell[648559, 18568, 503, 9, 70, "Input"],
Cell[649065, 18579, 1003, 30, 70, "Text"],
Cell[650071, 18611, 137, 4, 70, "Input"],
Cell[650211, 18617, 345, 6, 70, "Text"],
Cell[650559, 18625, 924, 17, 70, "Input"],
Cell[651486, 18644, 91, 3, 70, "Text"],
Cell[651580, 18649, 985, 18, 70, "Input"],
Cell[652568, 18669, 102, 3, 70, "Input"],
Cell[652673, 18674, 400, 13, 70, "ProgramLabel"],
Cell[653076, 18689, 102, 3, 70, "Program"],
Cell[653181, 18694, 25, 0, 70, "ProgramBottom"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[653255, 18700, 184, 6, 70, "ExerciseHeading"],
Cell[653442, 18708, 577, 15, 70, "Text"],

Cell[CellGroupData[{
Cell[654044, 18727, 471, 15, 70, "SolutionSubgroup"],
Cell[654518, 18744, 395, 8, 70, "Input"],
Cell[654916, 18754, 206, 6, 70, "Text"],
Cell[655125, 18762, 192, 5, 70, "Input"],
Cell[655320, 18769, 73, 0, 70, "Text"],
Cell[655396, 18771, 1520, 33, 70, "DisplayFormula"],
Cell[656919, 18806, 146, 4, 70, "Text"],
Cell[657068, 18812, 96, 3, 70, "Input"],
Cell[657167, 18817, 109, 3, 70, "Input"],
Cell[657279, 18822, 1446, 39, 70, "Text"],
Cell[658728, 18863, 103, 3, 70, "Input"],
Cell[658834, 18868, 88, 3, 70, "Text"],
Cell[658925, 18873, 180, 5, 70, "Input"],
Cell[659108, 18880, 32, 0, 70, "Input"],
Cell[659143, 18882, 495, 15, 70, "Text"],
Cell[659641, 18899, 123, 3, 70, "Input"],
Cell[659767, 18904, 91, 3, 70, "Input"],
Cell[659861, 18909, 169, 5, 70, "Text"],
Cell[660033, 18916, 298, 6, 70, "Input"],
Cell[660334, 18924, 72, 0, 70, "Text"],
Cell[660409, 18926, 40, 0, 70, "Input"],
Cell[660452, 18928, 87, 3, 70, "Text"],
Cell[660542, 18933, 123, 3, 70, "Input"],
Cell[660668, 18938, 113, 3, 70, "Input"],
Cell[660784, 18943, 133, 5, 70, "Text"],
Cell[660920, 18950, 49, 0, 70, "Input"],
Cell[660972, 18952, 45, 0, 70, "Input"],
Cell[661020, 18954, 716, 14, 70, "Text"],
Cell[661739, 18970, 1001, 17, 70, "Input"],
Cell[662743, 18989, 522, 17, 70, "Text"],
Cell[663268, 19008, 201, 5, 70, "Input"],
Cell[663472, 19015, 429, 15, 70, "Text"],
Cell[663904, 19032, 203, 5, 70, "Input"],
Cell[664110, 19039, 363, 8, 70, "Text"],
Cell[664476, 19049, 321, 6, 70, "Input"],
Cell[664800, 19057, 321, 6, 70, "Input"],
Cell[665124, 19065, 145, 5, 70, "Text"],
Cell[665272, 19072, 142, 3, 70, "Input"],
Cell[665417, 19077, 408, 10, 70, "Text"],
Cell[665828, 19089, 116, 3, 70, "Input"],
Cell[665947, 19094, 103, 3, 70, "Input"],
Cell[666053, 19099, 236, 5, 70, "Text"],
Cell[666292, 19106, 84, 3, 70, "Input"],
Cell[666379, 19111, 105, 3, 70, "Input"],
Cell[666487, 19116, 128, 3, 70, "Text"],
Cell[666618, 19121, 171, 4, 70, "Input"],
Cell[666792, 19127, 104, 3, 70, "Text"],
Cell[666899, 19132, 153, 3, 70, "Input"],
Cell[667055, 19137, 43, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[667147, 19143, 208, 6, 70, "ExerciseHeading"],
Cell[667358, 19151, 2754, 75, 70, "Text"],

Cell[CellGroupData[{
Cell[670137, 19230, 59, 0, 70, "SolutionSubgroup"],
Cell[670199, 19232, 1548, 38, 70, "DisplayFormula"],
Cell[671750, 19272, 107, 3, 70, "Text"],
Cell[671860, 19277, 264, 5, 70, "Text"],
Cell[672127, 19284, 146, 4, 70, "Input"],
Cell[672276, 19290, 72, 0, 70, "Text"],
Cell[672351, 19292, 351, 7, 70, "Input"],
Cell[672705, 19301, 67, 0, 70, "Text"],
Cell[672775, 19303, 283, 6, 70, "Input"],
Cell[673061, 19311, 404, 11, 70, "Text"],
Cell[673468, 19324, 48, 0, 70, "Input"],
Cell[673519, 19326, 40, 0, 70, "Text"],
Cell[673562, 19328, 244, 6, 70, "Input"],
Cell[673809, 19336, 89, 3, 70, "Text"],
Cell[673901, 19341, 712, 13, 70, "Input"],
Cell[674616, 19356, 367, 9, 70, "Input"],
Cell[674986, 19367, 71, 0, 70, "Text"],
Cell[675060, 19369, 652, 11, 70, "Input"],
Cell[675715, 19382, 635, 19, 70, "Text"],
Cell[676353, 19403, 392, 10, 70, "Input"],
Cell[676748, 19415, 705, 14, 70, "Text"],
Cell[677456, 19431, 1669, 27, 70, "Input"],
Cell[679128, 19460, 213, 4, 70, "Text"],
Cell[679344, 19466, 520, 8, 70, "Input"],
Cell[679867, 19476, 163, 4, 70, "Input"],
Cell[680033, 19482, 41, 0, 70, "Input"],
Cell[680077, 19484, 682, 16, 70, "Text"],
Cell[680762, 19502, 226, 4, 70, "Input"],
Cell[680991, 19508, 706, 12, 70, "Input"],
Cell[681700, 19522, 141, 4, 70, "Text"],
Cell[681844, 19528, 245, 5, 70, "Input"],
Cell[682092, 19535, 105, 3, 70, "Text"],
Cell[682200, 19540, 51, 0, 70, "Input"],
Cell[682254, 19542, 217, 5, 70, "Text"],
Cell[682474, 19549, 238, 5, 70, "Input"],
Cell[682715, 19556, 282, 5, 70, "Input"],
Cell[683000, 19563, 651, 11, 70, "Input"],
Cell[683654, 19576, 265, 5, 70, "Text"],
Cell[683922, 19583, 281, 6, 70, "Input"],
Cell[684206, 19591, 1464, 25, 70, "Input"],
Cell[685673, 19618, 736, 17, 70, "Text"],
Cell[686412, 19637, 1443, 25, 70, "Input"],
Cell[687858, 19664, 107, 3, 70, "Text"],
Cell[687968, 19669, 137, 3, 70, "Input"],
Cell[688108, 19674, 136, 3, 70, "Text"],
Cell[688247, 19679, 214, 4, 70, "Input"],
Cell[688464, 19685, 113, 3, 70, "Text"],
Cell[688580, 19690, 149, 3, 70, "Input"],
Cell[688732, 19695, 117, 3, 70, "Text"],
Cell[688852, 19700, 236, 5, 70, "Input"],
Cell[689091, 19707, 303, 9, 70, "Text"],
Cell[689397, 19718, 115, 3, 70, "Text"],
Cell[689515, 19723, 335, 7, 70, "Input"],
Cell[689853, 19732, 713, 18, 70, "Text"],
Cell[690569, 19752, 212, 6, 70, "Input"],
Cell[690784, 19760, 297, 8, 70, "Input"],
Cell[691084, 19770, 649, 17, 70, "Text"],
Cell[691736, 19789, 313, 10, 70, "Text"],
Cell[692052, 19801, 213, 6, 70, "Input"],
Cell[692268, 19809, 47, 0, 70, "Text"],
Cell[692318, 19811, 41, 0, 70, "Input"],
Cell[692362, 19813, 470, 11, 70, "Text"],
Cell[692835, 19826, 307, 7, 70, "Input"],
Cell[693145, 19835, 116, 3, 70, "Input"],
Cell[693264, 19840, 1027, 25, 70, "Text"],
Cell[694294, 19867, 47, 0, 70, "Text"],
Cell[694344, 19869, 527, 9, 70, "Input"],
Cell[694874, 19880, 233, 7, 70, "Text"],
Cell[695110, 19889, 1882, 30, 70, "Input"],
Cell[696995, 19921, 35, 0, 70, "Input"],
Cell[697033, 19923, 149, 5, 70, "Text"],
Cell[697185, 19930, 383, 12, 70, "ProgramLabel"],
Cell[697571, 19944, 39, 0, 70, "Program"],
Cell[697613, 19946, 25, 0, 70, "ProgramBottom"],
Cell[697641, 19948, 530, 12, 70, "Text"],
Cell[698174, 19962, 556, 15, 70, "Input"],
Cell[698733, 19979, 744, 23, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[699526, 20008, 184, 6, 70, "ExerciseHeading"],
Cell[699713, 20016, 2767, 77, 70, "Text"],
Cell[702483, 20095, 769, 20, 70, "DisplayFormula"],
Cell[703255, 20117, 1203, 35, 70, "Text"],
Cell[704461, 20154, 459, 13, 70, "Text"],
Cell[704923, 20169, 594, 18, 70, "Text"],

Cell[CellGroupData[{
Cell[705542, 20191, 260, 7, 70, "SolutionSubgroup"],
Cell[705805, 20200, 522, 10, 70, "Input"],
Cell[706330, 20212, 62, 0, 70, "Text"],
Cell[706395, 20214, 72, 0, 70, "Input"],
Cell[706470, 20216, 203, 4, 70, "Text"],
Cell[706676, 20222, 265, 6, 70, "Input"],
Cell[706944, 20230, 50, 0, 70, "Text"],
Cell[706997, 20232, 131, 3, 70, "Input"],
Cell[707131, 20237, 242, 6, 70, "Text"],
Cell[707376, 20245, 91, 1, 70, "Input"],
Cell[707470, 20248, 94, 3, 70, "Text"],
Cell[707567, 20253, 254, 6, 70, "Input"],
Cell[707824, 20261, 110, 3, 70, "Input"],
Cell[707937, 20266, 907, 24, 70, "Text"],
Cell[708847, 20292, 911, 16, 70, "Input"],
Cell[709761, 20310, 483, 17, 70, "Text"],
Cell[710247, 20329, 597, 10, 70, "Input"],
Cell[710847, 20341, 3231, 83, 70, "Text"],
Cell[714081, 20426, 1068, 27, 70, "Text"],
Cell[715152, 20455, 198, 4, 70, "Input"],
Cell[715353, 20461, 2186, 36, 70, "Input"],
Cell[717542, 20499, 168, 6, 70, "Text"],
Cell[717713, 20507, 63, 0, 70, "Input"],
Cell[717779, 20509, 1069, 27, 70, "Text"],
Cell[718851, 20538, 527, 10, 70, "Input"],
Cell[719381, 20550, 91, 3, 70, "Text"],
Cell[719475, 20555, 63, 0, 70, "Input"],
Cell[719541, 20557, 259, 9, 70, "Text"],
Cell[719803, 20568, 63, 0, 70, "Input"],
Cell[719869, 20570, 63, 0, 70, "Input"],
Cell[719935, 20572, 63, 0, 70, "Input"],
Cell[720001, 20574, 63, 0, 70, "Input"],
Cell[720067, 20576, 321, 9, 70, "Text"],
Cell[720391, 20587, 63, 0, 70, "Input"],
Cell[720457, 20589, 63, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[720569, 20595, 189, 6, 70, "ExerciseHeading"],
Cell[720761, 20603, 51, 0, 70, "Text"],
Cell[720815, 20605, 2818, 65, 70, "DisplayFormula"],
Cell[723636, 20672, 306, 11, 70, "Text"],

Cell[CellGroupData[{
Cell[723967, 20687, 201, 6, 70, "ExerciseSubgroup"],
Cell[724171, 20695, 253, 6, 70, "Input"],
Cell[724427, 20703, 158, 6, 70, "Text"],
Cell[724588, 20711, 29, 0, 70, "Input"],
Cell[724620, 20713, 177, 5, 70, "Input"],
Cell[724800, 20720, 138, 4, 70, "Text"],
Cell[724941, 20726, 41, 0, 70, "Input"],
Cell[724985, 20728, 995, 27, 70, "Text"],
Cell[725983, 20757, 753, 13, 70, "Input"],
Cell[726739, 20772, 158, 4, 70, "Input"],
Cell[726900, 20778, 173, 6, 70, "Text"],
Cell[727076, 20786, 34, 0, 70, "Input"],
Cell[727113, 20788, 93, 3, 70, "Text"],
Cell[727209, 20793, 170, 4, 70, "Input"],
Cell[727382, 20799, 304, 6, 70, "Text"],
Cell[727689, 20807, 383, 7, 70, "Input"],
Cell[728075, 20816, 393, 7, 70, "Input"],
Cell[728471, 20825, 250, 7, 70, "Text"],
Cell[728724, 20834, 178, 5, 70, "Input"],
Cell[728905, 20841, 196, 6, 70, "Text"],
Cell[729104, 20849, 70, 0, 70, "Input"],
Cell[729177, 20851, 1682, 48, 70, "Text"],
Cell[730862, 20901, 589, 10, 70, "Input"],
Cell[731454, 20913, 202, 6, 70, "Text"],
Cell[731659, 20921, 158, 3, 70, "Input"],
Cell[731820, 20926, 840, 25, 70, "Text"],
Cell[732663, 20953, 409, 7, 70, "Input"],
Cell[733075, 20962, 216, 7, 70, "Text"],
Cell[733294, 20971, 158, 6, 70, "ProgramLabel"],
Cell[733455, 20979, 194, 5, 70, "Program"],
Cell[733652, 20986, 25, 0, 70, "ProgramBottom"],
Cell[733680, 20988, 742, 24, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[734471, 21018, 176, 6, 70, "ExerciseHeading"],
Cell[734650, 21026, 2665, 79, 70, "Text"],
Cell[737318, 21107, 1295, 37, 70, "DisplayFormula"],
Cell[738616, 21146, 2869, 87, 70, "Text"],

Cell[CellGroupData[{
Cell[741510, 21237, 3145, 99, 70, "ExerciseSubgroup"],
Cell[744658, 21338, 310, 9, 70, "Text"],
Cell[744971, 21349, 367, 6, 70, "Input"],
Cell[745341, 21357, 245, 8, 70, "Text"],
Cell[745589, 21367, 73, 0, 70, "Input"],
Cell[745665, 21369, 108, 3, 70, "Text"],
Cell[745776, 21374, 459, 8, 70, "Input"],
Cell[746238, 21384, 212, 7, 70, "Text"],
Cell[746453, 21393, 62, 0, 70, "Input"],
Cell[746518, 21395, 294, 10, 70, "Text"],
Cell[746815, 21407, 62, 0, 70, "Input"],
Cell[746880, 21409, 893, 28, 70, "Text"],
Cell[747776, 21439, 874, 16, 70, "Input"],
Cell[748653, 21457, 357, 13, 70, "Text"],
Cell[749013, 21472, 40, 0, 70, "Input"],
Cell[749056, 21474, 89, 3, 70, "Text"],
Cell[749148, 21479, 630, 11, 70, "Input"],
Cell[749781, 21492, 235, 5, 70, "Text"],
Cell[750019, 21499, 858, 14, 70, "Input"],
Cell[750880, 21515, 202, 7, 70, "Text"],
Cell[751085, 21524, 62, 0, 70, "Input"],
Cell[751150, 21526, 310, 8, 70, "Text"],
Cell[751463, 21536, 62, 0, 70, "Input"],
Cell[751528, 21538, 447, 12, 70, "Text"],
Cell[751978, 21552, 62, 0, 70, "Input"],
Cell[752043, 21554, 454, 12, 70, "Text"],
Cell[752500, 21568, 63, 0, 70, "Input"],
Cell[752566, 21570, 208, 6, 70, "Text"],
Cell[752777, 21578, 347, 9, 70, "Text"],
Cell[753127, 21589, 353, 6, 70, "Input"],
Cell[753483, 21597, 457, 13, 70, "Text"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[754001, 21617, 46, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[754072, 21621, 197, 6, 70, "ExerciseHeading"],
Cell[754272, 21629, 356, 8, 70, "Text"],
Cell[754631, 21639, 1290, 34, 70, "DisplayFormula"],
Cell[755924, 21675, 445, 13, 70, "Text"],
Cell[756372, 21690, 828, 29, 70, "Text"],
Cell[757203, 21721, 859, 23, 70, "DisplayFormula"],
Cell[758065, 21746, 862, 26, 70, "Text"],
Cell[758930, 21774, 2833, 72, 70, "DisplayFormula"],
Cell[761766, 21848, 1254, 41, 70, "Text"],
Cell[763023, 21891, 3320, 91, 70, "DisplayFormula"],
Cell[766346, 21984, 1261, 31, 70, "DisplayFormula"],
Cell[767610, 22017, 1419, 48, 70, "Text"],

Cell[CellGroupData[{
Cell[769054, 22069, 1172, 38, 70, "SolutionSubgroup"],
Cell[770229, 22109, 268, 5, 70, "Input"],
Cell[770500, 22116, 971, 16, 70, "Input"],
Cell[771474, 22134, 1446, 47, 70, "Text"],
Cell[772923, 22183, 472, 8, 70, "Input"],
Cell[773398, 22193, 1371, 46, 70, "Text"],
Cell[774772, 22241, 913, 17, 70, "Input"],
Cell[775688, 22260, 88, 3, 70, "Text"],
Cell[775779, 22265, 530, 9, 70, "Input"],
Cell[776312, 22276, 105, 3, 70, "Input"],
Cell[776420, 22281, 309, 12, 70, "Text"],
Cell[776732, 22295, 765, 14, 70, "Input"],
Cell[777500, 22311, 218, 6, 70, "Input"],
Cell[777721, 22319, 1598, 56, 70, "Text"],
Cell[779322, 22377, 1056, 17, 70, "Input"],
Cell[780381, 22396, 1422, 52, 70, "Text"],
Cell[781806, 22450, 170, 4, 70, "Input"],
Cell[781979, 22456, 339, 8, 70, "Text"],
Cell[782321, 22466, 131, 4, 70, "Input"],
Cell[782455, 22472, 598, 21, 70, "Text"],
Cell[783056, 22495, 1159, 26, 70, "Text"],
Cell[784218, 22523, 4326, 107, 70, "DisplayFormula"],
Cell[788547, 22632, 398, 15, 70, "Text"],
Cell[788948, 22649, 2450, 60, 70, "DisplayFormula"],
Cell[791401, 22711, 186, 6, 70, "Text"],
Cell[791590, 22719, 1791, 41, 70, "DisplayFormula"],
Cell[793384, 22762, 1629, 43, 70, "Text"],
Cell[795016, 22807, 1473, 35, 70, "Text"],
Cell[796492, 22844, 61, 0, 70, "Text"],
Cell[796556, 22846, 1389, 36, 70, "DisplayFormula"],
Cell[797948, 22884, 1032, 27, 70, "DisplayFormula"],
Cell[798983, 22913, 62, 0, 70, "Text"],
Cell[799048, 22915, 1270, 35, 70, "DisplayFormula"],
Cell[800321, 22952, 578, 18, 70, "Text"],
Cell[800902, 22972, 1748, 50, 70, "DisplayFormula"],
Cell[802653, 23024, 61, 0, 70, "Input"],
Cell[802717, 23026, 753, 21, 70, "Text"],
Cell[803473, 23049, 941, 16, 70, "Input"],
Cell[804417, 23067, 534, 14, 70, "Text"],
Cell[804954, 23083, 107, 3, 70, "Text"],
Cell[805064, 23088, 212, 4, 70, "Input"],
Cell[805279, 23094, 428, 7, 70, "Input"],
Cell[805710, 23103, 502, 8, 70, "Input"],
Cell[806215, 23113, 301, 9, 70, "Text"],
Cell[806519, 23124, 455, 8, 70, "Input"],
Cell[806977, 23134, 439, 17, 70, "Text"],
Cell[807419, 23153, 367, 8, 70, "Input"],
Cell[807789, 23163, 178, 6, 70, "Input"],
Cell[807970, 23171, 2472, 62, 70, "Text"],
Cell[810445, 23235, 838, 15, 70, "Input"],
Cell[811286, 23252, 323, 6, 70, "Input"],
Cell[811612, 23260, 449, 16, 70, "Text"],
Cell[812064, 23278, 78, 3, 70, "Input"],
Cell[812145, 23283, 77, 3, 70, "Input"],
Cell[812225, 23288, 220, 6, 70, "Text"],
Cell[812448, 23296, 368, 7, 70, "Input"],
Cell[812819, 23305, 757, 21, 70, "Text"],
Cell[813579, 23328, 239, 5, 70, "Input"],
Cell[813821, 23335, 95, 3, 70, "Input"],
Cell[813919, 23340, 1465, 38, 70, "Text"],
Cell[815387, 23380, 2642, 43, 70, "Input"],
Cell[818032, 23425, 758, 19, 70, "Text"],
Cell[818793, 23446, 476, 8, 70, "Input"],
Cell[819272, 23456, 650, 22, 70, "Text"],
Cell[819925, 23480, 168, 4, 70, "Input"],
Cell[820096, 23486, 391, 12, 70, "Text"],
Cell[820490, 23500, 135, 4, 70, "Input"],
Cell[820628, 23506, 1034, 32, 70, "Text"],
Cell[821665, 23540, 196, 4, 70, "Input"],
Cell[821864, 23546, 392, 12, 70, "Text"],
Cell[822259, 23560, 307, 7, 70, "Input"],
Cell[822569, 23569, 252, 7, 70, "Text"],
Cell[822824, 23578, 139, 3, 70, "Input"],
Cell[822966, 23583, 1859, 57, 70, "Text"],
Cell[824828, 23642, 2287, 59, 70, "DisplayFormula"],
Cell[827118, 23703, 2231, 73, 70, "Text"],
Cell[829352, 23778, 2194, 59, 70, "DisplayFormula"],
Cell[831549, 23839, 1343, 39, 70, "Text"],
Cell[832895, 23880, 195, 6, 70, "Text"],
Cell[833093, 23888, 393, 7, 70, "Input"],
Cell[833489, 23897, 306, 6, 70, "Input"],
Cell[833798, 23905, 608, 19, 70, "Text"],
Cell[834409, 23926, 173, 4, 70, "Input"],
Cell[834585, 23932, 772, 22, 70, "Text"],
Cell[835360, 23956, 551, 10, 70, "Input"],
Cell[835914, 23968, 495, 16, 70, "Text"],
Cell[836412, 23986, 220, 5, 70, "Input"],
Cell[836635, 23993, 478, 13, 70, "Text"],
Cell[837116, 24008, 237, 6, 70, "Input"],
Cell[837356, 24016, 545, 14, 70, "Text"],
Cell[837904, 24032, 129, 4, 70, "Input"],
Cell[838036, 24038, 76, 0, 70, "Text"],
Cell[838115, 24040, 106, 3, 70, "Input"],
Cell[838224, 24045, 494, 18, 70, "Text"],
Cell[838721, 24065, 240, 6, 70, "Input"],
Cell[838964, 24073, 60, 0, 70, "Text"],
Cell[839027, 24075, 109, 3, 70, "Input"],
Cell[839139, 24080, 462, 16, 70, "Text"],
Cell[839604, 24098, 159, 4, 70, "Input"],
Cell[839766, 24104, 503, 18, 70, "Text"],
Cell[840272, 24124, 256, 7, 70, "Input"],
Cell[840531, 24133, 60, 0, 70, "Text"],
Cell[840594, 24135, 111, 3, 70, "Input"],
Cell[840708, 24140, 161, 4, 70, "Input"],
Cell[840872, 24146, 1436, 41, 70, "Text"],
Cell[842311, 24189, 1488, 25, 70, "Input"],
Cell[843802, 24216, 276, 7, 70, "Text"],
Cell[844081, 24225, 448, 8, 70, "Input"],
Cell[844532, 24235, 295, 5, 70, "Input"],
Cell[844830, 24242, 132, 4, 70, "Text"],
Cell[844965, 24248, 169, 4, 70, "Input"],
Cell[845137, 24254, 897, 26, 70, "Text"],
Cell[846037, 24282, 272, 5, 70, "Input"],
Cell[846312, 24289, 270, 6, 70, "Input"],
Cell[846585, 24297, 267, 6, 70, "Input"],
Cell[846855, 24305, 713, 19, 70, "Text"],
Cell[847571, 24326, 330, 6, 70, "Input"],
Cell[847904, 24334, 1458, 25, 70, "Input"],
Cell[849365, 24361, 109, 3, 70, "Input"],
Cell[849477, 24366, 713, 23, 70, "Text"],
Cell[850193, 24391, 584, 11, 70, "Input"],
Cell[850780, 24404, 410, 7, 70, "Text"],
Cell[851193, 24413, 700, 12, 70, "Input"],
Cell[851896, 24427, 241, 5, 70, "Input"],
Cell[852140, 24434, 255, 5, 70, "Text"],
Cell[852398, 24441, 588, 10, 70, "Input"],
Cell[852989, 24453, 240, 7, 70, "Text"],
Cell[853232, 24462, 164, 5, 70, "Input"],
Cell[853399, 24469, 258, 8, 70, "Text"],
Cell[853660, 24479, 161, 4, 70, "Input"],
Cell[853824, 24485, 67, 0, 70, "Text"],
Cell[853894, 24487, 65, 0, 70, "Input"],
Cell[853962, 24489, 166, 4, 70, "Text"],
Cell[854131, 24495, 49, 0, 70, "Input"],
Cell[854183, 24497, 1468, 39, 70, "Text"],
Cell[855654, 24538, 176, 4, 70, "Input"],
Cell[855833, 24544, 630, 18, 70, "Text"],
Cell[856466, 24564, 593, 11, 70, "Input"],
Cell[857062, 24577, 612, 12, 70, "Text"],
Cell[857677, 24591, 719, 13, 70, "Input"],
Cell[858399, 24606, 1279, 40, 70, "Text"],
Cell[859681, 24648, 918, 18, 70, "Input"],
Cell[860602, 24668, 1451, 39, 70, "Text"],
Cell[862056, 24709, 734, 19, 70, "DisplayFormula"],
Cell[862793, 24730, 408, 11, 70, "Text"],
Cell[863204, 24743, 1330, 23, 70, "Input"],
Cell[864537, 24768, 1304, 38, 70, "Text"],
Cell[865844, 24808, 2584, 40, 70, "Input"],
Cell[868431, 24850, 616, 15, 70, "Text"],
Cell[869050, 24867, 321, 8, 70, "Text"],
Cell[869374, 24877, 695, 13, 70, "Input"],
Cell[870072, 24892, 562, 11, 70, "Text"],
Cell[870637, 24905, 1089, 17, 70, "Input"],
Cell[871729, 24924, 642, 10, 70, "Text"],
Cell[872374, 24936, 2505, 39, 70, "Input"],
Cell[874882, 24977, 926, 25, 70, "Text"],
Cell[875811, 25004, 783, 14, 70, "Input"],
Cell[876597, 25020, 884, 21, 70, "Text"],
Cell[877484, 25043, 1523, 27, 70, "Input"],
Cell[879010, 25072, 624, 18, 70, "Text"],
Cell[879637, 25092, 656, 12, 70, "Input"],
Cell[880296, 25106, 239, 5, 70, "Text"],
Cell[880538, 25113, 200, 5, 70, "Input"],
Cell[880741, 25120, 587, 11, 70, "Text"],
Cell[881331, 25133, 168, 4, 70, "Input"],
Cell[881502, 25139, 231, 6, 70, "Input"],
Cell[881736, 25147, 45, 0, 70, "Text"],
Cell[881784, 25149, 150, 4, 70, "Input"],
Cell[881937, 25155, 68, 0, 70, "Text"],
Cell[882008, 25157, 183, 5, 70, "Input"],
Cell[882194, 25164, 420, 11, 70, "Text"],
Cell[882617, 25177, 75, 0, 70, "Input"],
Cell[882695, 25179, 1258, 32, 70, "Text"],
Cell[883956, 25213, 469, 8, 70, "Input"],
Cell[884428, 25223, 2343, 41, 70, "Input"],
Cell[886774, 25266, 593, 9, 70, "Text"],
Cell[887370, 25277, 999, 25, 70, "Text"],
Cell[888372, 25304, 162, 4, 70, "Input"],
Cell[888537, 25310, 188, 4, 70, "Text"],
Cell[888728, 25316, 164, 4, 70, "Input"],
Cell[888895, 25322, 134, 3, 70, "Text"],
Cell[889032, 25327, 172, 5, 70, "Input"],
Cell[889207, 25334, 92, 3, 70, "Text"],
Cell[889302, 25339, 176, 5, 70, "Input"],
Cell[889481, 25346, 132, 3, 70, "Text"],
Cell[889616, 25351, 170, 5, 70, "Input"],
Cell[889789, 25358, 122, 3, 70, "Text"],
Cell[889914, 25363, 174, 5, 70, "Input"],
Cell[890091, 25370, 169, 4, 70, "Text"],
Cell[890263, 25376, 168, 5, 70, "Input"],
Cell[890434, 25383, 72, 0, 70, "Text"],
Cell[890509, 25385, 156, 3, 70, "Input"],
Cell[890668, 25390, 168, 5, 70, "Input"],
Cell[890839, 25397, 168, 5, 70, "Input"],
Cell[891010, 25404, 106, 3, 70, "Text"],
Cell[891119, 25409, 172, 5, 70, "Input"],
Cell[891294, 25416, 102, 3, 70, "Text"],
Cell[891399, 25421, 170, 5, 70, "Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[891630, 25433, 46, 0, 42, "Section"],

Cell[CellGroupData[{
Cell[891701, 25437, 572, 18, 70, "ExerciseHeading"],
Cell[892276, 25457, 978, 34, 70, "Text"],

Cell[CellGroupData[{
Cell[893279, 25495, 1115, 37, 70, "SolutionSubgroup"],
Cell[894397, 25534, 448, 8, 70, "Input"],
Cell[894848, 25544, 256, 7, 70, "Input"],
Cell[895107, 25553, 231, 7, 70, "Text"],
Cell[895341, 25562, 282, 6, 70, "Input"],
Cell[895626, 25570, 1958, 54, 70, "Text"],
Cell[897587, 25626, 100, 3, 70, "Input"],
Cell[897690, 25631, 242, 7, 70, "Input"],
Cell[897935, 25640, 40, 0, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[898024, 25646, 199, 6, 70, "ExerciseHeading"],
Cell[898226, 25654, 1409, 48, 70, "Text"],
Cell[899638, 25704, 2438, 64, 70, "DisplayFormula"],
Cell[902079, 25770, 1324, 44, 70, "Text"],
Cell[903406, 25816, 245, 6, 70, "Text"],
Cell[903654, 25824, 877, 26, 70, "DisplayFormula"],
Cell[904534, 25852, 282, 9, 70, "Text"],

Cell[CellGroupData[{
Cell[904841, 25865, 412, 13, 70, "SolutionSubgroup"],
Cell[905256, 25880, 625, 11, 70, "Input"],
Cell[905884, 25893, 188, 6, 70, "Text"],
Cell[906075, 25901, 202, 5, 70, "Input"],
Cell[906280, 25908, 192, 6, 70, "Text"],
Cell[906475, 25916, 278, 7, 70, "Input"],
Cell[906756, 25925, 324, 8, 70, "Text"],
Cell[907083, 25935, 354, 8, 70, "Input"],
Cell[907440, 25945, 281, 5, 70, "Text"],
Cell[907724, 25952, 243, 5, 70, "Input"],
Cell[907970, 25959, 134, 3, 70, "Input"],
Cell[908107, 25964, 271, 8, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[908427, 25978, 271, 9, 70, "ExerciseHeading"],
Cell[908701, 25989, 999, 31, 70, "Text"],
Cell[909703, 26022, 845, 22, 70, "DisplayFormula"],
Cell[910551, 26046, 369, 12, 70, "Text"],
Cell[910923, 26060, 2366, 73, 70, "Text"],
Cell[913292, 26135, 1251, 31, 70, "DisplayFormula"],
Cell[914546, 26168, 414, 14, 70, "Text"],

Cell[CellGroupData[{
Cell[914985, 26186, 1318, 40, 70, "SolutionSubgroup"],
Cell[916306, 26228, 179, 4, 70, "Input"],
Cell[916488, 26234, 831, 14, 70, "Input"],
Cell[917322, 26250, 312, 12, 70, "Text"],
Cell[917637, 26264, 157, 4, 70, "Input"],
Cell[917797, 26270, 371, 14, 70, "Text"],
Cell[918171, 26286, 147, 4, 70, "Input"],
Cell[918321, 26292, 417, 13, 70, "Text"],
Cell[918741, 26307, 131, 3, 70, "Input"],
Cell[918875, 26312, 221, 4, 70, "Text"],
Cell[919099, 26318, 383, 10, 70, "Input"],
Cell[919485, 26330, 273, 8, 70, "Text"],
Cell[919761, 26340, 106, 3, 70, "Input"],
Cell[919870, 26345, 221, 7, 70, "Text"],
Cell[920094, 26354, 119, 4, 70, "Input"],
Cell[920216, 26360, 100, 3, 70, "Text"],
Cell[920319, 26365, 477, 8, 70, "Input"],
Cell[920799, 26375, 296, 10, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[921144, 26391, 363, 13, 70, "ExerciseHeading"],
Cell[921510, 26406, 314, 11, 70, "Text"],

Cell[CellGroupData[{
Cell[921849, 26421, 313, 10, 70, "SolutionSubgroup"],
Cell[922165, 26433, 93, 3, 70, "Input"],
Cell[922261, 26438, 1629, 46, 70, "Text"],
Cell[923893, 26486, 142, 3, 70, "Text"],
Cell[924038, 26491, 837, 13, 70, "Input"],
Cell[924878, 26506, 364, 12, 70, "Text"],
Cell[925245, 26520, 106, 3, 70, "Input"],
Cell[925354, 26525, 335, 10, 70, "Text"],
Cell[925692, 26537, 138, 4, 70, "Input"],
Cell[925833, 26543, 848, 28, 70, "Text"],
Cell[926684, 26573, 32, 0, 70, "Input"],
Cell[926719, 26575, 139, 4, 70, "Input"],
Cell[926861, 26581, 294, 8, 70, "Text"],
Cell[927158, 26591, 141, 3, 70, "Input"],
Cell[927302, 26596, 133, 3, 70, "Text"],
Cell[927438, 26601, 95, 3, 70, "Input"],
Cell[927536, 26606, 96, 3, 70, "Input"],
Cell[927635, 26611, 61, 0, 70, "Text"],
Cell[927699, 26613, 89, 3, 70, "Input"],
Cell[927791, 26618, 870, 27, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[928710, 26651, 165, 6, 70, "ExerciseHeading"],
Cell[928878, 26659, 2451, 74, 70, "Text"],

Cell[CellGroupData[{
Cell[931354, 26737, 77, 0, 70, "SolutionSubgroup"],
Cell[931434, 26739, 76, 0, 70, "Input"],
Cell[931513, 26741, 510, 17, 70, "Text"],
Cell[932026, 26760, 126, 4, 70, "Input"],
Cell[932155, 26766, 929, 24, 70, "Text"],
Cell[933087, 26792, 70, 0, 70, "Input"],
Cell[933160, 26794, 1992, 57, 70, "Text"],
Cell[935155, 26853, 227, 5, 70, "Input"],
Cell[935385, 26860, 557, 17, 70, "Text"],
Cell[935945, 26879, 238, 5, 70, "Input"],
Cell[936186, 26886, 111, 3, 70, "Input"],
Cell[936300, 26891, 1001, 24, 70, "Text"],
Cell[937304, 26917, 324, 6, 70, "Input"],
Cell[937631, 26925, 182, 6, 70, "Text"],
Cell[937816, 26933, 64, 0, 70, "Input"],
Cell[937883, 26935, 249, 10, 70, "Text"],
Cell[938135, 26947, 53, 0, 70, "Input"],
Cell[938191, 26949, 234, 9, 70, "Text"],
Cell[938428, 26960, 68, 0, 70, "Input"],
Cell[938499, 26962, 223, 6, 70, "Text"],
Cell[938725, 26970, 94, 3, 70, "Input"],
Cell[938822, 26975, 131, 3, 70, "Input"],
Cell[938956, 26980, 528, 16, 70, "Text"],
Cell[939487, 26998, 73, 0, 70, "Input"],
Cell[939563, 27000, 268, 9, 70, "Text"],
Cell[939834, 27011, 72, 0, 70, "Input"],
Cell[939909, 27013, 643, 22, 70, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[940601, 27041, 182, 6, 70, "ExerciseHeading"],
Cell[940786, 27049, 535, 18, 70, "Text"],

Cell[CellGroupData[{
Cell[941346, 27071, 402, 15, 70, "SolutionSubgroup"],
Cell[941751, 27088, 121, 3, 70, "Input"],
Cell[941875, 27093, 87, 3, 70, "Text"],
Cell[941965, 27098, 121, 3, 70, "Input"],
Cell[942089, 27103, 904, 24, 70, "Text"],
Cell[942996, 27129, 896, 15, 70, "Input"],
Cell[943895, 27146, 67, 0, 70, "Text"],
Cell[943965, 27148, 69, 0, 70, "Input"],
Cell[944037, 27150, 322, 9, 70, "Text"],
Cell[944362, 27161, 342, 7, 70, "Input"],
Cell[944707, 27170, 485, 9, 70, "Input"],
Cell[945195, 27181, 499, 16, 70, "Text"],
Cell[945697, 27199, 115, 3, 70, "Input"],
Cell[945815, 27204, 123, 4, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[945987, 27214, 168, 6, 70, "ExerciseHeading"],
Cell[946158, 27222, 616, 18, 70, "Text",
  CellTags->{
  "T[D[Sliding Spinning Disk]]", 
    "Index[14, {disk, spinning and sliding ~}]"}],
Cell[946779, 27243, 3617, 78, 70, "DisplayFormula"],
Cell[950399, 27323, 4404, 94, 70, "DisplayFormula"],
Cell[954806, 27419, 1729, 47, 70, "Text"],

Cell[CellGroupData[{
Cell[956560, 27470, 393, 11, 70, "SolutionSubgroup"],
Cell[956956, 27483, 559, 10, 70, "Input"],
Cell[957518, 27495, 607, 10, 70, "Input"],
Cell[958128, 27507, 248, 6, 70, "Text"],
Cell[958379, 27515, 226, 6, 70, "Input"],
Cell[958608, 27523, 1155, 27, 70, "Text"],
Cell[959766, 27552, 1443, 23, 70, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[961258, 27581, 181, 6, 70, "ExerciseHeading"],
Cell[961442, 27589, 359, 11, 70, "Text"],
Cell[961804, 27602, 429, 12, 70, "DisplayFormula"],
Cell[962236, 27616, 636, 17, 70, "DisplayFormula"],
Cell[962875, 27635, 1012, 27, 70, "DisplayFormula"],
Cell[963890, 27664, 1172, 31, 70, "DisplayFormula"],
Cell[965065, 27697, 1053, 28, 70, "DisplayFormula"],
Cell[966121, 27727, 1847, 47, 70, "DisplayFormula"],
Cell[967971, 27776, 1241, 32, 70, "DisplayFormula"],
Cell[969215, 27810, 1488, 39, 70, "DisplayFormula"],
Cell[970706, 27851, 2431, 66, 70, "DisplayFormula"],
Cell[973140, 27919, 2532, 66, 70, "DisplayFormula"],
Cell[975675, 27987, 2415, 65, 70, "DisplayFormula"],
Cell[978093, 28054, 216, 6, 70, "Text"],

Cell[CellGroupData[{
Cell[978334, 28064, 1248, 39, 70, "SolutionSubgroup"],
Cell[979585, 28105, 103, 3, 70, "Input"],
Cell[979691, 28110, 457, 14, 70, "Text"],
Cell[980151, 28126, 608, 13, 70, "Input"],
Cell[980762, 28141, 116, 3, 70, "Text"],
Cell[980881, 28146, 1350, 33, 70, "DisplayFormula"],
Cell[982234, 28181, 3022, 95, 70, "Text"],
Cell[985259, 28278, 750, 17, 70, "Text"],
Cell[986012, 28297, 688, 17, 70, "Text"],
Cell[986703, 28316, 318, 7, 70, "Input"],
Cell[987024, 28325, 497, 15, 70, "Text"],
Cell[987524, 28342, 160, 4, 70, "Input"],
Cell[987687, 28348, 971, 34, 70, "Text"],
Cell[988661, 28384, 246, 5, 70, "Input"],
Cell[988910, 28391, 260, 8, 70, "Text"],
Cell[989173, 28401, 489, 10, 70, "Input"],
Cell[989665, 28413, 726, 22, 70, "Text"],
Cell[990394, 28437, 348, 6, 70, "Input"],
Cell[990745, 28445, 267, 9, 70, "Text"],
Cell[991015, 28456, 388, 10, 70, "Input"],
Cell[991406, 28468, 245, 5, 70, "Text"],
Cell[991654, 28475, 561, 9, 70, "Input"],
Cell[992218, 28486, 719, 13, 70, "Input"],
Cell[992940, 28501, 202, 5, 70, "Input"],
Cell[993145, 28508, 67, 0, 70, "Text"],
Cell[993215, 28510, 91, 3, 70, "Input"],
Cell[993309, 28515, 265, 5, 70, "Text"],
Cell[993577, 28522, 407, 7, 70, "Input"],
Cell[993987, 28531, 99, 3, 70, "Text"],
Cell[994089, 28536, 107, 4, 70, "Input"],
Cell[994199, 28542, 692, 22, 70, "Text"],
Cell[994894, 28566, 1699, 29, 70, "Input"],
Cell[996596, 28597, 163, 4, 70, "Text"],
Cell[996762, 28603, 159, 4, 70, "Input"],
Cell[996924, 28609, 231, 5, 70, "Input"],
Cell[997158, 28616, 62, 0, 70, "Text"],
Cell[997223, 28618, 222, 5, 70, "Input"],
Cell[997448, 28625, 167, 4, 70, "Text"],
Cell[997618, 28631, 465, 8, 70, "Input"],
Cell[998086, 28641, 167, 4, 70, "Input"],
Cell[998256, 28647, 400, 7, 70, "Text"],
Cell[998659, 28656, 178, 4, 70, "Input"],
Cell[998840, 28662, 553, 11, 70, "Text"],
Cell[999396, 28675, 2109, 40, 70, "Input"],
Cell[1001508, 28717, 335, 6, 70, "Text"],
Cell[1001846, 28725, 314, 12, 70, "Input"],
Cell[1002163, 28739, 321, 7, 70, "Text"],
Cell[1002487, 28748, 579, 11, 70, "Input"],
Cell[1003069, 28761, 116, 3, 70, "Text"],
Cell[1003188, 28766, 64, 3, 70, "Input"],
Cell[1003255, 28771, 724, 25, 70, "Text"],
Cell[1003982, 28798, 153, 4, 70, "Input"],
Cell[1004138, 28804, 226, 6, 70, "Text"],
Cell[1004367, 28812, 98, 3, 70, "Input"],
Cell[1004468, 28817, 54, 0, 70, "Text"],
Cell[1004525, 28819, 337, 8, 70, "Input"],
Cell[1004865, 28829, 196, 5, 70, "Text"],
Cell[1005064, 28836, 327, 7, 70, "Input"],
Cell[1005394, 28845, 60, 0, 70, "Text"],
Cell[1005457, 28847, 63, 3, 70, "Input"],
Cell[1005523, 28852, 219, 5, 70, "Text"],
Cell[1005745, 28859, 991, 20, 70, "Input"],
Cell[1006739, 28881, 334, 11, 70, "Text"],
Cell[1007076, 28894, 2204, 56, 70, "DisplayFormula"],
Cell[1009283, 28952, 2604, 65, 70, "DisplayFormula"],
Cell[1011890, 29019, 1896, 50, 70, "DisplayFormula"],
Cell[1013789, 29071, 2228, 58, 70, "DisplayFormula"],
Cell[1016020, 29131, 3473, 86, 70, "DisplayFormula"],
Cell[1019496, 29219, 4039, 92, 70, "DisplayFormula"],
Cell[1023538, 29313, 895, 27, 70, "Text"],
Cell[1024436, 29342, 2988, 50, 70, "Input"],
Cell[1027427, 29394, 427, 14, 70, "Text"],
Cell[1027857, 29410, 83, 3, 70, "Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[1028001, 29420, 64, 1, 57, "ReferencesSection",
  CellTags->"T[Ref[1]]"],
Cell[1028068, 29423, 270, 9, 70, "BibliographyItem",
  CellTags->"Abramson03"],
Cell[1028341, 29434, 321, 11, 70, "BibliographyItem",
  CellTags->"Acedo03"],
Cell[1028665, 29447, 258, 9, 70, "BibliographyItem",
  CellTags->"Adler78"],
Cell[1028926, 29458, 294, 9, 70, "BibliographyItem",
  CellTags->"Aguirre01"],
Cell[1029223, 29469, 279, 9, 70, "BibliographyItem",
  CellTags->"Aguirre03"],
Cell[1029505, 29480, 349, 11, 70, "BibliographyItem",
  CellTags->"Alonso03"],
Cell[1029857, 29493, 274, 9, 70, "BibliographyItem",
  CellTags->"Angelo03"],
Cell[1030134, 29504, 302, 9, 70, "BibliographyItem",
  CellTags->"Atakishiyev01"],
Cell[1030439, 29515, 297, 9, 70, "BibliographyItem",
  CellTags->"Atakishiyev03"],
Cell[1030739, 29526, 348, 11, 70, "BibliographyItem",
  CellTags->"Atakishiyev04"],
Cell[1031090, 29539, 264, 9, 70, "BibliographyItem",
  CellTags->"Azzam82"],
Cell[1031357, 29550, 332, 11, 70, "BibliographyItem",
  CellTags->"Baake99"],
Cell[1031692, 29563, 332, 11, 70, "BibliographyItem",
  CellTags->"BaezDuarte03"],
Cell[1032027, 29576, 316, 9, 70, "BibliographyItem",
  CellTags->"Baker96"],
Cell[1032346, 29587, 293, 9, 70, "BibliographyItem",
  CellTags->"Balcou96"],
Cell[1032642, 29598, 273, 9, 70, "BibliographyItem",
  CellTags->"Ballentine98"],
Cell[1032918, 29609, 301, 9, 70, "BibliographyItem",
  CellTags->"Baltes76"],
Cell[1033222, 29620, 278, 9, 70, "BibliographyItem",
  CellTags->"Bajnok02"],
Cell[1033503, 29631, 279, 9, 70, "BibliographyItem",
  CellTags->"Barbashov67"],
Cell[1033785, 29642, 273, 9, 70, "BibliographyItem",
  CellTags->"Barlow90"],
Cell[1034061, 29653, 318, 10, 70, "BibliographyItem",
  CellTags->"Barthelemy00"],
Cell[1034382, 29665, 329, 10, 70, "BibliographyItem",
  CellTags->"Baruch10"],
Cell[1034714, 29677, 268, 9, 70, "BibliographyItem",
  CellTags->"Bayfield99"],
Cell[1034985, 29688, 265, 9, 70, "BibliographyItem",
  CellTags->"Beaver04"],
Cell[1035253, 29699, 241, 9, 70, "BibliographyItem",
  CellTags->"Bell70"],
Cell[1035497, 29710, 345, 11, 70, "BibliographyItem",
  CellTags->"Belloni03"],
Cell[1035845, 29723, 304, 9, 70, "BibliographyItem",
  CellTags->"Belmonte01"],
Cell[1036152, 29734, 352, 11, 70, "BibliographyItem",
  CellTags->"Berezovoj03a"],
Cell[1036507, 29747, 329, 9, 70, "BibliographyItem",
  CellTags->"Berry79"],
Cell[1036839, 29758, 262, 9, 70, "BibliographyItem",
  CellTags->"Berry79b"],
Cell[1037104, 29769, 261, 9, 70, "BibliographyItem",
  CellTags->"Besprosvany01"],
Cell[1037368, 29780, 252, 9, 70, "BibliographyItem",
  CellTags->"Betchov65"],
Cell[1037623, 29791, 285, 9, 70, "BibliographyItem",
  CellTags->"Bhattacharya02"],
Cell[1037911, 29802, 362, 9, 70, "BibliographyItem",
  CellTags->"BialnynickiBirula83"],
Cell[1038276, 29813, 262, 9, 70, "BibliographyItem",
  CellTags->"Blochintsev52"],
Cell[1038541, 29824, 313, 9, 70, "BibliographyItem",
  CellTags->"Bode01"],
Cell[1038857, 29835, 326, 11, 70, "BibliographyItem",
  CellTags->"Bogomolny04"],
Cell[1039186, 29848, 301, 9, 70, "BibliographyItem",
  CellTags->"Bolivar04"],
Cell[1039490, 29859, 329, 10, 70, "BibliographyItem",
  CellTags->"Borwein03"],
Cell[1039822, 29871, 306, 9, 70, "BibliographyItem",
  CellTags->"Borwein04"],
Cell[1040131, 29882, 250, 9, 70, "BibliographyItem",
  CellTags->"Bosanac83"],
Cell[1040384, 29893, 287, 9, 70, "BibliographyItem",
  CellTags->"Brack93"],
Cell[1040674, 29904, 265, 9, 70, "BibliographyItem",
  CellTags->"Brack98"],
Cell[1040942, 29915, 260, 9, 70, "BibliographyItem",
  CellTags->"Brenier04"],
Cell[1041205, 29926, 321, 9, 70, "BibliographyItem",
  CellTags->"Breuer02"],
Cell[1041529, 29937, 249, 9, 70, "BibliographyItem",
  CellTags->"Briggs91"],
Cell[1041781, 29948, 323, 11, 70, "BibliographyItem",
  CellTags->"Brunelli97"],
Cell[1042107, 29961, 281, 9, 70, "BibliographyItem",
  CellTags->"Burchnall30"],
Cell[1042391, 29972, 255, 9, 70, "BibliographyItem",
  CellTags->"Buttke88"],
Cell[1042649, 29983, 315, 9, 70, "BibliographyItem",
  CellTags->"Byron70"],
Cell[1042967, 29994, 276, 9, 70, "BibliographyItem",
  CellTags->"Camassa94"],
Cell[1043246, 30005, 325, 11, 70, "BibliographyItem",
  CellTags->"Cametti02"],
Cell[1043574, 30018, 280, 9, 70, "BibliographyItem",
  CellTags->"Caputo01"],
Cell[1043857, 30029, 293, 9, 70, "BibliographyItem",
  CellTags->"Cardeso03"],
Cell[1044153, 30040, 329, 11, 70, "BibliographyItem",
  CellTags->"Cartwright02"],
Cell[1044485, 30053, 298, 9, 70, "BibliographyItem",
  CellTags->"Carvalho04"],
Cell[1044786, 30064, 240, 9, 70, "BibliographyItem",
  CellTags->"Casati96"],
Cell[1045029, 30075, 277, 9, 70, "BibliographyItem",
  CellTags->"CerrutiSola96"],
Cell[1045309, 30086, 289, 9, 70, "BibliographyItem",
  CellTags->"ChaosCador04"],
Cell[1045601, 30097, 273, 9, 70, "BibliographyItem",
  CellTags->"Chate87"],
Cell[1045877, 30108, 289, 9, 70, "BibliographyItem",
  CellTags->"Chatteraj04"],
Cell[1046169, 30119, 252, 9, 70, "BibliographyItem",
  CellTags->"Chellone71"],
Cell[1046424, 30130, 286, 9, 70, "BibliographyItem",
  CellTags->"Christiansen90"],
Cell[1046713, 30141, 267, 9, 70, "BibliographyItem",
  CellTags->"Chang86"],
Cell[1046983, 30152, 267, 9, 70, "BibliographyItem",
  CellTags->"Chruscinski98"],
Cell[1047253, 30163, 268, 9, 70, "BibliographyItem",
  CellTags->"Ciattoni04"],
Cell[1047524, 30174, 287, 9, 70, "BibliographyItem",
  CellTags->"Cieslinski86"],
Cell[1047814, 30185, 273, 9, 70, "BibliographyItem",
  CellTags->"Chun03"],
Cell[1048090, 30196, 278, 9, 70, "BibliographyItem",
  CellTags->"Ciattoni04"],
Cell[1048371, 30207, 273, 9, 70, "BibliographyItem",
  CellTags->"Clarkson03"],
Cell[1048647, 30218, 286, 9, 70, "BibliographyItem",
  CellTags->"Cohen95"],
Cell[1048936, 30229, 287, 9, 70, "BibliographyItem",
  CellTags->"Crampin99"],
Cell[1049226, 30240, 272, 9, 70, "BibliographyItem",
  CellTags->"Crampin01"],
Cell[1049501, 30251, 283, 9, 70, "BibliographyItem",
  CellTags->"Crampin02"],
Cell[1049787, 30262, 288, 9, 70, "BibliographyItem",
  CellTags->"Crampin02b"],
Cell[1050078, 30273, 294, 9, 70, "BibliographyItem",
  CellTags->"Cuccietti02"],
Cell[1050375, 30284, 362, 11, 70, "BibliographyItem",
  CellTags->"Cucchietti03"],
Cell[1050740, 30297, 305, 9, 70, "BibliographyItem",
  CellTags->"Czirjak00"],
Cell[1051048, 30308, 256, 9, 70, "BibliographyItem",
  CellTags->"Denisov00"],
Cell[1051307, 30319, 250, 9, 70, "BibliographyItem",
  CellTags->"DeSerio03"],
Cell[1051560, 30330, 343, 11, 70, "BibliographyItem",
  CellTags->"Dhar03"],
Cell[1051906, 30343, 313, 11, 70, "BibliographyItem",
  CellTags->"Dowker04"],
Cell[1052222, 30356, 250, 9, 70, "BibliographyItem",
  CellTags->"Driscoll97"],
Cell[1052475, 30367, 322, 9, 70, "BibliographyItem",
  CellTags->"Driscoll02"],
Cell[1052800, 30378, 277, 9, 70, "BibliographyItem",
  CellTags->"Driscoll03"],
Cell[1053080, 30389, 263, 9, 70, "BibliographyItem",
  CellTags->"Dubey79"],
Cell[1053346, 30400, 278, 9, 70, "BibliographyItem",
  CellTags->"Duxbury95"],
Cell[1053627, 30411, 264, 9, 70, "BibliographyItem",
  CellTags->"Encinosa03"],
Cell[1053894, 30422, 336, 11, 70, "BibliographyItem",
  CellTags->"Encinosa04"],
Cell[1054233, 30435, 267, 9, 70, "BibliographyItem",
  CellTags->"Englisch91"],
Cell[1054503, 30446, 335, 9, 70, "BibliographyItem",
  CellTags->"Ericksen84"],
Cell[1054841, 30457, 289, 9, 70, "BibliographyItem",
  CellTags->"Farkas03"],
Cell[1055133, 30468, 260, 9, 70, "BibliographyItem",
  CellTags->"Feigenbaum78"],
Cell[1055396, 30479, 335, 11, 70, "BibliographyItem",
  CellTags->"Felder02"],
Cell[1055734, 30492, 351, 10, 70, "BibliographyItem",
  CellTags->"Felsenthal98"],
Cell[1056088, 30504, 252, 9, 70, "BibliographyItem",
  CellTags->"Ferraro04"],
Cell[1056343, 30515, 322, 10, 70, "BibliographyItem",
  CellTags->"Foeldi03"],
Cell[1056668, 30527, 249, 9, 70, "BibliographyItem",
  CellTags->"Fornberg98"],
Cell[1056920, 30538, 269, 9, 70, "BibliographyItem",
  CellTags->"Fornberg99"],
Cell[1057192, 30549, 267, 9, 70, "BibliographyItem",
  CellTags->"Friesecke02"],
Cell[1057462, 30560, 280, 9, 70, "BibliographyItem",
  CellTags->"Friesecke03"],
Cell[1057745, 30571, 334, 11, 70, "BibliographyItem",
  CellTags->"Frisch03"],
Cell[1058082, 30584, 264, 9, 70, "BibliographyItem",
  CellTags->"Galleani02"],
Cell[1058349, 30595, 267, 9, 70, "BibliographyItem",
  CellTags->"Galleani02b"],
Cell[1058619, 30606, 301, 9, 70, "BibliographyItem",
  CellTags->"Gardiner00"],
Cell[1058923, 30617, 265, 9, 70, "BibliographyItem",
  CellTags->"Gaspard89"],
Cell[1059191, 30628, 273, 9, 70, "BibliographyItem",
  CellTags->"Gillet01"],
Cell[1059467, 30639, 272, 9, 70, "BibliographyItem",
  CellTags->"Gladwell02"],
Cell[1059742, 30650, 254, 9, 70, "BibliographyItem",
  CellTags->"Goldman84"],
Cell[1059999, 30661, 277, 9, 70, "BibliographyItem",
  CellTags->"Golovin03"],
Cell[1060279, 30672, 253, 9, 70, "BibliographyItem",
  CellTags->"Goos47"],
Cell[1060535, 30683, 265, 9, 70, "BibliographyItem",
  CellTags->"Goos49"],
Cell[1060803, 30694, 354, 11, 70, "BibliographyItem",
  CellTags->"Greenbaum04"],
Cell[1061160, 30707, 310, 9, 70, "BibliographyItem",
  CellTags->"Grosche98"],
Cell[1061473, 30718, 324, 11, 70, "BibliographyItem",
  CellTags->"Gutierrez04"],
Cell[1061800, 30731, 277, 9, 70, "BibliographyItem",
  CellTags->"Gutman04"],
Cell[1062080, 30742, 333, 11, 70, "BibliographyItem",
  CellTags->"Habib98"],
Cell[1062416, 30755, 365, 11, 70, "BibliographyItem",
  CellTags->"Habib00"],
Cell[1062784, 30768, 315, 11, 70, "BibliographyItem",
  CellTags->"Hauswirth00"],
Cell[1063102, 30781, 270, 9, 70, "BibliographyItem",
  CellTags->"Helmkamp94"],
Cell[1063375, 30792, 261, 9, 70, "BibliographyItem",
  CellTags->"Hicks59"],
Cell[1063639, 30803, 287, 9, 70, "BibliographyItem",
  CellTags->"Hinch91"],
Cell[1063929, 30814, 324, 11, 70, "BibliographyItem",
  CellTags->"Hlushchuk03"],
Cell[1064256, 30827, 274, 9, 70, "BibliographyItem",
  CellTags->"Hobiki95"],
Cell[1064533, 30838, 273, 9, 70, "BibliographyItem",
  CellTags->"Hobiki96"],
Cell[1064809, 30849, 323, 11, 70, "BibliographyItem",
  CellTags->"Holm03"],
Cell[1065135, 30862, 264, 9, 70, "BibliographyItem",
  CellTags->"Holm03b"],
Cell[1065402, 30873, 282, 9, 70, "BibliographyItem",
  CellTags->"Homolya03"],
Cell[1065687, 30884, 253, 9, 70, "BibliographyItem",
  CellTags->"Homolya03b"],
Cell[1065943, 30895, 258, 9, 70, "BibliographyItem",
  CellTags->"Horvat03"],
Cell[1066204, 30906, 269, 9, 70, "BibliographyItem",
  CellTags->"Horvat03b"],
Cell[1066476, 30917, 281, 9, 70, "BibliographyItem",
  CellTags->"Hu00"],
Cell[1066760, 30928, 262, 9, 70, "BibliographyItem",
  CellTags->"Huang04"],
Cell[1067025, 30939, 282, 9, 70, "BibliographyItem",
  CellTags->"Hyouguchi04"],
Cell[1067310, 30950, 260, 9, 70, "BibliographyItem",
  CellTags->"Ignatovich04"],
Cell[1067573, 30961, 269, 9, 70, "BibliographyItem",
  CellTags->"Jacoboni04"],
Cell[1067845, 30972, 359, 11, 70, "BibliographyItem",
  CellTags->"Jakobson04"],
Cell[1068207, 30985, 345, 11, 70, "BibliographyItem",
  CellTags->"Jacquod02"],
Cell[1068555, 30998, 324, 11, 70, "BibliographyItem",
  CellTags->"Jordan01"],
Cell[1068882, 31011, 251, 9, 70, "BibliographyItem",
  CellTags->"Joshi75"],
Cell[1069136, 31022, 324, 10, 70, "BibliographyItem",
  CellTags->"Kalhous04"],
Cell[1069463, 31034, 262, 9, 70, "BibliographyItem",
  CellTags->"Kallunki00"],
Cell[1069728, 31045, 352, 11, 70, "BibliographyItem",
  CellTags->"Karkuszewski00"],
Cell[1070083, 31058, 261, 9, 70, "BibliographyItem",
  CellTags->"Kenfack04"],
Cell[1070347, 31069, 279, 9, 70, "BibliographyItem",
  CellTags->"Kim03"],
Cell[1070629, 31080, 268, 9, 70, "BibliographyItem",
  CellTags->"Knowles04"],
Cell[1070900, 31091, 298, 9, 70, "BibliographyItem",
  CellTags->"Knuth69"],
Cell[1071201, 31102, 265, 9, 70, "BibliographyItem",
  CellTags->"Koch94"],
Cell[1071469, 31113, 251, 9, 70, "BibliographyItem",
  CellTags->"Kokubun98"],
Cell[1071723, 31124, 258, 9, 70, "BibliographyItem",
  CellTags->"Kong04"],
Cell[1071984, 31135, 315, 9, 70, "BibliographyItem",
  CellTags->"Koppenfels59"],
Cell[1072302, 31146, 273, 9, 70, "BibliographyItem",
  CellTags->"Kostadt00"],
Cell[1072578, 31157, 331, 11, 70, "BibliographyItem",
  CellTags->"Krapivsky03"],
Cell[1072912, 31170, 241, 9, 70, "BibliographyItem",
  CellTags->"Krug02"],
Cell[1073156, 31181, 269, 9, 70, "BibliographyItem",
  CellTags->"Kuttler84"],
Cell[1073428, 31192, 277, 9, 70, "BibliographyItem",
  CellTags->"Lai00"],
Cell[1073708, 31203, 274, 9, 70, "BibliographyItem",
  CellTags->"Lane95"],
Cell[1073985, 31214, 259, 9, 70, "BibliographyItem",
  CellTags->"Lanford82"],
Cell[1074247, 31225, 308, 9, 70, "BibliographyItem",
  CellTags->"Lapidus96"],
Cell[1074558, 31236, 302, 9, 70, "BibliographyItem",
  CellTags->"LeBerre02"],
Cell[1074863, 31247, 248, 9, 70, "BibliographyItem",
  CellTags->"Lee95"],
Cell[1075114, 31258, 245, 9, 70, "BibliographyItem",
  CellTags->"Lee96"],
Cell[1075362, 31269, 246, 9, 70, "BibliographyItem",
  CellTags->"Lee97"],
Cell[1075611, 31280, 251, 9, 70, "BibliographyItem",
  CellTags->"Lee02"],
Cell[1075865, 31291, 323, 11, 70, "BibliographyItem",
  CellTags->"Lemos99"],
Cell[1076191, 31304, 267, 9, 70, "BibliographyItem",
  CellTags->"Lesne98"],
Cell[1076461, 31315, 261, 9, 70, "BibliographyItem",
  CellTags->"Liu01"],
Cell[1076725, 31326, 268, 9, 70, "BibliographyItem",
  CellTags->"Lopez03"],
Cell[1076996, 31337, 252, 9, 70, "BibliographyItem",
  CellTags->"Lopez91"],
Cell[1077251, 31348, 254, 9, 70, "BibliographyItem",
  CellTags->"Lopez02"],
Cell[1077508, 31359, 319, 9, 70, "BibliographyItem",
  CellTags->"Lopuszanski99"],
Cell[1077830, 31370, 311, 11, 70, "BibliographyItem",
  CellTags->"Lorente04"],
Cell[1078144, 31383, 263, 9, 70, "BibliographyItem",
  CellTags->"Lou02"],
Cell[1078410, 31394, 317, 11, 70, "BibliographyItem",
  CellTags->"Loutsenko02"],
Cell[1078730, 31407, 317, 11, 70, "BibliographyItem",
  CellTags->"Loutsenko03"],
Cell[1079050, 31420, 255, 9, 70, "BibliographyItem",
  CellTags->"Lu04"],
Cell[1079308, 31431, 274, 9, 70, "BibliographyItem",
  CellTags->"Lu04"],
Cell[1079585, 31442, 295, 9, 70, "BibliographyItem",
  CellTags->"Lyubomudrov03"],
Cell[1079883, 31453, 279, 9, 70, "BibliographyItem",
  CellTags->"MacMahon78"],
Cell[1080165, 31464, 254, 9, 70, "BibliographyItem",
  CellTags->"Maitra00"],
Cell[1080422, 31475, 290, 9, 70, "BibliographyItem",
  CellTags->"Malhotra02"],
Cell[1080715, 31486, 309, 11, 70, "BibliographyItem",
  CellTags->"Marder04"],
Cell[1081027, 31499, 317, 9, 70, "BibliographyItem",
  CellTags->"Mattila95"],
Cell[1081347, 31510, 266, 9, 70, "BibliographyItem",
  CellTags->"McCartin04"],
Cell[1081616, 31521, 271, 9, 70, "BibliographyItem",
  CellTags->"McDonald88"],
Cell[1081890, 31532, 255, 9, 70, "BibliographyItem",
  CellTags->"Menski03"],
Cell[1082148, 31543, 272, 9, 70, "BibliographyItem",
  CellTags->"Monteoliva00"],
Cell[1082423, 31554, 270, 9, 70, "BibliographyItem",
  CellTags->"Monteoliva01"],
Cell[1082696, 31565, 272, 9, 70, "BibliographyItem",
  CellTags->"MoralesRuiz01"],
Cell[1082971, 31576, 268, 9, 70, "BibliographyItem",
  CellTags->"Muratov96"],
Cell[1083242, 31587, 270, 9, 70, "BibliographyItem",
  CellTags->"Muratov01"],
Cell[1083515, 31598, 325, 11, 70, "BibliographyItem",
  CellTags->"Netrusov03"],
Cell[1083843, 31611, 252, 9, 70, "BibliographyItem",
  CellTags->"Nieto70"],
Cell[1084098, 31622, 293, 9, 70, "BibliographyItem",
  CellTags->"Noid80"],
Cell[1084394, 31633, 284, 9, 70, "BibliographyItem",
  CellTags->"Novaes03"],
Cell[1084681, 31644, 241, 9, 70, "BibliographyItem",
  CellTags->"Nye03"],
Cell[1084925, 31655, 271, 9, 70, "BibliographyItem",
  CellTags->"O'Connell03"],
Cell[1085199, 31666, 289, 9, 70, "BibliographyItem",
  CellTags->"Okada03"],
Cell[1085491, 31677, 313, 11, 70, "BibliographyItem",
  CellTags->"Ota03"],
Cell[1085807, 31690, 278, 9, 70, "BibliographyItem",
  CellTags->"Parekh95"],
Cell[1086088, 31701, 275, 9, 70, "BibliographyItem",
  CellTags->"Pattanayak92"],
Cell[1086366, 31712, 294, 9, 70, "BibliographyItem",
  CellTags->"Pattanyak03"],
Cell[1086663, 31723, 365, 11, 70, "BibliographyItem",
  CellTags->"Pennetta02"],
Cell[1087031, 31736, 252, 9, 70, "BibliographyItem",
  CellTags->"Porras98"],
Cell[1087286, 31747, 280, 9, 70, "BibliographyItem",
  CellTags->"Porras00"],
Cell[1087569, 31758, 269, 9, 70, "BibliographyItem",
  CellTags->"Prosen00"],
Cell[1087841, 31769, 265, 9, 70, "BibliographyItem",
  CellTags->"Pullen81"],
Cell[1088109, 31780, 315, 11, 70, "BibliographyItem",
  CellTags->"Radozycki04"],
Cell[1088427, 31793, 286, 9, 70, "BibliographyItem",
  CellTags->"Rasband90"],
Cell[1088716, 31804, 298, 9, 70, "BibliographyItem",
  CellTags->"Reynolds94"],
Cell[1089017, 31815, 293, 9, 70, "BibliographyItem",
  CellTags->"Reynolds97"],
Cell[1089313, 31826, 309, 11, 70, "BibliographyItem",
  CellTags->"Rivin03"],
Cell[1089625, 31839, 278, 9, 70, "BibliographyItem",
  CellTags->"Russ97"],
Cell[1089906, 31850, 247, 9, 70, "BibliographyItem",
  CellTags->"Russ01"],
Cell[1090156, 31861, 259, 9, 70, "BibliographyItem",
  CellTags->"Russ02"],
Cell[1090418, 31872, 254, 9, 70, "BibliographyItem",
  CellTags->"Sakajo04"],
Cell[1090675, 31883, 247, 9, 70, "BibliographyItem",
  CellTags->"Sapoval89"],
Cell[1090925, 31894, 280, 9, 70, "BibliographyItem",
  CellTags->"Sapoval91"],
Cell[1091208, 31905, 262, 9, 70, "BibliographyItem",
  CellTags->"Sapoval93"],
Cell[1091473, 31916, 281, 9, 70, "BibliographyItem",
  CellTags->"Sapoval97"],
Cell[1091757, 31927, 348, 11, 70, "BibliographyItem",
  CellTags->"Schmidt02"],
Cell[1092108, 31940, 254, 9, 70, "BibliographyItem",
  CellTags->"Schwarz88"],
Cell[1092365, 31951, 275, 9, 70, "BibliographyItem",
  CellTags->"Scott03"],
Cell[1092643, 31962, 255, 9, 70, "BibliographyItem",
  CellTags->"Shigehara94"],
Cell[1092901, 31973, 286, 9, 70, "BibliographyItem",
  CellTags->"Silvestrov02"],
Cell[1093190, 31984, 296, 9, 70, "BibliographyItem",
  CellTags->"Silvestrov03"],
Cell[1093489, 31995, 306, 9, 70, "BibliographyItem",
  CellTags->"Sneddon66"],
Cell[1093798, 32006, 340, 9, 70, "BibliographyItem",
  CellTags->"Solin04"],
Cell[1094141, 32017, 268, 9, 70, "BibliographyItem",
  CellTags->"Sridhar94"],
Cell[1094412, 32028, 254, 9, 70, "BibliographyItem",
  CellTags->"Stakgold50"],
Cell[1094669, 32039, 341, 11, 70, "BibliographyItem",
  CellTags->"Stenull03"],
Cell[1095013, 32052, 254, 9, 70, "BibliographyItem",
  CellTags->"Straley89"],
Cell[1095270, 32063, 298, 9, 70, "BibliographyItem",
  CellTags->"Takahashi86"],
Cell[1095571, 32074, 265, 9, 70, "BibliographyItem",
  CellTags->"Tang02"],
Cell[1095839, 32085, 294, 9, 70, "BibliographyItem",
  CellTags->"Toscana01"],
Cell[1096136, 32096, 335, 11, 70, "BibliographyItem",
  CellTags->"Trzetrzelewski03"],
Cell[1096474, 32109, 281, 9, 70, "BibliographyItem",
  CellTags->"Tsubota00"],
Cell[1096758, 32120, 334, 11, 70, "BibliographyItem",
  CellTags->"Ujevic03"],
Cell[1097095, 32133, 312, 11, 70, "BibliographyItem",
  CellTags->"Vernov02"],
Cell[1097410, 32146, 312, 11, 70, "BibliographyItem",
  CellTags->"Vernov03"],
Cell[1097725, 32159, 312, 9, 70, "BibliographyItem",
  CellTags->"VigoAguiar03"],
Cell[1098040, 32170, 277, 9, 70, "BibliographyItem",
  CellTags->"Vul84"],
Cell[1098320, 32181, 257, 9, 70, "BibliographyItem",
  CellTags->"Walker03"],
Cell[1098580, 32192, 259, 9, 70, "BibliographyItem",
  CellTags->"Wang04"],
Cell[1098842, 32203, 276, 9, 70, "BibliographyItem",
  CellTags->"Wells94"],
Cell[1099121, 32214, 257, 9, 70, "BibliographyItem",
  CellTags->"Wigley72"],
Cell[1099381, 32225, 245, 9, 70, "BibliographyItem",
  CellTags->"Wirzba99"],
Cell[1099629, 32236, 317, 11, 70, "BibliographyItem",
  CellTags->"Wong02"],
Cell[1099949, 32249, 271, 9, 70, "BibliographyItem",
  CellTags->"Wu95"],
Cell[1100223, 32260, 302, 9, 70, "BibliographyItem",
  CellTags->"Yosibash98"],
Cell[1100528, 32271, 288, 9, 70, "BibliographyItem",
  CellTags->"Yuan00"],
Cell[1100819, 32282, 253, 9, 70, "BibliographyItem",
  CellTags->"Zanzatto96"],
Cell[1101075, 32293, 258, 9, 70, "BibliographyItem",
  CellTags->"Zeyman85"],
Cell[1101336, 32304, 263, 9, 70, "BibliographyItem",
  CellTags->"Ziff80"],
Cell[1101602, 32315, 273, 9, 70, "BibliographyItem",
  CellTags->"Ziolkowski01"],
Cell[1101878, 32326, 244, 9, 70, "BibliographyItem",
  CellTags->"Zurek01"],
Cell[1102125, 32337, 251, 9, 70, "BibliographyItem",
  CellTags->"Zurek02"],
Cell[1102379, 32348, 252, 9, 70, "BibliographyItem",
  CellTags->"Zurek03"],
Cell[1102634, 32359, 334, 11, 70, "BibliographyItem",
  CellTags->"Zyczkowski04"]
}, Closed]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

